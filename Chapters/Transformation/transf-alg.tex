Before detailing the algorithm underlying the \hilecop{} model-to-text
transformation, we want to point out the necessity to automate the
transformation. Judging by the appearance of the \hvhdl{} design
generated from the input SITPN model, the reader could rightly ask why
the designers of hardware circuits that are using the \hilecop{}
methodology do not start directly by writing down the \vhdl{}
code. The reasons are many. First, handling the interconnections
between PCIs and TCIs is simple enough when the number of places and
transitions of the input SITPN is few, however, it becomes a lot more
tedious with the increase of the size of models. To give an example,
the \textsf{Neurrinov} company\footnote{\url{https://neurinnov.com/}},
which applies the \hilecop{} methodology to the design of critical
digital circuits, has developed a digital circuit model for the
control of the electro-stimulation in neuroprostheses. Once flattened
down, the model is composed of 1097 places and 1666 transitions. The
top-level \vhdl{} design generated from this model represents up to
140000 lines of code. Obviously, the hand-coding of this input model
into a \vhdl{} design would be too error-prone. Moreover, the PN
models offer a lot of opportunities in terms of analysis and
model-checking compared to the ones that exist for \vhdl{}
code. Finally, the graphical aspect of PNs appears to be more fit for
the task of digital architecture design in comparison to plain source
code, as it facilitates the discussions between designers. For these
reasons, we choose to preserve SITPNs as the input models of the
\hilecop{} methodology, and to automatize the transformation into
top-level \hvhdl{} designs.

In this section, we give the algorithm underlying the \hilecop{}
model-to-text transformation. This algorithm is the base of the \coq{}
implementation of the \hilecop{} transformation; the implementation is
presented in Section~\ref{sec:trans-coq-impl}. As presented in
Chapter~\ref{chap:intro}, there exists a \textsf{Java} implementation
of the \hilecop{} methodology. This implementation performs the
generation of \vhdl{} code from a SITPN model. However, the algorithm
of the transformation has never been documented, nor a formal
specification given. The following algorithm is one of the
contribution of this thesis. It has been devised through the
examination of the code of the existing \textsf{Java} implementation,
and through the discussions with the designers of the \hilecop{}
methodology.

\subsection{The \texorpdfstring{\texttt{sitpn_to_hvhdl}}{sitpn\_to\_hvhdl} function}
\label{sec:sitpn-to-hvhdl}

The \hilecop{} transformation algorithm, presented in
Algorithm~\ref{alg:sitpn2hvhdl}, generates a \hvhdl{} design and a
SITPN-to-\hvhdl{} binder from an input SITPN. A SITPN-to-\hvhdl{}
design binder is a structure that binds the \textit{dynamic} elements
of a SITPN, namely: places, transitions, conditions, actions and
functions; to the \textit{dynamic} elements of a \hvhdl{} design,
namely: component instance identifiers and signal identifiers. By
dynamic elements, we mean these elements that value or characteristics
vary in the course of the execution/simulation of the structure.  Such
a binder is generated alongside the transformation and links a SITPN
element to its \hvhdl{} \textit{implementation}, i.e. the \hvhdl{}
element that will supposedly behave similarly to the source SITPN
element at runtime. Thus, the SITPN-to-\hvhdl{} design binder is at
the center of the state similarity relation, presented in
Chapter~\ref{chap:proof}, and that enables the comparison between an
SITPN state and an \hvhdl{} design state. The formal definition of an
SITPN-to-\hvhdl{} design binder is as follows.

\begin{definition}[SITPN-to-\hvhdl{} design binder]
  \label{def:sitpn-to-hvhdl-binder}
  Given a $sitpn\in{}SITPN$ and a \hvhdl{} design $d\in{}design$, a
  SITPN-to-\hvhdl{} design binder $\gamma\in{}WM(sitpn,d)$ is a tuple\\
  ${<}PMap,TMap,CMap,AMap,FMap{>}$ where:
  \begin{itemize}
  \item
    $sitpn={<}P,T,pre,test,inhib,post,M_0,{\succ},\mathcal{A},\mathcal{C},\mathcal{F},
    \mathbb{A},\mathbb{C},\mathbb{F},{I_s}{>}$
  \item $d=$ \vhdle|design| \textit{$id_{e}$ $id_{a}$ gens ports sigs cs}
  \item $PMap\in{}P\rightarrow{}\{id~|~\mathtt{comp}(id,\mathtt{place},g,i,o)\in{}cs\}$
  \item $TMap\in{}T\rightarrow{}\{id~|~\mathtt{comp}(id,\mathtt{transition},g,i,o)\in{}cs\}$
  \item $CMap\in\mathcal{C}\rightarrow\{id~|~(\mathtt{in}, id, t)\in{}ports\}$
  \item $AMap\in\mathcal{A}\rightarrow\{id~|~(\mathtt{out}, id, t)\in{}ports\}$
  \item $FMap\in\mathcal{F}\rightarrow\{id~|~(\mathtt{out}, id, t)\in{}ports\}$        
  \end{itemize}
\end{definition}

As presented in Definition~\ref{def:sitpn-to-hvhdl-binder}, the binder
is composed of five sub-environments that map the different SITPN sets
to identifiers. The $PMap$ and $TMap$ sub-environments map the places
to their corresponding PCI identifiers, and the transitions to their
corresponding TCI identifiers. The $CMap$ sub-environment maps the
conditions to input port identifiers. The $AMap$ and $FMap$
sub-environments map the actions and functions to output port
identifiers.

\begin{notation}
  For a given binder $\gamma$ and an element of an SITPN structure
  $e\in{}P\sqcup{}T\sqcup\mathcal{C}\sqcup\mathcal{A}\sqcup\mathcal{F}$,
  we write $\gamma(e)$ where $e$ is looked up in the appropriate
  function. For instance, for a given $f\in\mathcal{F}$, $\gamma(f)$
  is a shorthand notation for $FMap(f)$ where
  $\gamma={<}\dots,FMap{>}$.
\end{notation}

Algorithm~\ref{alg:sitpn2hvhdl} is the algorithm of the \hilecop{}
model-to-text transformation. The algorithm as four parameters; the
first one is the input SITPN model $sitpn$; $id_e$ and $id_a$ are the
entity and the architecture identifiers for the generated \hvhdl{}
design; $b\in{}P\rightarrow\mathbb{N}$ is the function associating a
maximal marking value to each place of the input SITPN. This function
is the result of the analysis of the input SITPN.

\begin{center}
  \begin{algorithm}[H]
    \DontPrintSemicolon

    \SetAlFnt{\fontsize{11}{13}\selectfont}
    
    \SetAlCapFnt{\fontsize{11}{13}\selectfont}
    \SetAlCapNameFnt{\fontsize{11}{13}\selectfont}
    % \NoCaptionOfAlgo

    \caption{\texttt{sitpn\_to\_hvhdl}($sitpn$, $id_e$, $id_a$, $b$)}
    \label{alg:sitpn2hvhdl}
    
    \AlFnt % overriding the new font

    $d\leftarrow\mathtt{design}$ $id_e$ $id_a$ $\emptyset$ $\emptyset$ $\emptyset$ $\mathtt{null}$\; \label{line:init-design}
    $\gamma\leftarrow\emptyset$\; \label{line:init-binder}
    \BlankLine

    \texttt{generate\_architecture}($sitpn$, $d$, $\gamma$, $b$)\; \label{line:genarch}
    \texttt{generate\_interconnections}($sitpn$, $d$, $\gamma$)\; \label{line:geninter}
    \texttt{generate\_ports}($sitpn$, $d$, $\gamma$)\; \label{line:genports}
    \BlankLine  

    \Return{($d$,$\gamma$)}\;
  \end{algorithm}
\end{center}

In Algorithm~\ref{alg:sitpn2hvhdl}, Line~\ref{line:init-design}
creates the initial \hvhdl{} design structure and assigns it to the
variable $d$. Initially, the design has an empty port declaration set,
an empty internal signal declaration set, and a behavior defined by
the \texttt{null} statement. The design generated by the
\texttt{sitpn\_to\_hvhdl} function has an empty set of generic
constants; this set stays empty even at the end of the
transformation. Line~\ref{line:init-binder} initializes the $\gamma$
binder with empty sub-environments. From Lines~\ref{line:genarch} to
\ref{line:genports}, the called procedures modify the design and the
binder structures. Each part of the sequence corresponds to one step
of the transformation, which were outlined in
Section~\ref{sec:informal-transf}. The content of the
\texttt{generate\_architecture} function is detailed in
Algorithms~\ref{alg:genarch}, \ref{alg:genpcis} and \ref{alg:gentcis}.
The content of the \texttt{generate\_interconnections} function is
detailed in Algorithm~\ref{alg:geninter}. The content of the
\texttt{generate\_ports} function is detailled in
Algorithms~\ref{alg:genports}, \ref{alg:genconds}, \ref{alg:genacts}
and \ref{alg:genfuns}.

\begin{notation}
  In the remainder of memoir, we write $\lfloor{}sitpn\rfloor_b$ to
  denote $\texttt{sitpn\_to\_hvhdl}(sitpn,id_e,id_a,$ $b)$, for all
  $sitpn\in{}SITPN$, $b\in{}P\rightarrow\mathbb{N}$ and identifiers
  $id_a,id_e$.
\end{notation}

\subsection{Primitive functions and sets}
\label{sec:prim-funs}

The description of further functions and algorithms appeals to some
primitive functions and set definitions that we introduce here. Below
are all the sets that we use in the description of the algorithms.

\begin{itemize}
\item
  \texttt{input}$(p)=\{t~\vert~\exists\omega~s.t.~post(t,p)=\omega\}$,
  the set of input transitions of a place $p$.
\item
  \texttt{output}$(p)=\{t~\vert~\exists{}\omega,a~s.t.~pre(p,t)=(\omega,a)\}$,
  the set of output transitions of a place $p$.

\item \texttt{acts}$(p)=\{a~\vert~\mathbb{A}(p,a)=\mathtt{true}\}$,
  the set of actions associated with a place $p$.
\item
  \texttt{input}$(t)=\{p~\vert~\exists\omega,a~s.t.~pre(p,t)=(\omega,a)\}$,
  the set of input places of a transition $t$.
\item
  \texttt{output}$(t)=\{p~\vert~\exists\omega~s.t.~post(t,p)=\omega\}$,
  the set of output places of a transition $t$.
\item
  \texttt{conds}$(t)=\{c~\vert~\mathbb{C}(t,c)=1\lor\mathbb{C}(t,c)=-1\}$,
  the set of conditions associated with a transition $t$.
\item
  \texttt{trs}$(c)=\{t~\vert~\mathbb{C}(t,c)=1\lor\mathbb{C}(t,c)=-1\}$,
  the set of transitions to which a condition $c$ is associated.
\item \texttt{pls}$(a)=\{p~\vert~\mathbb{A}(p,a)=\mathtt{true}\}$, the
  set of places to which an action $a$ is associated.
\item \texttt{trs}$(f)=\{t~\vert~\mathbb{F}(t,f)=\mathtt{true}\}$, the
  set of transitions to which a function $f$ is associated.
\end{itemize}

Every set presented above are \emph{unordered}. However, we assume
that, every time we iterate over the elements of an unordered set with
a \textbf{foreach} statement, the iteration respects an arbitrary
order. This order is always the same through the multiple calls to
\textbf{foreach} statements. Of course, the iteration over the
elements of an \emph{ordered} set with a \textbf{foreach} statement
respects the natural order of the set.

Now, let us introduce some primitive functions and procedures that we
use in the description of the following algorithms.

\begin{itemize}
\item \texttt{output}$_c\in{}P\rightarrow{}2^T$.  The
  \texttt{output}$_c$ function takes a place $p$ as input and yields
  an ordered set of transitions computed as follows:
  \begin{enumerate}
  \item If all conflicts between the output transitions of $p$ are
    solved by mutual exclusion, or if the set of conflicting
    transitions of $p$ is a singleton, then \texttt{output}$_c$
    returns an empty set.
  \item Otherwise, the function tries to establish a total ordering
    over the set of conflicting transitions of $p$ w.r.t the firing
    priority relation:
    \begin{itemize}
    \item If no such ordering can be established (in that case, the
      firing priority relation is ill-formed, and the input SITPN is
      not well-defined), \texttt{output}$_c$ raises an error.
    \item Otherwise, the function returns the ordered set, with the
      top-level priority transition at the head.
    \end{itemize}
  \end{enumerate}

\item \texttt{output}$_{nc}\in{}P\rightarrow{}2^T$.  The
  \texttt{output}$_{nc}$ function takes a place $p$ as input and
  yields an unordered set of transitions computed as follows:
  \begin{itemize}
  \item If all conflicts between the output transitions of $p$ are
    solved by mutual exclusion, or if the set of conflicting
    transitions of $p$ is a singleton, then, the function returns the
    set of output transitions of $p$, i.e. \texttt{output}$(p)$ as
    defined above.
  
  \item Otherwise, the function returns the set of output transitions
    of $p$ connected through a \texttt{test} or an \texttt{inhib} arc,
    i.e.
    $\{t~\vert~\exists\omega~s.t.~pre(p,t)=(\omega,\mathtt{test})\lor{}pre(p,t)=(\omega,\mathtt{inhib})\}$.
  \end{itemize}

\item \texttt{cassoc}$(map,id,x)$ where $map$ is either an input port
  map or an output port map, $id$ is an identifier, $x$ is an
  expression or a name (i.e. a simple or indexed identifier). The
  \texttt{cassoc} procedure adds an association of the form
  $(id(i),x)$ to the $map$ structure. The index $i$ is computed as
  follows based on the content of $map$:
  \begin{enumerate}
  \item looks up $id(j)$ with $max(j)$ in the formal parts of $map$
  \item if no such $j$, adds $(id(0),x)$ in $map$
  \item if such $j$, adds $(id(j+1),x)$ in $map$
  \end{enumerate}

  \noindent{}\textit{Examples:}
  \begin{itemize}
  \item
    \texttt{cassoc}$(~\mathtt{\{(s(0),\mathtt{true}),(s(1),\mathtt{false})\}},~\mathtt{s},~\mathtt{true})$
    yields the resulting map \\
    $\mathtt{\{(s(0),\mathtt{true}),(s(1),\mathtt{false}),(s(2),\mathtt{true})\}}$.
  \item
    \texttt{cassoc}$(~\mathtt{\{(s(0),\mathtt{true}),(s(1),\mathtt{false})\}},~\mathtt{a},~\mathtt{3})$
    yields the resulting map \\
    $\mathtt{\{(s(0),\mathtt{true}),(s(1),\mathtt{false}),(a(0),\mathtt{3})\}}$.
  \end{itemize}

\item \texttt{get\_comp}$(id_c, cstmt)$ where $id_c$ is an identifier,
  and $cstmt\in{}\mathrm{cs}$ is a \hvhdl{} concurrent statement. The
  \texttt{get\_comp} function looks up $cstmt$ for a component
  instantiation statement labelled with $id_c$ as a component instance
  identifier, and returns the component instantiation statement when
  found. The \texttt{get\_comp} function throws an error if no
  component instantiation statement with identifier $id_c$ exists in
  $cstmt$, or if there exist multiple component instantiation
  statements with identifier $id_c$ in $cstmt$.
\item \texttt{put\_comp}$(id_c,cistmt,cstmt)$ where $id_c$ is an
  identifier, $cistmt$ is a component instantiation statement, and
  $cstmt\in{}\mathrm{cs}$ is a \hvhdl{} concurrent statement. The
  \texttt{put\_comp} procedure looks up in $cstmt$ for a component
  instantiation statement with identifier $id_c$, and replaces the
  statement with $cistmt$ in $cstmt$. If no CIS with identifier $id_c$
  exists in $cstmt$, then $cistmt$ is directly composed with $cstmt$
  with the \texttt{||} operator. The \texttt{put\_comp} procedure
  throws an error if multiple CIS with identifier $id_c$ exist in
  $cstmt$.
\item \texttt{actual}$(id,map)$ where $id$ is an identifier and $map$
  is a generic, an input port or an output port map. The
  \texttt{actual} function returns the actual part associated with the
  formal part $id$ in $map$, i.e. returns $a$ if $(id,a)\in{}map$. The
  function throws an error if $id$ is not a formal part in $map$, or
  if there are multiple association with $id$ as a formal part in
  $map$.
\item \texttt{genid}$()$. The \texttt{genid} function returns a fresh
  and unique identifier. During the transformation, we appeal to it
  when a new internal signal, a new port or a new component instance
  must be declared or generated.
\end{itemize}

Algorithm~\ref{alg:connect} presents the \texttt{connect} procedure.
This procedure takes an output port map $o$, an input port map $i$, a
name $n$ (i.e. a simple or indexed identifier), an identifier $id$ and
a \hvhdl{} design $d$ as parameters. It generates a Boolean internal
signal $id_s$ and adds it to the internal signal declaration list of
design $d$. Then, the procedure adds the association between the $n$
name and the internal signal $id_s$ to the output port map
$o$. Moreover, the procedure adds an association between a subelement
of $id$, which index will be determined by the \texttt{cassoc}
function, and the internal signal $id_s$ to the input port map $i$. As
a result, $n$ is connected to a subelement of $id$ through the Boolean
internal signal $id_s$. Note that the name $n$ must denote a signal of
the Boolean type, and so must be the subelements of the composite
signal denoted by $id$; otherwise, the output port map $o$ and the
input port map $i$, will not be well-typed at the end of the execution
of the \texttt{connect} procedure.

\begin{center}
  \begin{algorithm}[H] \DontPrintSemicolon

    \SetAlFnt{\fontsize{11}{13}\selectfont}
    
    \SetAlCapFnt{\fontsize{11}{13}\selectfont}
    \SetAlCapNameFnt{\fontsize{11}{13}\selectfont} % \NoCaptionOfAlgo

    \caption{\texttt{connect}($o$, $i$, $n$, $id$, $d$)}
    \label{alg:connect}

    $id_s\leftarrow\mathtt{genid}()$\;
    $d.sigs\leftarrow{}d.sigs\cup\{(id_s,\mathtt{boolean})\}$\;
    $o\leftarrow{}o\cup\{(n,id_s)\}$\;
    \texttt{cassoc}$(i,id,id_s)$\;
  \end{algorithm}
\end{center}

\begin{notation}
  When there is no ambiguity, $id_p$ (resp. $id_t$) denotes the PCI
  (resp. TCI) identifier associated with a given place $p$
  (resp. transition $t$) through $\gamma(p)=id_p$
  (resp. $\gamma(t)=id_t$), where $\gamma$ is the binder returned by
  the \hilecop{} transformation function. Similarly, $id_c$
  (resp. $id_a$ and $id_f$) denotes the input port (resp. output port)
  identifier associated with a given condition $c$ (resp. action $a$
  and function $f$) through $\gamma(c)=id_c$.
\end{notation}

\subsection{Generation of component instances and constant parts}
\label{sec:genarch}

The first step of the transformation generates the PCIs and TCIs,
their generic map, and the constant part of their input port maps, in
the behavior of the \hvhdl{} design. At this moment of the
transformation, places are bound to PCI identifiers, and transitions
are bound to TCI identifiers in the $\gamma$ binder. Also, the
\texttt{marked} output port and the \texttt{fired} output port are
connected to internal signals in the output port map of PCIs and
TCIs. Algorithm~\ref{alg:genarch} presents the content of the
\texttt{generate\_architecture} procedure that implements this first
part of code generation. The \texttt{generate\_architecture} procedure
is decomposed in two procedures: the \texttt{generate\_PCIs} and the
\texttt{generate\_TCIs} procedures.

\begin{center}
  \begin{algorithm}[H]
    \DontPrintSemicolon

    \SetAlFnt{\fontsize{11}{13}\selectfont}
    
    \SetAlCapFnt{\fontsize{11}{13}\selectfont}
    \SetAlCapNameFnt{\fontsize{11}{13}\selectfont}
    % \NoCaptionOfAlgo

    \caption{\texttt{generate\_architecture}($sitpn$, $d$, $\gamma$, $b$)}
    \label{alg:genarch}
    
    \AlFnt % overriding the new font

    \texttt{generate\_PCIs}($sitpn$, $d$, $\gamma$, $b$)\; \label{line:genpcis}
    \texttt{generate\_TCIs}($sitpn$, $d$, $\gamma$)\; \label{line:gentcis}

  \end{algorithm}
\end{center}

The \texttt{generate\_PCIs} procedure, presented in
Algorithm~\ref{alg:genpcis}, has four parameters: $sitpn\in{}SITPN$,
the input SITPN model; $d\in{}design$, the \hvhdl{} design being
generated; $\gamma\in{}WM(sit\-pn,d)$, the binder between $sitpn$ and
$d$; $b\in{}P\rightarrow\mathbb{N}$, the function assigning a
maximal marking value to each place. The procedure iterates over the
set of places of the $sitpn$ parameter. For each place $p$ in the set,
the procedure produces a corresponding PCI $id_p$, and generates its
generic map $g_p$, and its partially-built input and output port maps
$i_p$ and $o_p$.  At the end of the procedure
(Lines~\ref{line:gen-pcomp-id} to \ref{line:gen-bind-p}), a fresh and
unique component identifier $id_p$ is generated, and a new component
instantiation statement, corresponding to the instantiation of the PCI
$id_p$, is composed with the current behavior of design $d$. Finally,
the $\gamma$ binder receives a new couple corresponding to binding of
place $p$ to identifier $id_p$.

\begin{center}
  \begin{algorithm}[H]
    \DontPrintSemicolon

    \SetAlFnt{\fontsize{11}{13}\selectfont}
    
    \SetAlCapFnt{\fontsize{11}{13}\selectfont}
    \SetAlCapNameFnt{\fontsize{11}{13}\selectfont}
    % \NoCaptionOfAlgo

    \caption{\texttt{generate\_PCIs}($sitpn$, $d$, $\gamma$, $b$)}
    \label{alg:genpcis}
    
    \AlFnt % overriding the new font

    \ForEach{$p\in{}P$}{

      \lIf{$\mathtt{input}(p)=\emptyset$ and $\mathtt{output}(p)=\emptyset$}{\label{line:p-isolated}
        \texttt{err}$("p~is~an~isolated~place")$\label{line:p-isolated-err}
      }
      
      \BlankLine
      $g_p\leftarrow\{(\mathtt{mm},b(p)),(\mathtt{ian},\begin{cases}
        1~\mathtt{if}~\mathtt{input}(t)=\emptyset \\
        \vert\mathtt{input}(t)\vert~otherwise\\
      \end{cases}),(\mathtt{oan},\begin{cases}
        1~\mathtt{if}~\mathtt{output}(t)=\emptyset \\
        \vert\mathtt{output}(t)\vert~otherwise\\
      \end{cases})\}$; 
      $i_p\leftarrow\emptyset$; 
      $o_p\leftarrow\emptyset$\; \label{line:init-pcomp}

      \BlankLine
      \lIf{$\mathtt{input}(p)=\emptyset$}{ \label{line:genpcis-inp-p-empty}
        $i_p\leftarrow{}i_p\cup\{(\mathtt{iaw}(0),0),(\mathtt{itf}(0),\mathtt{false})\}$\label{line:iaw-itf-empty}
      }
      \Else{
        $i\leftarrow{}0$\;
        \ForEach{$t\in\mathtt{input}(p)$}{ \label{line:foreach-iaw}
          $i_p\leftarrow{}i_p\cup\{(\mathtt{iaw}(i),post(t,p))\}$\;
          $i\leftarrow{}i+1$\;
        }
      }

      \BlankLine
      \uIf{$\mathtt{output}(p)=\emptyset$}{\label{line:genpcis-out-p-empty}
        $i_p\leftarrow{}i_p\cup\{(\mathtt{oaw}(0),0),(\mathtt{oat}(0),\mathtt{basic}),(\mathtt{otf}(0),\mathtt{false})\}$\;
        \label{line:genpcis-out-p-empty-ip}
        $o_p\leftarrow{}o_p\cup\{(\mathtt{oav},\mathtt{open}),(\mathtt{pauths},\mathtt{open}),(\mathtt{rtt},\mathtt{open})\}$\;
        \label{line:genpcis-out-p-empty-op}
      }
      \Else{
        $i\leftarrow{}0$\;
        \ForEach{$t\in\mathtt{output}_c(p)\cup\mathtt{output}_{nc}(p)$}{\label{line:begin-oaw}
          $(\omega,a)\leftarrow{}pre(p,t)$\;
          $i_p\leftarrow{}i_p\cup\{(\mathtt{oaw}(i),\omega),(\mathtt{oat}(i),a)\}$\;
          $i\leftarrow{}i+1$\;
        }
      }

      \BlankLine
      \lIf{$\mathtt{acts}(p)=\emptyset$}{$o_p\leftarrow{}o_p\cup\{(\mathtt{marked},\mathtt{open})\}$}\label{line:genpcis-acts-empty}
      \Else{
        $id_s\leftarrow{}\mathtt{genid}()$\;
        $d.sigs\leftarrow{}d.sigs\cup\{(id_s,\mathtt{boolean})\}$\;
        $o_p\leftarrow{}o_p\cup\{(\mathtt{marked},id_s)\}$\; \label{line:end-op}
      }
      
      \BlankLine
      $id_p\leftarrow{}\mathtt{genid}()$\;\label{line:gen-pcomp-id}
      $d.cs\leftarrow{}d.cs~\mathtt{||}~\mathtt{comp}(\mathtt{id}_p,\mathtt{place},g_p,i_p,o_p)$\;\label{line:gen-pcomp}
      $\gamma\leftarrow\gamma\cup\{(p,\mathtt{id}_p)\}$\;\label{line:gen-bind-p}
    }
  \end{algorithm}
\end{center}

From Line~\ref{line:p-isolated} to Line~\ref{line:end-op}, the
procedure generates the generic map, the input port map, and the
output port map of the PCI that implements place $p$. First, the
procedure checks if the current place $p$ is isolated, i.e. without
input nor output transitions. An error, with an associated message, is
raised with the \texttt{err} primitive if the test succeeds. The
\hilecop{} transformation raises errors in the presence of an input
SITPN model that does not meet the well-definition property (see
Definition~\ref{def:wd-sitpn}). One part of the well-definition
property pertains to the absence of isolated place in the input
model. Line~\ref{line:init-pcomp} builds the variable $g_p$, and
initializes the variables $i_p$ and $o_p$, respectively holding the
generic map, the input port map and the output port map of the PCI
being generated. The generic map $g_p$ holds three associations: the
association between the \texttt{mm} constant to the maximal marking
value returned by the $b$ function for place $p$, and the association
between the \texttt{ian} (resp. the \texttt{oan} constant) and a
natural number that depends on the size of the set of input
transitions (resp. output transitions) of place $p$.

Line~\ref{line:genpcis-inp-p-empty} tests if the set of input
transitions of $p$ is empty.  The size of the \texttt{iaw} and
\texttt{itf} input ports, which are of the array type, is equal to the
value of the \texttt{ian} constant. Thus, in the case where the
\texttt{ian} constant is associated to $1$ in the generic map $g_p$
(i.e. the set of input transitions of $p$ is empty), the \texttt{iaw}
and \texttt{itf} input ports are composed of one subelement with index
$0$. At Line~\ref{line:iaw-itf-empty}, the sole subelement of the
\texttt{iaw} port is associated with $0$, and the sole subelement of
the \texttt{itf} port is associated with \texttt{false} in the input
port map $i_p$. In the set of input transitions of $p$ holds is not
empty, each subelement of the \texttt{iaw} port is associated with the
weight of the arc between place $p$ and a given input transition $t$.
Note that, in that case, the procedure does not deal with the
connection of the \texttt{itf} port. As the set of input transitions
of $p$ is not empty, the connection of the \texttt{itf} port will be
performed by the \texttt{generate\_interconnections} described in
Algorithm~\ref{alg:geninter}.

Line~\ref{line:genpcis-out-p-empty} tests if the set of output
transitions of $p$ is empty.  The size of the \texttt{oaw},
\texttt{oat} and \texttt{otf} input ports, which are of the array
type, is equal to the value of the \texttt{oan} constant. Thus, in the
case where the \texttt{oan} constant is associated to $1$ in the
generic map $g_p$ (i.e. the set of output transitions of $p$ is
empty), the \texttt{oaw}, \texttt{oat} and \texttt{otf} input ports
are composed of one subelement with index $0$. At
Line~\ref{line:genpcis-out-p-empty-ip}, the sole subelement of the
\texttt{oaw} port is associated with $0$, the sole subelement of the
\texttt{oat} port is associated with \texttt{basic}, and the sole
subelement of the \texttt{otf} port is associated with \texttt{false}
in the input port map $i_p$. Also, in the abscence of output
transitions, the \texttt{oav}, \texttt{pauths} and \texttt{rtt} output
ports are left unconnected, i.e. they are associated with the
\texttt{open} keyword of output port map $o_p$.

If the set of output transitions of $p$ is not empty, the \texttt{oan}
constant is associated with the size of this set in the generic map
$g_p$. Then, each subelement of the \texttt{oaw} (resp. the
\texttt{oat}) port is associated with the weight (resp. the type) of
the arc between place $p$ and a given output transition $t$.  Note
that, in that case, the procedure does not handle the connection of
the \texttt{otf} input port, nor the connection of the \texttt{oav},
\texttt{pauths} and \texttt{rtt} output ports. As the set of output
transitions of $p$ is not empty, these connections will be performed
by the \texttt{generate\_interconnections} described in
Algorithm~\ref{alg:geninter}.

From Line~\ref{line:genpcis-acts-empty} to Line~\ref{line:end-op}, the
\texttt{generate\_PCIs} procedure connects the \texttt{marked} output
port in the output port map $o_p$. If the place $p$ is not associated
with any action, the \texttt{marked} output port is left unconnected,
i.e. connected to the \texttt{open} keyword. Otherwise, the
\texttt{marked} output port is connected to a newly generated internal
signal of the Boolean type. This generated signal joins the internal
signal declaration list of design $d$. The connection between the
\texttt{marked} output port and the internal signal will be used
later, during the generation of the \texttt{action} process (see
Section~\ref{sec:genports}).

Figure~\ref{fig:gen-pci-ex} shows the generic, input port and output
port map of the PCI $id_{p_0}$ (cf. Figure~\ref{fig:transf-arch})
after the execution of the \texttt{generate_PCIs} procedure.

\begin{figure}[H]
  \centering
  \includegraphics[keepaspectratio,width=.4\textwidth]{Figures/Transformation/gen-pci-ex}
  \caption{A graphical representation of the interface of the PCI
    \texttt{id}$_{p_0}$ after the \texttt{generate_PCIs}
    procedure. The generic map associations appear in
    \textcolor{blue}{blue} underneath the PCI. The indexes of
    composite ports appear in \textcolor{blue}{blue} to stress the
    relation between the interface dimensioning and the generic
    constants. The \texttt{m} output port is connected to an internal
    signal represented by a \textcolor{red}{red} wire.}
  \label{fig:gen-pci-ex}
\end{figure}

The \texttt{generate\_TCIs} procedure, presented in
Algorithm~\ref{alg:gentcis}, iterates over the set of transitions $T$
of the $sitpn$ parameter. For each transition $t$ in the set, the
procedure produces a corresponding TCI $id_t$, and generates its
generic map $g_t$, and its partially-built input and output port maps
$i_t$ and $o_t$.  At the end of the procedure
(Lines~\ref{line:gen-tcomp-id} to \ref{line:gen-bind-t}), a fresh and
unique component identifier $id_t$ is generated, and a new component
instantiation statement, corresponding to the instantiation of the TCI
$id_t$, is composed with the current behavior of design $d$. Finally,
the $\gamma$ binder receives a new couple corresponding to binding of
transition $t$ to identifier $id_t$.

\begin{center}
  \begin{algorithm}[H]
    \DontPrintSemicolon

    \SetAlFnt{\fontsize{11}{13}\selectfont}
    
    \SetAlCapFnt{\fontsize{11}{13}\selectfont}
    \SetAlCapNameFnt{\fontsize{11}{13}\selectfont}
    % \NoCaptionOfAlgo

    \caption{\texttt{generate\_TCIs}($sitpn$, $d$, $\gamma$)}
    \label{alg:gentcis}
    
    \AlFnt % overriding the new font

    \ForEach{$t\in{}T$}{

      \lIf{$\mathtt{input}(t)=\emptyset$ and $\mathtt{output}(t)=\emptyset$}{
        \texttt{err}$("t~is~an~isolated~transition")$\label{line:t-isolated}
      }

      \BlankLine
      $g_t\leftarrow\{(\mathtt{tt},\mathtt{get\_ttype}(t)),(\mathtt{mtc},\mathtt{get\_mtc}(t)),$\;
      $(\mathtt{ian},\begin{cases}
        1~\mathtt{if}~\mathtt{input}(t)=\emptyset \\
        \vert\mathtt{input}(t)\vert~otherwise\\
      \end{cases}),(\mathtt{cn},
      \begin{cases}
        1~\mathtt{if}~\mathtt{conds}(t)=\emptyset \\
        \vert\mathtt{conds}(t)\vert~otherwise\\
      \end{cases})\}$\;\label{line:init-gt}

      \BlankLine
      $i_t\leftarrow\{(\mathtt{A},
      \begin{cases}
        0~\mathtt{if}~t\notin{}\mathtt{dom}(I_s) \\
        l(I_s(t))~otherwise\\
      \end{cases}), (\mathtt{B},
      \begin{cases}
        0~\mathtt{if}~t\notin{}\mathtt{dom}(I_s)\lor{}u(I_s(t))=\infty \\
        u(I_s(t))~otherwise\\
      \end{cases})\}$\;\label{line:init-it}

      $id_s\leftarrow{}\mathtt{genid()}$\;\label{line:genid-fired}
      $d.sigs\leftarrow{}d.sigs\cup\{(id_s,boolean)\}$\;\label{line:declid-fired}
      $o_t\leftarrow{}\{(\mathtt{fired},id_s)\}$\;\label{line:connect-fired}
      
      \BlankLine
      \lIf{$\mathtt{input}(t)=\emptyset$}{\label{line:gentcis-input-empty}
        $i_t\leftarrow{}i_t\cup\{(\mathtt{iav}(0),\mathtt{true}),(\mathtt{pauths}(0),\mathtt{true}),(\mathtt{rt}(0),id_s)\}$
        \label{line:gentcis-in-empty-it}
      }
      
      \lIf{$\mathtt{conds}(t)=\emptyset$}{ \label{line:gentcis-conds-empty}
        $i_t\leftarrow{}i_t\cup\{(\mathtt{ic}(0),\mathtt{true})\}$
      } 
      
      \BlankLine
      $id_t\leftarrow{}\mathtt{genid}()$\;\label{line:gen-tcomp-id}
      $d.cs\leftarrow{}d.cs~\mathtt{||}~\mathtt{comp}(\mathtt{id}_t,\mathtt{transition},g_t,i_t,o_t)$\;\label{line:gen-tcomp}
      $\gamma\leftarrow\gamma\cup\{(t,\mathtt{id}_t)\}$\;\label{line:gen-bind-t}
    }
  \end{algorithm}
\end{center}

At Line~\ref{line:t-isolated}, the procedure checks if transition $t$
is isolated, and raises an error accordingly.
Lines~\ref{line:init-gt} to \ref{line:connect-fired} initialize the
variables $g_t$, $i_t$ and $o_t$, respectively holding the generic
map, the input port map and the output port map of the TCI
being-generated. The generic map $g_t$ takes four associations: the
association between the \texttt{tt} constant and the result of the
function call \texttt{get\_ttype}$(t)$, the association between the
\texttt{mtc} constant and the result of the function call
\texttt{get\_mtc}$(t)$, the association between \texttt{ian} and the
size of the set of input places of $t$, and the association between
\texttt{cn} and the size of the set of conditions associated with $t$.
The \texttt{get\_ttype} function returns the type of transition $t$,
i.e. either \texttt{NOT\_TEMPORAL}, \texttt{TEMPORAL\_A\_A},
\texttt{TEMPORAL\_A\_B} or \texttt{TEMPORAL\_A\_INFINITE}, based on
the form of the time interval associated with
$t$. Algorithm~\ref{alg:getttype} describes the \texttt{get\_ttype}
function.

\begin{center}
  \begin{algorithm}[H]
    \DontPrintSemicolon

    \SetAlFnt{\fontsize{11}{13}\selectfont}
    
    \SetAlCapFnt{\fontsize{11}{13}\selectfont}
    \SetAlCapNameFnt{\fontsize{11}{13}\selectfont}
    % \NoCaptionOfAlgo

    \caption{\texttt{get\_ttype}($t$)}
    \label{alg:getttype}
    
    \AlFnt % overriding the new font

    \lIf{$t\notin{}\mathtt{dom}(I_s)$}{
      \Return{\texttt{NOT\_TEMPORAL}}
    }
    \lElseIf{$I_s(t)=[a,a]$}{
      \Return{\texttt{TEMPORAL\_A\_A}}
    }
    \lElseIf{$I_s(t)=[a,b]$}{
      \Return{\texttt{TEMPORAL\_A\_B}}
    }
    \lElseIf{$I_s(t)=[a,\infty]$}{\Return{\texttt{TEMPORAL\_A\_INFINITE}}}
    
  \end{algorithm}
\end{center}

The \texttt{get\_mtc} function determines the maximal value for the
time counter of $t$ based on the form of the time interval associated
with transition $t$. Algorithm~\ref{alg:getmtc} describes the
\texttt{get\_mtc} function.

\begin{center}
  \begin{algorithm}[H]
    \DontPrintSemicolon

    \SetAlFnt{\fontsize{11}{13}\selectfont}
    
    \SetAlCapFnt{\fontsize{11}{13}\selectfont}
    \SetAlCapNameFnt{\fontsize{11}{13}\selectfont}
    % \NoCaptionOfAlgo

    \caption{\texttt{get\_mtc}($t$)}
    \label{alg:getmtc}
    
    \AlFnt % overriding the new font

    \lIf{$t\notin{}\mathtt{dom}(I_s)$}{
      \Return{$1$}
    }
    \lElseIf{$I_s(t)=[a,b]$}{
      \Return{$b$}
    }
    \lElseIf{$I_s(t)=[a,\infty]$}{
      \Return{$a$}
    }
    
  \end{algorithm}
\end{center}

In the \texttt{generate\_TCIs} procedure, Line~\ref{line:init-it} sets
the value of the \texttt{A} and \texttt{B} input ports while
initializing the input port map $i_t$. The \texttt{A} port is
associated with $0$ if the transition $t$ is not a time transition
(i.e. $t$ has no associated time interval, it is not in the domain of
function $I_s$); otherwise, the \texttt{A} port is associated with the
lower bound of the time interval of $t$.  The \texttt{B} input port is
associated with $0$ if transition $t$ is not a time transition or if
its time interval has an infinite upper bound; otherwise, the
\texttt{B} port is associated with the upper bound of the time
interval of $t$. From Lines~\ref{line:genid-fired} to
\ref{line:connect-fired}, the \texttt{generate\_TCIs} procedure
connects the \texttt{fired} output port to a newly generated internal
signal in the output port map $o_p$. This internal signal will then be
connected to the input port map of PCIs during the interconnection
phase of the transformation (see Section~\ref{sec:geninter}).

Line~\ref{line:gentcis-input-empty} checks if the set of input places
of $t$ is empty. If the test succeeds, the \texttt{ian} constant is
associated with $1$ in the generic map $g_t$. The size of the
\texttt{iav}, \texttt{pauths} and \texttt{rt} input ports, which are
of the array type, is equal to the value of the \texttt{ian}
constant. Thus, in the case where the set of input places of $t$ is
empty, the \texttt{iav}, \texttt{pauths} and \texttt{rt} input ports
are composed of one subelement with index $0$. At
Line~\ref{line:gentcis-in-empty-it}, the sole subelements of the
\texttt{iav} and the \texttt{pauths} ports are associated with
\texttt{true}, and the sole subelement of the \texttt{rt} port is
associated with the signal identifier $id_s$. Remember that the
\texttt{fired} output port has been previously connected to the
internal signal $id_s$ in the output port map $o_t$. Thus, the
\texttt{fired} output port is connected to the subelement of the
\texttt{rt} input port with index $0$ through the $id_s$ signal.  This
connection is mandatory to reset the value of the
\texttt{s\_time\_counter} signal (which is an internal signal of the
\texttt{transition} design) in the absence of input places.

Line~\ref{line:gentcis-conds-empty} checks if the set of conditions
attached to $t$ is empty.  The size of the \texttt{ic} input port,
which is of the array type, is equal to the value of the \texttt{cn}
constant. Thus, in the case where the set of conditions attached to
$t$ is empty, the \texttt{ic} input port is composed of one subelement
with index $0$. Then, the sole subelement of the \texttt{ic} port is
associated with \texttt{true} in the input port map $i_t$. If the set
of conditions attached to $t$ is not empty, then the
\texttt{generate\_conds} procedure, presented in
Algorithm~\ref{alg:genconds}, will handle the connection of the
subelements of the \texttt{ic} input port.

Figure~\ref{fig:gen-tci-ex} shows the generic, input port and output
port map of the TCI $id_{t_0}$ (cf. Figure~\ref{fig:transf-arch})
after the execution of the \texttt{generate_TCIs} procedure.

\begin{figure}[H]
  \centering
  \includegraphics[keepaspectratio,width=.4\textwidth]{Figures/Transformation/gen-tci-ex}
  \caption{A graphical representation of the interface of the TCI
    \texttt{id}$_{t_0}$ after the \texttt{generate_TCIs}
    procedure. The generic map associations appear in
    \textcolor{blue}{blue} underneath the TCI. The indexes of
    composite ports appear in \textcolor{blue}{blue} to stress the
    relation between the interface dimensioning and the generic
    constants. The \texttt{f} output port is connected to an internal
    signal represented by a \textcolor{red}{red} wire.}
  \label{fig:gen-tci-ex}
\end{figure}

\subsection{Interconnection of the place and transition component
  instances}
\label{sec:geninter}

After the generation of PCIs and TCIs, and of all constant
associations in their generic and input port maps, the next step of
the transformation performs the interconnections between the
interfaces of PCIs and TCIs. The \texttt{generate\_interconnections}
procedure, presented in Algorithm~\ref{alg:geninter}, produces these
interconnections.

\begin{center}
  \begin{algorithm}[H]
    \DontPrintSemicolon

    \SetAlFnt{\fontsize{11}{13}\selectfont}
    
    \SetAlCapFnt{\fontsize{11}{13}\selectfont}
    \SetAlCapNameFnt{\fontsize{11}{13}\selectfont}
    % \NoCaptionOfAlgo

    \caption{\texttt{generate\_interconnections}($sitpn$, $d$, $\gamma$)}
    \label{alg:geninter}
    
    \AlFnt % overriding the new font

    \ForEach{$p\in{}P$}{
      \texttt{comp}$(id_p,\mathtt{place},g_p,i_p,o_p)\leftarrow\mathtt{get\_comp}(\gamma(p),d.cs)$\;\label{line:geninter-getpcomp}

      \BlankLine
      $i\leftarrow{}0$\; \label{geninter-start}
      \ForEach{$t\in\mathtt{input}(p)$}{\label{line:foreach-input-cit}
        \texttt{comp}$(id_t,\mathtt{transition},g_t,i_t,o_t)\leftarrow\mathtt{get\_comp}(\gamma(t),d.cs)$\;
        $i_p\leftarrow{}i_p\cup\{(\mathtt{itf}(i),\mathtt{actual}(\mathtt{fired},o_t))\}$\;\label{line:connect-itf-fired}
        $i\leftarrow{}i+1$\;
      }\label{line:geninter-end-input}

      \BlankLine
      $i\leftarrow{}0$\;
      \ForEach{$t\in\mathtt{output}_c(p)$}{\label{line:foreach-outc}
        \texttt{comp}$(id_t,\mathtt{transition},g_t,i_t,o_t)\leftarrow\mathtt{get\_comp}(\gamma(t),d.cs)$\;
        $i_p\leftarrow{}i_p\cup\{(\mathtt{otf}(i),\mathtt{actual}(\mathtt{fired},o_t))\}$\; \label{line:otf-fired-1}
        \texttt{connect}$(o_p,i_t,\mathtt{oav}(i),\mathtt{iav},d)$\; \label{line:oav-iav-1}
        \texttt{connect}$(o_p,i_t,\mathtt{rtt}(i),\mathtt{rt},d)$\; \label{line:rtt-rt-1}
        \texttt{connect}$(o_p,i_t,\mathtt{pauths}(i),\mathtt{pauths},d)$\; \label{line:pauths-pauths-1}
        \texttt{put\_comp}$(id_t, \mathtt{comp}(id_t,\mathtt{transition},g_t,i_t,o_t), d.cs)$\; \label{geninter-puttcomp}
        $i\leftarrow{}i+1$\;
      }\label{line:end-foreach-outc}
      
      \ForEach{$t\in\mathtt{output}_{nc}(p)$}{
        \texttt{comp}$(id_t,\mathtt{transition},g_t,i_t,o_t)\leftarrow\mathtt{get\_comp}(\gamma(t),d.cs)$\;\label{line:foreach-outnc}
        $i_p\leftarrow{}i_p\cup\{(\mathtt{otf}(i),\mathtt{actual}(\mathtt{fired},o_t))\}$\; \label{line:otf-fired-2}
        \texttt{connect}$(o_p,i_t,\mathtt{oav}(i),\mathtt{iav},d)$\; \label{line:oav-iav-2}
        \texttt{connect}$(o_p,i_t,\mathtt{rtt}(i),\mathtt{rt},d)$\; \label{line:rtt-rt-2}

        $id_s\leftarrow\mathtt{genid}()$\;\label{line:genid-for-pauths}
        $d.sigs\leftarrow{}d.sigs\cup(id_s,\mathtt{boolean})$\;
        $o_p\leftarrow{}o_p\cup\{(\mathtt{pauths}(i),id_s)\}$\;\label{line:pauths-assoc}
        \texttt{cassoc}$(i_t,\mathtt{pauths},\mathtt{true})$\; \label{line:pauths-true}
        
        \texttt{put\_comp}$(id_t, \mathtt{comp}(id_t,\mathtt{transition},g_t,i_t,o_t), d.cs)$\;\label{line:end-foreach-outnc}
        $i\leftarrow{}i+1$\;
      } \label{geninter-end}
      
      \BlankLine
      \texttt{put\_comp}$(id_p, \mathtt{comp}(id_p,\mathtt{place},g_p,i_p,o_p), d.cs)$\;\label{line:putpcomp-cit}
    }
  \end{algorithm}
\end{center}

The \texttt{generate\_interconnections} procedure iterates over the
set of places of the $sitpn$ parameter. For each place $p$, the
procedure generates the interconnections between the PCI $id_p$ and
the TCIs that implement the input and output transitions of $p$; we
will refer to them as the input and output TCIs of PCI $id_p$.

At Line~\ref{line:geninter-getpcomp}, the \texttt{get\_comp} function
returns the PCI associated with the identifier $\gamma(p)$ (i.e. the
PCI identifier associated with place $p$ in $\gamma$) by looking up
the behavior of the design $d$. At this step, we assume that all PCIs
and TCIs, and all bindings pertaining to places and transitions in the
$\gamma$ binder, have been previously generated by the
\texttt{generate\_architecture} procedure. Otherwise, the
\texttt{get\_comp} function raises an error if it is not able to find
the PCI $id_p$ in the behavior of design $d$.

Then, from Line~\ref{geninter-start} to Line~\ref{geninter-end}, the
procedure modifies the input and output port map of PCI $id_p$ and the
input port map of its input and output TCIs. Finally,
Line~\ref{line:putpcomp-cit} replaces the old PCI $id_p$ by the
modified one in the behavior of design $d$.

From Line~\ref{geninter-start} to Line~\ref{line:geninter-end-input},
the procedure iterates over the input transitions of place $p$. Note
that the iteration is performed in the same order as the iteration
performed by the \textbf{foreach} loop at Line~\ref{line:foreach-iaw}
of the \texttt{generate_PCIs} procedure; this is mandatory to preserve
a consistency between the index $i$ and the connection to a given
transition (see Remark~\ref{rem:connections-consistency}).  For each
input transition $t$ of $p$, the corresponding TCI $id_t$ is retrieved
from the behavior of design $d$. Then, the internal signal associated
with the \texttt{fired} output port in the output port map of TCI
$id_t$ is retrieved (i.e. \texttt{actual}$(\mathtt{fired},o_t)$), and
the signal is associated with the subelement of the \texttt{itf} input
port with index $i$. We know that the \texttt{generate_TCIs} function
has generated the association between the \texttt{fired} output port
and an internal signal in the output port map of all TCIs. Thus, the
\texttt{actual} function never raises an error.

\begin{remark}[Connections consistency]
  \label{rem:connections-consistency}
  In the behavior of the \texttt{place} design, some processes access
  to the subelements of composite ports through the use of
  indices. For instance, the \texttt{input\_tokens\_sum} process (see
  Appendix~\ref{app:place-design}) increments a local variable $i$ in
  range $0$ to $\mathtt{input\_arcs\_number}-1$ in a for loop. The
  process tests the value of the \texttt{itf} port's subelement with
  index $i$. If the test succeeds, the process adds the value of the
  \texttt{iaw} port's subelement with index $i$ to the local variable
  \texttt{v\_internal\_input\_token\_sum}. Thus, the subelement with
  index $i$ of the \texttt{itf} and \texttt{iaw} ports must refer to
  the connection to the same transition. Otherwise, the process does
  not compute a correct input tokens
  sum. Figure~\ref{fig:consistent-connections} illustrates the correct
  connection of the \texttt{itf} and \texttt{iaw} ports in the input
  port map of PCI $id_p$ w.r.t. to the connection between transitions
  $t_a$, $t_b$, $t_c$ and place $p$.

  \begin{figure}[H]
    \centering
    \includegraphics[keepaspectratio,width=.8\textwidth]{Figures/Transformation/consistent-indexes}
    \caption[An example of correct connections between several TCIs
    and a PCI.]{An example of correct connections between the PCI
      $id_p$ and TCIs $id_{t_a}$, $id_{t_b}$ and $id_{t_c}$. On the
      left, the input SITPN model showing the connections of the
      transitions $t_a$, $t_b$ and $t_c$ to the place $p$. The dots
      indicate that the place $p$ possibly has other input
      transitions. On the right, the TCIs and the PCI generated by the
      transformation. In the input port map of PCI $id_p$, the
      subelements of the \texttt{itf} input port are connected to the
      \texttt{fired} port of TCIs; the subelements of the \texttt{iaw}
      port are connected to constant values, i.e. the weight of the
      arcs between place $p$ and the input transitions of $p$.}
    \label{fig:consistent-connections}
  \end{figure}

  It is the part of the \hilecop{} transformation function to ensure
  the consistency of the connections of the subelements in the input
  and output port maps of PCIs. Because the \texttt{transition} design
  does not hold the information pertaining to the arc connections, the
  input and output port maps of TCIs are not subject to such a
  constraint. The fact that a \textbf{foreach} loop always iterates in
  the same order over the elements of a set ensures the consistency of
  the connections.
\end{remark}

From Line~\ref{line:foreach-outc} to Line~\ref{line:end-foreach-outc},
the procedure connects the PCI $id_p$ to the TCIs implementing the
conflicting output transitions of place $p$. For each conflicting
output transition $t$ of $p$, the corresponding TCI $id_t$ is
retrieved from the behavior of design $d$. The function call
\texttt{actual}$(\mathtt{fired},o_t)$ returns the internal signal
associated with the \texttt{fired} output port in the output port map
of TCI $id_t$. This internal signal is then connected to the
subelement of the \texttt{otf} input port with index $i$ in the input
port map of PCI $id_p$. At Line~\ref{line:oav-iav-1}, the
\texttt{connect} function generates an internal signal $id$ and adds
it to the internal signal declaration list of design $d$. Then, the
function associates the subelement \texttt{oav}$(i)$ (i.e. the
subelement of the \texttt{oav} input port with index $i$) with the
internal signal $id$ in the output port map $o_p$, and it associates
one subelement of the \texttt{iav} input port to the internal signal
$id$ in the input port map $i_t$. The \texttt{connect} function
operates similarly on the \texttt{rtt} output port and the \texttt{rt}
input port at Line~\ref{line:rtt-rt-1}, and on the \texttt{pauths}
input port and the \texttt{pauths} output port at
Line~\ref{line:pauths-pauths-1}. Finally, at
Line~\ref{geninter-puttcomp}, the old TCI $id_t$ is replaced by the
modified one in the behavior of design $d$.

From Line~\ref{line:foreach-outnc} to
Line~\ref{line:end-foreach-outnc}, the procedure connects the TCIs
implementing to the output transitions of $p$ that are not in
conflict. Note that the variable $i$ is not reset between the two
\textbf{foreach} loops to preserve the continuity of indices.  For
each non-conflicting output transition $t$ of $p$, the corresponding
TCI $id_t$ is retrieved from the behavior of design $d$. Then, the
interconnections between PCI $id_p$ and TCI $id_t$ are similar to the
ones that have been performed for the conflicting transitions of
$p$. The difference lies in the connection of the \texttt{pauths}
ports.  Between the PCI $id_p$ and its \textit{non-conflicting} TCIs,
the \texttt{pauths} are not connected together; this to reflect the
independence of non-conflicting output transitions regarding the
priority authorizations. Instead, the subelement of the
\texttt{pauths} output port with index $i$ is connected to a newly
generated internal signal $id_s$ in the output port map $o_p$
(Line~\ref{line:genid-for-pauths} to Line~\ref{line:pauths-assoc});
the internal signal $id_s$ is not connected to anything, and it will
be removed by the (industrial) compiler at the time of the
synthesis. Also, one subelement of the \texttt{pauths} input port is
associated with \texttt{true} in the input port map $i_t$
(Line~\ref{line:pauths-true}); this connection represents the fact
that, since the transition $t$ is not a conflicting transition of
place $p$, then, transition $t$ always has the authorization to be
fired, given that it is firable.

Figure~\ref{fig:gen-inter-ex} shows the interconnections between the
PCI $id_{p_0}$ and the TCI $id_{t_0}$
(cf. Figure~\ref{fig:transf-arch}) after the execution of the
\texttt{generate_interconnections} procedure.

\begin{figure}[H]
  \centering
  \includegraphics[keepaspectratio,width=.7\textwidth]{Figures/Transformation/gen-inter-ex}
  \caption{A graphical representation of the interconnections of the
    PCI $id_{p_0}$ and the TCI \texttt{id}$_{t_0}$ after the execution
    of \texttt{generate_interconnections} procedure. }
  \label{fig:gen-inter-ex}
\end{figure}

\subsection{Generation of ports, the \texttt{action} and the
  \texttt{function} process}
\label{sec:genports}

The last part of the transformation pertains to the generation of the
input and output ports of the top-level \hvhdl{} design. The input
ports implement the conditions declared in the input SITPN model. Each
input port is associated with a condition through the $\gamma$
binder. This binding is built during the transformation. The output
ports of the \hvhdl{} design implement the action and function of the
input SITPN. Each output port is associated with an action or a
function through the $\gamma$ binder. During the simulation of a
\hvhdl{} design, the value of an output port represent the
activation/execution status of the associated
action/function. Algorithm~\ref{alg:genports} presents the
\texttt{generate\_ports} procedure. This procedure calls three
procedures, namely: the \texttt{generate\_condition\_ports} procedure,
responsible for the generation and the connection of input ports
implementing conditions; the \texttt{generate\_action\_ports}
procedure, responsible for the generation of output ports implementing
actions, and for the generation of the \texttt{action} process; the
\texttt{generate\_function\_ports} procedure, responsible for the
generation of output ports implementing functions, and for the
generation of the \texttt{function} process. These three procedures
are detailed in Algorithms~\ref{alg:genconds}, \ref{alg:genacts} and
\ref{alg:genfuns}.

\begin{center}
  \begin{algorithm}[H]
    \DontPrintSemicolon

    \SetAlFnt{\fontsize{11}{13}\selectfont}
    
    \SetAlCapFnt{\fontsize{11}{13}\selectfont}
    \SetAlCapNameFnt{\fontsize{11}{13}\selectfont}
    % \NoCaptionOfAlgo

    \texttt{generate\_condition\_ports}($sitpn$, $d$, $\gamma$)\;
    \texttt{generate\_action\_ports}($sitpn$, $d$, $\gamma$)\;
    \texttt{generate\_function\_ports}($sitpn$, $d$, $\gamma$)\;
    
    \caption{\texttt{generate\_ports}($sitpn$, $d$, $\gamma$)}
    \label{alg:genports}
    
    \AlFnt % overriding the new font
  \end{algorithm}
\end{center}

Algorithm~\ref{alg:genconds} describes the
\texttt{generate\_condition\_ports} procedure.

\begin{center}
  \begin{algorithm}[H]
    \DontPrintSemicolon

    \SetAlFnt{\fontsize{11}{13}\selectfont}
    
    \SetAlCapFnt{\fontsize{11}{13}\selectfont}
    \SetAlCapNameFnt{\fontsize{11}{13}\selectfont}
    % \NoCaptionOfAlgo

    \ForEach{$c\in\mathcal{C}$}{
      $id_c\leftarrow\mathtt{genid}()$\;
      $d.ports\leftarrow{}d.ports\cup\{(\mathtt{in},id_c,\mathtt{boolean})\}$\;
      $\gamma\leftarrow\gamma\cup\{(c,id_c)\}$\;
      
      \BlankLine
      \ForEach{$t\in\mathtt{trs}(c)$}{\label{line:foreach-trans-of-c}
        \texttt{comp}$(id_t,\mathtt{transition},g_t,i_t,o_t)\leftarrow\mathtt{get\_comp}(\gamma(t),d.cs)$\;
        \lIf{$\mathbf{C}(t,c)=1$}{\texttt{cassoc}$(i_t,\mathtt{ic},id_c)$}
        \lElseIf{$\mathbf{C}(t,c)=-1$}{\texttt{cassoc}$(i_t,\mathtt{ic},\mathtt{not}~id_c)$}
        \texttt{put\_comp}$(id_t, \mathtt{comp}(id_t,\mathtt{transition},g_t,i_t,o_t), d.cs)$\;
      }
    }
    
    \caption{\texttt{generate\_condition\_ports}($sitpn$, $d$, $\gamma$)}
    \label{alg:genconds}
    
    \AlFnt % overriding the new font
  \end{algorithm}
\end{center}

The \texttt{generate\_condition\_ports} procedure iterates over the set of
conditions of the $sitpn$ parameter. For each condition of the set,
the \texttt{generate\_condition\_ports} procedure produces a corresponding
input port identifier $id_c$, and adds an input port declaration entry
in the port declaration list of design $d$. The declared input port is
of the Boolean type. Also, a binding between condition $c$ and
identifier $id_c$ is added to $\gamma$. Then, the procedure performs
the connection between the input port $id_c$ and the \texttt{ic} input
port present in the input interface of TCIs. The \texttt{ic} input
port is an array composed of Boolean subelements. Indeed, as multiple
conditions can be attached to a given transition, a given TCI is
possibly connected to multiple input ports implementing conditions
through its \texttt{ic} port. At Line~\ref{line:foreach-trans-of-c},
the \textbf{foreach} loop iterates over the set of transitions
attached to condition $c$. For each such transition $t$, the
corresponding TCI $id_t$ is retrieved from the behavior of design
$d$. Then, depending on the relation that exists between condition $c$
and transition $t$, an association between $id_c$ and one subelement
of the \texttt{ic} input port is added to the input port map $i_t$. At
the end of the loop, the old TCI $id_t$ is replaced by a new TCI, with
an updated input port map, in the behavior of design $d$.\\

Algorithm~\ref{alg:genacts} describes the
\texttt{generate\_action\_ports} procedure.

\begin{algorithm}[H]
  \DontPrintSemicolon

  \SetAlFnt{\fontsize{11}{13}\selectfont}
  
  \SetAlCapFnt{\fontsize{11}{13}\selectfont}
  \SetAlCapNameFnt{\fontsize{11}{13}\selectfont}
  % \NoCaptionOfAlgo

  $rstss\leftarrow{}\mathtt{null}$\;
  $fss\leftarrow{}\mathtt{null}$\;

  \BlankLine
  \ForEach{$a\in\mathcal{A}$}{\label{line:foreach-acts}
    $id_a\leftarrow\mathtt{genid}()$\;
    $d.ports\leftarrow{}d.ports\cup\{(\mathtt{out},id_a,\mathtt{boolean})\}$\;
    $\gamma\leftarrow{}\gamma\cup\{(a,id_a)\}$\;
    $e_{id_a}\leftarrow{}\mathtt{false}$\;\label{line:init-expr-a}

    \BlankLine
    \ForEach{$p\in{}\mathtt{pls}(a)$}{
      \texttt{comp}$(id_p,\mathtt{place},g_p,i_p,o_p)\leftarrow\mathtt{get\_comp}(\gamma(p),d.cs)$\;
      $id_s\leftarrow{}\mathtt{actual}(\mathtt{marked},o_p)$\;
      $e_{id_a}\leftarrow{}id_s~\mathtt{or}~e_{id_a}$\;
    }

    \BlankLine
    $rstss\leftarrow{}rstss;~id_a\Leftarrow{}\mathtt{false}$\;
    $fss\leftarrow{}fss;~id_a\Leftarrow{}e_{id_a}$\;\label{line:add-assign-fss}
  }

  $d.cs\leftarrow{}d.cs~\mathtt{||}~\mathtt{process}(\mathtt{action},\{\mathtt{clk}\},\emptyset,\mathtt{rst}~(rstss)~(\mathtt{falling}~fss))$\;
  
  \caption{\texttt{generate\_action\_ports}($sitpn$, $d$, $\gamma$)}
  \label{alg:genacts}
  
  \AlFnt % overriding the new font
\end{algorithm}

The \texttt{generate\_action\_ports} procedure does two things. First,
it generates an output port for each action of the input SITPN;
second, it builds the \texttt{action} process that is responsible for
the assignment of the value of \textit{action} ports depending on the
value of the \texttt{marked} output ports of PCIs. The \texttt{action}
process is a synchronous process; its statement body is composed of a
single \texttt{rst} block. A \texttt{rst} block is composed of two
blocks of sequential statements; the first block is executed only
during an initialization phase, otherwise, the second block is
executed. Here, the second block corresponds to a \texttt{falling}
block, i.e. a block that is only executed during a falling edge
phase. Thus, the \texttt{generate\_action\_ports} procedure builds two
blocks of sequential statements: the first one, hold in the $rstss$
variable, corresponds to the first part of the \texttt{rst} block
(i.e. the one executed during the initialization phase); the second
one, hold in the $fss$ variable, corresponds to the second part of the
\texttt{rst} block, i.e. a falling edge block. The first two lines of
the procedure initialize the $rstss$ and $fss$ with the \texttt{null}
sequential statement. Then, in the absence of actions defined in the
input SITPN, the statement body of the \texttt{action} process is
composed of \texttt{null} statements; the execution of \texttt{null}
statements has no effect on the state of design during a simulation.
At Line~\ref{line:foreach-acts}, the procedure iterates over the set
of actions of the $sitpn$ parameter. For each action $a$ in the set,
an output port identifier $id_a$ is generated, an output port
declaration entry is added to the port declaration list of design $d$,
the binding between action $a$ and identifier $id_a$ joins the
$\gamma$ binder.

An action is activated at given state if one of its attached place is
marked, i.e. its marking is greater than zero. An output port
identifier that implements the activation status of a given action is
assigned in the falling block of the \texttt{action} process. The
expression assigned to the output port $id_a$ corresponds to the
\texttt{or} sum between each \texttt{marked} port of the PCIs
implementing the places attached to the action $a$. From
Line~\ref{line:init-expr-a} to Line~\ref{line:add-assign-fss}, the
\texttt{generate\_action\_ports} procedure builds this \texttt{or} sum
expression. For each place $p$ associated with the action $a$, the
corresponding PCI $id_p$ is retrieved from the behavior of design
$d$. The internal signal $id_s$ associated with the \texttt{marked}
port is looked up in the output port map of PCI $id_p$. Then, the
signal identifier $id_s$ is composed with the expression $e_{id_a}$
with the \texttt{or} operator. At the end of the loop started at
Line~\ref{line:foreach-acts}, the procedure adds a new signal
assignment statement to the $rstss$ and to the $fss$ variables by
composition with the $;$ operator. In the $rstss$ variable, i.e. in
the part of the \texttt{action} process executed during an
initialization phase, the $id_a$ output port is assigned to
\texttt{false}. In the $fss$ variable, i.e. the part of the
\texttt{action} process executed during a falling edge phase, the
$id_a$ output port is assigned to the previously built \texttt{or} sum
expression $e_{id_a}$. The last line of the procedure builds and adds
the \texttt{action} process to the behavior of design $d$. The
\texttt{action} process is a synchronous process, thus, it declares
the \texttt{clk} signal in its sensitivity list. The \texttt{action}
process has an empty set of local variables. Finally, its statement
body is composed of a \texttt{rst} block with $rstss$ as a first
block, and a \texttt{falling} edge block wrapping $fss$ as a second
block.

Algorithm~\ref{alg:genfuns} describes the
\texttt{generate\_function\_ports} procedure.

\begin{algorithm}[H]
  \DontPrintSemicolon

  \SetAlFnt{\fontsize{11}{13}\selectfont}
  
  \SetAlCapFnt{\fontsize{11}{13}\selectfont}
  \SetAlCapNameFnt{\fontsize{11}{13}\selectfont}
  % \NoCaptionOfAlgo

  $rstss\leftarrow{}\mathtt{null}$\;
  $rss\leftarrow{}\mathtt{null}$\;

  \BlankLine
  \ForEach{$f\in\mathcal{F}$}{\label{line:foreach-funs}
    $id_f\leftarrow\mathtt{genid}()$\;
    $d.ports\leftarrow{}d.ports\cup\{(\mathtt{out},id_f,\mathtt{boolean})\}$\;
    $\gamma\leftarrow{}\gamma\cup\{(f,id_f)\}$\;
    $e_{id_f}\leftarrow{}\mathtt{false}$\; \label{line:init-expr-f}

    \BlankLine
    \ForEach{$t\in{}\mathtt{trs}(f)$}{
      \texttt{comp}$(id_t,\mathtt{transition},g_t,i_t,o_t)\leftarrow\mathtt{get\_comp}(\gamma(t),d.cs)$\;
      $id_s\leftarrow{}\mathtt{actual}(\mathtt{fired},o_t)$\;
      $e_{id_f}\leftarrow{}id_s~\mathtt{or}~e_{id_f}$\;
    }

    \BlankLine
    $rstss\leftarrow{}rstss;~id_f\Leftarrow{}\mathtt{false}$\;
    $rss\leftarrow{}rss;~id_f\Leftarrow{}e_{id_f}$\;\label{line:add-assign-rss}
  }

  $d.cs\leftarrow{}d.cs~\mathtt{||}~\mathtt{process}(\mathtt{function},\{\mathtt{clk}\},\emptyset,\mathtt{rst}~(rstss)~(\mathtt{rising}~rss))$\;
  
  \caption{\texttt{generate\_function\_ports}($sitpn$, $d$, $\gamma$)}
  \label{alg:genfuns}
  
  \AlFnt % overriding the new font
\end{algorithm}

The \texttt{generate\_function\_ports} procedure does two
things. First, it generates an output port for each function of the
input SITPN; second, it builds the \texttt{function} process that is
responsible for the assignment of the value of \textit{function} ports
depending on the value of the \texttt{fired} output ports of
PCIs. Similarly to the \texttt{action} process, the \texttt{function}
process is a synchronous process with a statement body composed of a
single \texttt{rst} block. The second part of the \texttt{rst} block
is a \texttt{rising} block, i.e. a block that is only executed during
a rising edge phase. Thus, the \texttt{generate\_function\_ports}
procedure builds two blocks of sequential statements: the first one,
hold in the $rstss$ variable, corresponds to the first part of the
\texttt{rst} block (i.e. the one executed during the initialization
phase); the second one, hold in the $rss$ variable, corresponds to the
second part of the \texttt{rst} block, i.e. a rising edge block. The
first two lines of the procedure initialize the $rstss$ and $rss$ with
the \texttt{null} sequential statement. At
Line~\ref{line:foreach-funs}, the procedure iterates over the set of
functions of the $sitpn$ parameter. For each function $f$ in the set,
an output port identifier $id_f$ is generated, an output port
declaration entry is added to the port declaration list of design $d$,
the binding between function $f$ and identifier $id_f$ joins the
$\gamma$ binder.

A function is executed at given state if one of its attached
transition is fired. An output port identifier that implements the
execution status of a given function is assigned in the rising block
of the \texttt{function} process. The expression assigned to the
output port $id_f$ corresponds to the \texttt{or} sum between each
\texttt{fired} port of the TCIs implementing the transitions attached
to the function $f$. From Line~\ref{line:init-expr-f} to
Line~\ref{line:add-assign-rss}, the \texttt{generate\_function\_ports}
procedure builds this \texttt{or} sum expression. For each transition
$t$ associated with the function $f$, the corresponding TCI $id_t$ is
retrieved from the behavior of design $d$. The internal signal $id_s$
associated with the \texttt{fired} port is looked up in the output
port map of TCI $id_t$. Then, the signal identifier $id_s$ is composed
with the expression $e_{id_f}$ with the \texttt{or} operator. At the
end of the loop started at Line~\ref{line:foreach-funs}, the procedure
adds a new signal assignment statement to the $rstss$ and to the $rss$
variables by composition with the $;$ operator. In the $rstss$
variable, i.e. in the part of the \texttt{function} process executed
during an initialization phase, the $id_f$ output port is assigned to
\texttt{false}. In the $rss$ variable, i.e. the part of the
\texttt{function} process executed during a rising edge phase, the
$id_f$ output port is assigned to the previously built \texttt{or} sum
expression $e_{id_f}$. The last line of the procedure builds and adds
the \texttt{function} process to the behavior of design $d$. The
\texttt{function} process is a synchronous process, thus, it declares
the \texttt{clk} signal in its sensitivity list. The \texttt{function}
process has an empty set of local variables. Finally, its statement
body is composed of a \texttt{rst} block with $rstss$ as a first
block, and a \texttt{rising} edge block wrapping $rss$.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../main"
%%% End:
