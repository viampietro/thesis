In this section, we give the algorithm underlying the \hilecop{}
model-to-text transformation. This algorithm is the base of the \coq{}
implementation of the \hilecop{} transformation; the implementation is
presented in Section~\ref{sec:trans-coq-impl}. As stated in
Chapter~\ref{chap:hilecop}, there exists a Java implementation of the
\hilecop{} methodology. This implementation embeds the generation of
VHDL code from an SITPN model. However, the algorithm of the
transformation has never been devised, nor a formal specification
given. The following algorithm is one of the contribution of this
thesis. It has been devised through the examination of the code of the
existing Java implementation, and through the discussions with the
designers of the \hilecop{} methodology.

\subsection{The \texttt{sitpn_to_hvhdl} function}
\label{sec:sitpn-to-hvhdl}

The \hilecop{} transformation algorithm, presented in
Algorithm~\ref{alg:sitpn2hvhdl}, generates a \hvhdl{} design and a
SITPN-to-\hvhdl{} binder from an input SITPN. A SITPN-to-\hvhdl{}
design binder is a structure that binds the elements of an SITPN
(places, transitions, actions\dots) to the elements of a \hvhdl{}
design (component instances or signals). As it is generated along the
transformation, the binder links a SITPN element to its \hvhdl{}
\textit{implementation}, i.e. the \hvhdl{} element that will
supposedly behave similarly to the source SITPN element at
runtime. Thus, the SITPN-to-\hvhdl{} design binder is at the center of
the state similarity relation, presented in Chapter~\ref{chap:proof},
and that enables the comparison between an SITPN state and an \hvhdl{}
design state. The formal definition of an SITPN-to-\hvhdl{} design
binder is as follows.

\begin{definition}[SITPN-to-\hvhdl{} design binder]
  \label{def:sitpn-to-hvhdl-binder}
  Given a $sitpn\in{}SITPN$ and a \hvhdl{} design $d\in{}design$, a
  SITPN-to-\hvhdl{} design binder $\gamma\in{}WM(sitpn,d)$ is a tuple\\
  ${<}PMap,TMap,CMap,AMap,FMap{>}$
  where:
  \begin{itemize}
  \item
    $sitpn={<}P,T,pre,test,inhib,post,M_0,{\succ},\mathcal{A},\mathcal{C},\mathcal{F},
    \mathbb{A},\mathbb{C},\mathbb{F},{I_s}{>}$
  \item $d=$ \vhdle|design| \textit{$id_{e}$ $id_{a}$ gens ports sigs cs}
  \item $PMap\in{}P\rightarrow{}\{id~|~\mathtt{comp}(id,\mathtt{place},g,i,o)\in{}cs\}$
  \item $TMap\in{}T\rightarrow{}\{id~|~\mathtt{comp}(id,\mathtt{transition},g,i,o)\in{}cs\}$
  \item $CMap\in\mathcal{C}\rightarrow\{id~|~(\mathtt{in}, id, t)\in{}ports\}$
  \item $AMap\in\mathcal{A}\rightarrow\{id~|~(\mathtt{out}, id, t)\in{}ports\}$
  \item $FMap\in\mathcal{F}\rightarrow\{id~|~(\mathtt{out}, id, t)\in{}ports\}$        
  \end{itemize}
\end{definition}

As presented in Definition~\ref{def:sitpn-to-hvhdl-binder}, the binder
is composed of five sub-environments that map the different SITPN sets
to identifiers. The $PMap$ and $TMap$ sub-environments map the places
to their corresponding PCI identifiers, and the transitions to their
corresponding TCI identifiers. The $CMap$ sub-environment maps the
conditions to input port identifiers. The $AMap$ and $FMap$
sub-environments map the actions and functions to output port
identifiers. In what follows, for a given binder $\gamma$ and an
element of an SITPN structure
$e\in{}P\sqcup{}T\sqcup\mathcal{C}\sqcup\mathcal{A}\sqcup\mathcal{F}$,
we write $\gamma(e)$ where $e$ is looked up in the appropriate
function. For instance, for a given $f\in\mathcal{F}$, $\gamma(f)$ is
a shorthand for $FMap(f)$ where $\gamma={<}\dots,FMap{>}$.

Algorithm~\ref{alg:sitpn2hvhdl} is the algorithm of the \hilecop{}
model-to-text transformation. The algorithm as four parameters; the
first one is the input SITPN model; $id_e$ and $id_a$ are the entity
and the architecture identifiers for the generated \hvhdl{} design;
$mmf\in{}P\rightarrow\mathbb{N}$ is the function associating a maximal
marking value to each place of the input SITPN. This function is the
result of the analysis of the input SITPN.

\begin{remark}[Bounded SITPN]
  \label{rem:bounded-sitpn}
  A part of the analysis is interested in determining the maximal
  number of tokens that a place can hold during the execution of a
  SITPN. If each place of the SITPN can only hold a limited number of
  tokens during the execution, then the model is said to be
  bounded. In that case, a function associated the places with a
  maximal marking value can be computed. Thus, the presence of the
  $mmf$ function as a parameter of the \texttt{sitpn\_to\_hvhdl}
  function implies that the input SITPN model is bounded. In the case
  of an unbounded input model, there exists a place that can
  accumulate an infinite number of tokens during the model
  execution. In the world of hardware description, and especially when
  aiming at the hardware synthesis, every element must have a finite
  dimension. In the definition of the \texttt{place} design, the
  internal signal \texttt{s\_marking} represents the marking value of
  a place. The maximal value of the \texttt{s\_marking} signal is
  bounded by the generic constant \texttt{maximal\_marking}. Thus,
  when generating, a PCI from a place in the course of the
  transformation, we must be able to give a value to the
  \texttt{maximal\_marking} generic constant. However, even with a
  settled \texttt{maximal\_marking} value, the execution of a \hvhdl{}
  design, resulting from the transformation of an unbounded SITPN
  model, could lead to the overflow of the value of the
  \texttt{s\_marking} signals in the internal states of PCIs.  Thus,
  it is impossible to prove the equivalence between the behavior of an
  unbounded SITPN model and its corresponding \hvhdl{} design. 
\end{remark}

\begin{algorithm}[H]
  \DontPrintSemicolon

  \SetAlFnt{\fontsize{11}{13}\selectfont}
  
  \SetAlCapFnt{\fontsize{11}{13}\selectfont}
  \SetAlCapNameFnt{\fontsize{11}{13}\selectfont}
  % \NoCaptionOfAlgo

  \caption{\texttt{sitpn\_to\_hvhdl}($sitpn$, $id_e$, $id_a$, $mmf$)}
  \label{alg:sitpn2hvhdl}
  
  \AlFnt % overriding the new font

  $d\leftarrow\mathtt{design}$ $id_e$ $id_a$ $\emptyset$ $\emptyset$ $\emptyset$ $\mathtt{null}$\; \label{line:init-design}
  $\gamma\leftarrow\emptyset$\; \label{line:init-binder}
  \BlankLine

  \texttt{generate\_architecture}($sitpn$, $d$, $\gamma$, $mmf$)\; \label{line:genarch}
  \texttt{generate\_interconnections}($sitpn$, $d$, $\gamma$)\; \label{line:geninter}
  \texttt{generate\_ports}($sitpn$, $d$, $\gamma$)\; \label{line:genports}
  \BlankLine  

  \Return{($d$,$\gamma$)}\;
\end{algorithm}

In Algorithm~\ref{alg:sitpn2hvhdl}, Line~\ref{line:init-design}
creates the \hvhdl{} design. Initially, the design has an empty port
declaration set, an empty internal signal declaration set, and a
behavior defined by the \texttt{null} statement. The design generated
by the \texttt{sitpn\_to\_hvhdl} function has an empty set of generic
constant, even at the end of the
transformation. Line~\ref{line:init-binder} initializes the $\gamma$
binder with empty sub-environments. From Lines~\ref{line:genarch} to
\ref{line:genports}, the called procedures modify the design and the
binder structures. Each part of the sequence corresponds to one step
of the transformation, which were outlined in
Section~\ref{sec:informal-transf}. The content of the
\texttt{generate\_architecture} function is detailled in Algorithms,
the content of the \texttt{generate\_interconnections} function is
detailled in Algorithms, and the content of the
\texttt{generate\_ports} function is detailled in Algorithms.

\subsection{Primitive functions and sets}
\label{sec:prim-funs}

The description of further functions and algorithms appeals to some
primitive functions and set definitions that we introduce here. Below
are all the sets that we use in the description of the algorithms.

\begin{itemize}
\item
  \texttt{input}$(p)=\{t~\vert~\exists\omega~s.t.~post(t,p)=\omega\}$,
  the set of input transitions of a place $p$.
\item
  \texttt{output}$(p)=\{t~\vert~\exists{}\omega,a~s.t.~pre(p,t)=(\omega,a)\}$,
  the set of output transitions of a place $p$.

\item \texttt{acts}$(p)=\{a~\vert~\mathbb{A}(p,a)=\mathtt{true}\}$,
  the set of actions associated with a place $p$.
\item
  \texttt{input}$(t)=\{p~\vert~\exists\omega,a~s.t.~pre(p,t)=(\omega,a)\}$,
  the set of input places of a transition $t$.
\item
  \texttt{output}$(t)=\{p~\vert~\exists\omega~s.t.~post(t,p)=\omega\}$,
  the set of output places of a transition $t$.
\item
  \texttt{conds}$(t)=\{c~\vert~\mathbb{C}(t,c)=1\lor\mathbb{C}(t,c)=-1\}$,
  the set of conditions associated with a transition $t$.
\item
  \texttt{trs}$(c)=\{t~\vert~\mathbb{C}(t,c)=1\lor\mathbb{C}(t,c)=-1\}$,
  the set of transitions to which a condition $c$ is associated.
\item \texttt{pls}$(a)=\{p~\vert~\mathbb{A}(p,a)=\mathtt{true}\}$, the
  set of places to which an action $a$ is associated.
\item \texttt{trs}$(f)=\{t~\vert~\mathbb{F}(t,f)=\mathtt{true}\}$, the
  set of transitions to which a function $f$ is associated.
\end{itemize}

Every above set are unordered. However, we assume that, every time we
iterate over the elements of an unordered set with a \textbf{foreach}
statement, the iteration respects an arbitrary order. This order is
always the same through the multiple calls to \textbf{foreach}
statements.

Now, let us introduce some primitive functions and procedures that we
use in the description of the following algorithms.

\begin{itemize}
\item \texttt{output}$_c(p)$. The function operates the following
  sequence:
  \begin{enumerate}
  \item if all conflicts between the output transitions of $p$ are
    solved by mutual exclusion, or if the set of conflicting
    transitions of $p$ is a singleton, then returns an empty set.
  \item otherwise, tries to establish a total ordering over the set of
    conflicting transitions of $p$ w.r.t the firing priority relation:
    \begin{itemize}
    \item raises an error if no such ordering can be established (in
      that case, the firing priority relation is ill-formed, and the
      input SITPN is not well-defined).
    \item returns the ordered set, with the top-level priority
      transition at the head.
    \end{itemize}
  \end{enumerate}

\item \texttt{output}$_{nc}(p)$. If all conflicts between the output
  transitions of $p$ are solved by mutual exclusion, or if the set of
  conflicting transitions of $p$ is a singleton, then, the function
  returns the set of output transitions of $p$, i.e
  \texttt{output}$(p)$ as defined above. Otherwise, the function
  returns the set of output transitions of $p$ connected through a
  \texttt{test} or an \texttt{inhib} arc,
  i.e.
  $\{t~\vert~\exists\omega~s.t.~pre(p,t)=(\omega,\mathtt{test})\lor{}pre(p,t)=(\omega,\mathtt{inhib})\}$.

\item \texttt{cassoc}$(map,id,x)$ where $map$ is either a generic map,
  an input port map or an output port map, $id$ is an identifier, $x$
  is an expression, a name (i.e. an simple or indexed identifier) or
  the \texttt{open} keyword. The \texttt{cassoc} procedure adds an
  association of the form $(id(i),x)$ to the $map$ structure. The
  index $i$ is computed as follows based on the content of $map$:
  \begin{enumerate}
  \item looks up $id(j)$ with $max(j)$ in the formal parts of $map$
  \item if no such $j$, adds $(id(0),x)$ in $map$
  \item if such $j$, adds $(id(j+1),x)$ in $map$
  \end{enumerate}

  \noindent{}\textit{Examples:}
  \begin{itemize}
  \item
    \texttt{cassoc}$(~\mathtt{((s(0),\mathtt{true}),(s(1),\mathtt{false}))},~\mathtt{s},~\mathtt{true})$
    yields the resulting map \\
    $\mathtt{((s(0),\mathtt{true}),(s(1),\mathtt{false}),(s(2),\mathtt{true}))}$.
  \item
    \texttt{cassoc}$(~\mathtt{((s(0),\mathtt{true}),(s(1),\mathtt{false}))},~\mathtt{a},~\mathtt{open})$
    yields the resulting map \\
    $\mathtt{((s(0),\mathtt{true}),(s(1),\mathtt{false}),(a(0),\mathtt{open}))}$.
  \end{itemize}

\item \texttt{get\_comp}$(id_c, cstmt)$ where $id_c$ is an
  identifier, and $cstmt\in{}\mathrm{cs}$ is a \hvhdl{} concurrent
  statement. The \texttt{get\_comp} function looks up $cstmt$ for a
  component instantiation statement labelled with $id_c$ as a
  component instance identifier, and returns the component
  instantiation statement when found. The \texttt{get\_comp} function
  throws an error if no component instantiation statement with
  identifier $id_c$ exists in $cstmt$, or if there ecist multiple
  component instantiation statements with identifier $id_c$ in
  $cstmt$.
\item \texttt{put\_comp}$(id_c,cistmt,cstmt)$ where $id_c$ is an
  identifier, $cistmt$ is a component instantiation statement, and
  $cstmt\in{}\mathrm{cs}$ is a \hvhdl{} concurrent statement. The
  \texttt{put\_comp} procedure looks up in $cstmt$ for a component
  instantiation statement with identifier $id_c$, and replaces the
  statement with $cistmt$ in $cstmt$. If no CIS with identifier $id_c$
  exists in $cstmt$, then $cistmt$ is composed with $cstmt$ with the
  \texttt{||} operator. The \texttt{put\_comp} procedure throws an
  error if multiple CIS with identifier $id_c$ exist in $cstmt$.
\item \texttt{actual}$(id,map)$ where $id$ is an identifier and $map$
  is a generic, an input port or an output port map. The
  \texttt{actual} function returns the actual part associated with the
  formal part $id$ in $map$, i.e. returns $a$ if $(id,a)\in{}map$. The
  function throws an error if $id$ is not a formal part in $map$, or
  if there are multiple association with $id$ as a formal part in
  $map$.
\item \texttt{genid}$()$. The \texttt{genid} function returns a fresh
  and unique identifier. During the transformation, we appeal to it
  when a new internal signal, a new port or a new component instance
  must be declared or generated.
\end{itemize}

Algorithm~\ref{alg:connect} presents the \texttt{connect} procedure.
The procedure takes an output port map $o$, an input port map $i$, two
identifiers $id_1,id_2$ and a \hvhdl{} design $d$ as parameters. The
procedure generates an internal signal $id_s$ and adds it to the
internal signal declaration list of design $d$. Then, the procedure
connects a subelement of port $id_1$ (resp. $id_2$) to the internal
signal $id_s$ in the output port map $o$ (resp. input port map $i$).
As the result, a subelement of $id_1$ is connected to a subelement of
$id_2$ through the internal signal $id_s$.

\begin{algorithm}[H] \DontPrintSemicolon

  \SetAlFnt{\fontsize{11}{13}\selectfont}
  
  \SetAlCapFnt{\fontsize{11}{13}\selectfont}
  \SetAlCapNameFnt{\fontsize{11}{13}\selectfont} % \NoCaptionOfAlgo

  \caption{\texttt{connect}($o$, $i$, $n$, $id$, $d$)}
  \label{alg:connect}

  $id_s\leftarrow\mathtt{genid}()$\;
  $d.sigs\leftarrow{}d.sigs\cup(id_s,\mathtt{boolean})$\;
  $o\leftarrow{}o\cup(n,id_s)$\; \texttt{cassoc}$(i,id,id_s)$\;
\end{algorithm}

\paragraph{Complementary notations}
When there is no ambiguity, $id_p$ (resp. $id_t$) denotes the PCI
(resp. TCI) identifier associated to a given place $p$
(resp. transition $t$) through $\gamma(p)=id_p$
(resp. $\gamma(t)=id_t$), where $\gamma$ is the binder returned by the
transformation function. Similarly, $id_c$ (resp. $id_a$ and $id_f$)
denotes the input port (resp. output port) identifier associated to a
given condition $c$ (resp. action $a$ and function $f$) through
$\gamma(c)=id_c$.

\subsection{Generation of component instances and constant parts}
\label{sec:genarch}

The first step of the transformation generates the PCIs and TCIs,
their generic map, and the constant part of their input port maps, in
the behavior of the \hvhdl{} design. This is when places are bound to
PCI identifiers, and transitions are bound to TCI identifiers in the
$\gamma$ binder. Also, the \texttt{marked} output port and the
\texttt{fired} output port are connected in the output port map of
PCIs and TCIs during this first generation
step. Algorithm~\ref{alg:genarch} presents the content of the
\texttt{generate\_architecture} procedure that implements this first
part of code generation. The \texttt{generate\_architecture} procedure
is decomposed in two procedures: the \texttt{generate\_PCIs} and the
\texttt{generate\_TCIs} procedures.

\begin{algorithm}[H]
  \DontPrintSemicolon

  \SetAlFnt{\fontsize{11}{13}\selectfont}
  
  \SetAlCapFnt{\fontsize{11}{13}\selectfont}
  \SetAlCapNameFnt{\fontsize{11}{13}\selectfont}
  % \NoCaptionOfAlgo

  \caption{\texttt{generate\_architecture}($sitpn$, $d$, $\gamma$, $mmf$)}
  \label{alg:genarch}
  
  \AlFnt % overriding the new font

  \texttt{generate\_PCIs}($sitpn$, $d$, $\gamma$, $mmf$)\; \label{line:genpcis}
  \texttt{generate\_TCIs}($sitpn$, $d$, $\gamma$)\; \label{line:gentcis}

\end{algorithm}

Note that, in the following algorithms and explanations, we refer to
the generic constant, internal signal and port identifiers defined in
the \texttt{place} and \texttt{transition} designs through their
abbreviated names (see Table~\ref{tab:consts-and-sigs-ref}).

\begin{algorithm}[H]
  \DontPrintSemicolon

  \SetAlFnt{\fontsize{11}{13}\selectfont}
  
  \SetAlCapFnt{\fontsize{11}{13}\selectfont}
  \SetAlCapNameFnt{\fontsize{11}{13}\selectfont}
  % \NoCaptionOfAlgo

  \caption{\texttt{generate\_PCIs}($sitpn$, $d$, $\gamma$, $mmf$)}
  \label{alg:genpcis}
  
  \AlFnt % overriding the new font

  \ForEach{$p\in{}P$}{

    \lIf{$\mathtt{input}(p)=\emptyset$ and $\mathtt{output}(p)=\emptyset$}{\label{line:p-isolated}
      \texttt{err}$("p~is~an~isolated~place")$\label{line:p-isolated-err}
    }
    
    \BlankLine
    $g_p\leftarrow\{(\mathtt{mm},mmf(p))\}$; 
    $i_p\leftarrow\emptyset$; 
    $o_p\leftarrow\emptyset$\; \label{line:init-pcomp}

    \BlankLine
    \uIf{$\mathtt{input}(p)=\emptyset$}{ \label{line:genpcis-inp-p-empty}
      $g_p\leftarrow{}g_p\cup\{(\mathtt{ian},1)\}$\; \label{line:ian-empty}
      $i_p\leftarrow{}i_p\cup\{(\mathtt{iaw}(0),0),(\mathtt{itf}(0),\mathtt{false})\}$\; \label{line:iaw-itf-empty}
    }
    \Else{
      $g_p\leftarrow{}g_p\cup\{(\mathtt{ian},\vert\mathtt{input}(p)\vert)\}$\; \label{line:ian-not-empty}
      $i\leftarrow{}0$\;
      \ForEach{$t\in\mathtt{input}(p)$}{ \label{line:foreach-iaw}
        $i_p\leftarrow{}i_p\cup\{(\mathtt{iaw}(i),post(t,p))\}$\;
        $i\leftarrow{}i+1$\;
      }
    }

    \BlankLine
    \uIf{$\mathtt{output}(p)=\emptyset$}{\label{line:genpcis-out-p-empty}
      $g_p\leftarrow{}g_p\cup\{(\mathtt{oan},1)\}$\; \label{line:oan-empty}
      $i_p\leftarrow{}i_p\cup\{(\mathtt{oaw}(0),0),(\mathtt{oat}(0),\mathtt{basic}),(\mathtt{otf}(0),\mathtt{false})\}$\;
      \label{line:genpcis-out-p-empty-ip}
      $o_p\leftarrow{}o_p\cup\{(\mathtt{oav},\mathtt{open}),(\mathtt{pauths},\mathtt{open}),(\mathtt{rtt},\mathtt{open})\}$\;
      \label{line:genpcis-out-p-empty-op}
    }
    \Else{
      $i\leftarrow{}0$\;
      \ForEach{$t\in\mathtt{output}_c(p)\cup\mathtt{output}_{nc}(p)$}{\label{line:begin-oaw}
        $(\omega,a)\leftarrow{}pre(p,t)$\;
        $i_p\leftarrow{}i_p\cup\{(\mathtt{oaw}(i),\omega),(\mathtt{oat}(i),a)\}$\;
        $i\leftarrow{}i+1$\;
      }
    }

    \BlankLine
    \lIf{$\mathtt{acts}(p)=\emptyset$}{$o_p\leftarrow{}o_p\cup\{(\mathtt{marked},\mathtt{open})\}$}\label{line:genpcis-acts-empty}
    \Else{
      $id_s\leftarrow{}\mathtt{genid}()$\;
      $d.sigs\leftarrow{}d.sigs\cup\{(id_s,\mathtt{boolean})\}$\;
      $o_p\leftarrow{}o_p\cup\{(\mathtt{marked},id_s)\}$\; \label{line:end-op}
    }
    
    \BlankLine
    $id_p\leftarrow{}\mathtt{genid}()$\;\label{line:gen-pcomp-id}
    $d.cs\leftarrow{}d.cs~\mathtt{||}~\mathtt{comp}(\mathtt{id}_p,\mathtt{place},g_p,i_p,o_p)$\;\label{line:gen-pcomp}
    $\gamma\leftarrow\gamma\cup\{(p,\mathtt{id}_p)\}$\;\label{line:gen-bind-p}
  }
\end{algorithm}

The \texttt{generate\_PCIs} procedure, presented in
Algorithm~\ref{alg:genpcis}, has four parameters: $sitpn\in{}SITPN$,
the input SITPN model; $d\in{}design$, the \hvhdl{} design being
generated; $\gamma\in{}WM(sitpn,d)$, the binder between $sitpn$ and
$d$; $mmf\in{}P\rightarrow\mathbb{N}$, the function assigning a
maximal marking value to each place. The procedure iterates over the
set of places of the $sitpn$ parameter. For each place $p$ in the set,
the procedure produces a corresponding PCI $id_p$, and generates its
generic map $g_p$, and its partially-built input and output port maps
$i_p$ and $o_p$. As said before, the only associations generated in
the input and output port maps during this phase pertain to the
association of ports to constant values. At the end of the procedure
(Lines~\ref{line:gen-pcomp-id} to \ref{line:gen-bind-p}), a fresh and
unique component identifier $id_p$ is generated, and a new CI
statement, corresponding to the instantiation of PCI $id_p$, is
composed with the current behavior of design $d$. Finally, the
$\gamma$ binder receives a new couple corresponding to binding of
place $p$ to identifier $id_p$.

From Line~\ref{line:p-isolated} to Line~\ref{line:end-op}, the
procedure generates the generic map, the input port map, and the
output port map of the PCI. First, the procedure checks if the current
place $p$ is isolated, i.e. without input nor output transitions. An
error, with an associated message, is raised with the \texttt{err}
primitive if the test succeeds. The \hilecop{} transformation raises
errors in the presence of an input SITPN model that does not meet the
well-definition property (see Definition~\ref{def:wd-sitpn}). One part
of the well-definition property pertains to the absence of isolated
place in the input model. Line~\ref{line:init-pcomp} initializes the
variables $g_p$, $i_p$ and $o_p$, respectively holding the generic
map, the input port map and the output port map of the generated
PCI. The generic map $g_p$ initially takes a single association that
binds the \texttt{mm} constant to the maximal marking value returned
by the $mmf$ function for place $p$. The input port map $i_p$ and the
output port map $o_p$ are initialized with empty sets.

Line~\ref{line:genpcis-inp-p-empty} tests if the set of input
transitions of $p$ is empty. If the test succeeds, the \texttt{ian}
constant is associated to $1$ in the generic map $g_p$. The size of
the \texttt{iaw} and \texttt{itf} input ports, which are of the array
type, is equal to the value of the \texttt{ian} constant minus
one. Thus, the \texttt{iaw} and \texttt{itf} input ports are composed
of one subelement with index $0$. At Line~\ref{line:iaw-itf-empty},
the sole subelement of the \texttt{iaw} port is associated with $0$,
and the sole subelement of the \texttt{itf} port is associated with
\texttt{false} in the input port map $i_p$. If the set of input
transitions of $p$ is not empty, the \texttt{ian} constant is
associated with the size of the set in the generic map $g_p$. Then,
each subelement of the \texttt{iaw} port is associated with the weight
of the arc between place $p$ and an input transition $t$.  Note that,
in that case, the procedure does not deal with the connection of the
\texttt{itf} port. As the set of input transitions of $p$ is not
empty, the connection of the \texttt{itf} port will be performed by
the \texttt{connect_input_trs} procedure during the generation of the
interconnections between PCIs and TCIs.

Line~\ref{line:genpcis-out-p-empty} tests if the set of output
transitions of $p$ is empty. If the test succeeds, the \texttt{oan}
constant is associated to $1$ in the generic map $g_p$. The size of
the \texttt{oaw}, \texttt{oat} and \texttt{otf} input ports, which are
of the array type, is equal to the value of the \texttt{oan} constant
minus one. Thus, the \texttt{oaw}, \texttt{oat} and \texttt{otf} input
ports are composed of one subelement with index $0$. At
Line~\ref{line:genpcis-out-p-empty-ip}, the sole subelement of the
\texttt{oaw} port is associated with $0$, the sole subelement of the
\texttt{oat} port is associated with \texttt{basic}, and the sole
subelement of the \texttt{otf} port is associated with \texttt{false}
in the input port map $i_p$. Also, in the abscence of output
transitions, the \texttt{oav}, \texttt{pauths} and \texttt{rtt} output
ports are left unconnected, i.e. they are associated with the
\texttt{open} keyword of output port map $o_p$.

If the set of output transitions of $p$ is not empty, the \texttt{oan}
constant is associated with the size of this set in the generic map
$g_p$. Then, each subelement of the \texttt{oaw} (resp. the
\texttt{oat}) port is associated with the weight (resp. the type) of
the arc between place $p$ and an output transition $t$.  Note that, in
that case, the procedure does not handle the connection of the
\texttt{otf} input port, nor the connection of the \texttt{oav},
\texttt{pauths} and \texttt{rtt} output ports. As the set of output
transitions of $p$ is not empty, these connections will be performed
by the \texttt{connect_output_trs} procedure during the generation of
the interconnections between PCIs and TCIs.

From Line~\ref{line:genpcis-acts-empty} to Line~\ref{line:end-op}, the
procedure connects the \texttt{marked} output port in the output port
map $o_p$. If the place $p$ is not associated with any action, the
\texttt{marked} output port is left unconnected, i.e. connected to the
\texttt{open} keyword. Otherwise, the \texttt{marked} output port is
connected to a newly generated internal signal of the Boolean
type. This generated signal joins the internal signal declaration list
of design $d$. The connection between the \texttt{marked} output port
and the internal signal will be used later, during the generation of
the \texttt{action} process (see Section~\ref{sec:genports}).

\begin{algorithm}[H]
  \DontPrintSemicolon

  \SetAlFnt{\fontsize{11}{13}\selectfont}
  
  \SetAlCapFnt{\fontsize{11}{13}\selectfont}
  \SetAlCapNameFnt{\fontsize{11}{13}\selectfont}
  % \NoCaptionOfAlgo

  \caption{\texttt{generate\_TCIs}($sitpn$, $d$, $\gamma$)}
  \label{alg:gentcis}
  
  \AlFnt % overriding the new font

  \ForEach{$t\in{}T$}{

    \lIf{$\mathtt{input}(t)=\emptyset$ and $\mathtt{output}(t)=\emptyset$}{
      \texttt{err}$("t~is~an~isolated~transition")$\label{line:t-isolated}
    }

    \BlankLine
    $g_t\leftarrow\{(\mathtt{tt},\mathtt{get\_ttype}(t)),(\mathtt{mtc},\mathtt{get\_mtc}(t))\}$\;\label{line:init-gt}
    $i_t\leftarrow\{(\mathtt{A},
    \begin{cases}
      0~\mathtt{if}~t\notin{}\mathtt{dom}(I_s) \\
      lower(I_s(t))~otherwise\\
    \end{cases}), (\mathtt{B},
    \begin{cases}
      0~\mathtt{if}~t\notin{}\mathtt{dom}(I_s)\lor{}upper(I_s(t))=\infty \\
      upper(I_s(t))~otherwise\\
    \end{cases})\}$\;\label{line:init-it}

    $id_s\leftarrow{}\mathtt{genid()}$\;\label{line:genid-fired}
    $d.sigs\leftarrow{}d.sigs\cup(id_s,boolean)$\;\label{line:declid-fired}
    $o_t\leftarrow{}\{(\mathtt{fired},id_s)\}$\;\label{line:connect-fired}
    
    \BlankLine
    \uIf{$\mathtt{input}(t)=\emptyset$}{\label{line:gentcis-input-empty}
      $g_t\leftarrow{}g_t\cup\{(\mathtt{ian},1)\}$\;
      $i_t\leftarrow{}i_t\cup\{(\mathtt{iav}(0),\mathtt{true}),(\mathtt{pauths}(0),\mathtt{true}),(\mathtt{rt}(0),id_s)\}$\;
      \label{line:gentcis-in-empty-it}
    }
    \Else{
      $g_t\leftarrow{}g_t\cup\{(\mathtt{ian},\vert{}\mathtt{input}(t)\vert)\}$\;
    }
    
    \BlankLine
    \uIf{$\mathtt{conds}(t)=\emptyset$}{ \label{line:gentcis-conds-empty}
      $g_t\leftarrow{}g_t\cup\{(\mathtt{cn},1)\}$\;
      $i_t\leftarrow{}i_t\cup\{(\mathtt{ic}(0),\mathtt{true})\}$\;
    } 
    \Else{
      $g_t\leftarrow{}g_t\cup\{(\mathtt{cn},\vert{}\mathtt{conds}(t)\vert)\}$\;
    }
    
    \BlankLine
    $id_t\leftarrow{}\mathtt{genid}()$\;\label{line:gen-tcomp-id}
    $d.cs\leftarrow{}d.cs~\mathtt{||}~\mathtt{comp}(\mathtt{id}_t,\mathtt{transition},g_t,i_t,o_t)$\;\label{line:gen-tcomp}
    $\gamma\leftarrow\gamma\cup(t,\mathtt{id}_t)$\;\label{line:gen-bind-t}
  }
\end{algorithm}

The \texttt{generate\_TCIs} procedure, presented in
Algorithm~\ref{alg:gentcis}, iterates over the set of transitions $T$
of the $sitpn$ parameter. For each transition $t$ in the set, the
procedure produces a corresponding TCI $id_t$, and generates its
generic map $g_t$, and its partially-built input and output port maps
$i_t$ and $o_t$.  At the end of the procedure
(Lines~\ref{line:gen-tcomp-id} to \ref{line:gen-bind-t}), a fresh and
unique component identifier $id_t$ is generated, and a new CI
statement, corresponding to the instantiation of TCI $id_t$, is
composed with the current behavior of design $d$. Finally, the
$\gamma$ binder receives a new couple corresponding to binding of
transition $t$ to identifier $id_t$.

At Line~\ref{line:t-isolated}, the procedure checks if transition $t$
is isolated, and raises an error accordingly.
Lines~\ref{line:init-gt} to \ref{line:connect-fired} initialize the
variables $g_t$, $i_t$ and $o_t$, respectively holding the generic
map, the input port map and the output port map of the generated
TCI. The generic map $g_t$ initially takes two associations: the one
between the \texttt{tt} constant and the result of the function call
\texttt{get\_ttype}$(t)$, and the one between the \texttt{mtc}
constant and the result of the function call \texttt{get\_mtc}$(t)$.
The \texttt{get\_ttype} function returns the type of transition $t$,
i.e. either \texttt{NOT\_TEMPORAL}, \texttt{TEMPORAL\_A\_A},
\texttt{TEMPORAL\_A\_B} or \texttt{TEMPORAL\_A\_INFINITE}, based on
the form of the time interval associated with
$t$. Algorithm~\ref{alg:getttype} describes the \texttt{get\_ttype}
function. The \texttt{get\_mtc} function determines the maximal value
for the time counter of $t$ based on the form of the time interval
associated with transition $t$. Algorithm~\ref{alg:getmtc} describes
the \texttt{get\_mtc} function.

\begin{algorithm}[H]
  \DontPrintSemicolon

  \SetAlFnt{\fontsize{11}{13}\selectfont}
  
  \SetAlCapFnt{\fontsize{11}{13}\selectfont}
  \SetAlCapNameFnt{\fontsize{11}{13}\selectfont}
  % \NoCaptionOfAlgo

  \caption{\texttt{get\_ttype}($t$)}
  \label{alg:getttype}
  
  \AlFnt % overriding the new font

  \lIf{$t\notin{}\mathtt{dom}(I_s)$}{
    \Return{\texttt{NOT\_TEMPORAL}}
  }
  \lElseIf{$I_s(t)=[a,a]$}{
    \Return{\texttt{TEMPORAL\_A\_A}}
  }
  \lElseIf{$I_s(t)=[a,b]$}{
    \Return{\texttt{TEMPORAL\_A\_B}}
  }
  \lElseIf{$I_s(t)=[a,\infty]$}{\Return{\texttt{TEMPORAL\_A\_INFINITE}}}
  
\end{algorithm}

\begin{algorithm}[H]
  \DontPrintSemicolon

  \SetAlFnt{\fontsize{11}{13}\selectfont}
  
  \SetAlCapFnt{\fontsize{11}{13}\selectfont}
  \SetAlCapNameFnt{\fontsize{11}{13}\selectfont}
  % \NoCaptionOfAlgo

  \caption{\texttt{get\_mtc}($t$)}
  \label{alg:getmtc}
  
  \AlFnt % overriding the new font

  \lIf{$t\notin{}\mathtt{dom}(I_s)$}{
    \Return{$1$}
  }
  \lElseIf{$I_s(t)=[a,b]$}{
    \Return{$b$}
  }
  \lElseIf{$I_s(t)=[a,\infty]$}{
    \Return{$a$}
  }
  
\end{algorithm}

Line~\ref{line:init-it} sets the value of the \texttt{A} and
\texttt{B} input ports while initializing the input port map
$i_t$. The \texttt{A} port is associated with $0$ if the transition
$t$ is not a time transition (i.e. $t$ has no associated time
interval, it is not in the domain of function $I_s$); otherwise, the
\texttt{A} port is associated with the lower bound of the time
interval of $t$.  The \texttt{B} input port is associated with $0$ if
transition $t$ is not a time transition or if its time interval has an
infinite upper bound; otherwise, the \texttt{B} port is associated
with the upper bound of the time interval of $t$. From
Lines~\ref{line:genid-fired} to \ref{line:connect-fired}, the
procedure connects the \texttt{fired} output port to a newly generated
internal signal in the output port map $o_p$. This internal signal
will then be connected to the input port map of PCIs during the
interconnection phase of the transformation (see
Section~\ref{sec:geninter}).

Line~\ref{line:gentcis-input-empty} checks if the set of input places
of $t$ is empty. If the test succeeds, the \texttt{ian} constant is
associated with $1$ in the generic map $g_t$. The size of the
\texttt{iav}, \texttt{pauths} and \texttt{rt} input ports, which are
of the array type, is equal to the value of the \texttt{ian} constant
minus one. Thus, in the case where the set of input places of $t$ is
empty, the \texttt{iav}, \texttt{pauths} and \texttt{rt} input ports
are composed of one subelement with index $0$. At
Line~\ref{line:gentcis-in-empty-it}, the sole subelements of the
\texttt{iav} and the \texttt{pauths} ports are associated with
\texttt{true}, and the sole subelement of the \texttt{rt} port is
associated with the signal identifier $id_s$. Remember that the
\texttt{fired} output port has been previously connected to the
internal signal $id_s$ in the output port map $o_t$. Thus, the
\texttt{fired} output port is connected to the subelement of the
\texttt{rt} input port with index $0$ through the $id_s$ signal.  This
connection is mandatory to reset the value of the
\texttt{s\_time\_counter} signal (which is an internal signal of the
\texttt{transition} design) in the abscence of input places. If the
set of input places of $t$ is not empty, then the \texttt{ian}
constant is associated with the size of the set in the generic map
$g_t$.

Line~\ref{line:gentcis-conds-empty} checks if the set of conditions
attached to $t$ is empty. If the test succeeds, the \texttt{cn}
constant is associated with $1$ in the generic map $g_t$. The size of
the \texttt{ic} input port, which is of the array type, is equal to
the value of the \texttt{cn} constant minus one. Thus, in the case
where the set of conditions attached to $t$ is empty, the \texttt{ic}
input port is composed of one subelement with index $0$. Then, the
sole subelement of the \texttt{ic} port is associated with
\texttt{true} in the input port map $i_t$. If the set of conditions
attached to $t$ is not empty, the \texttt{cn} constant is associated
with the size of the set in the generic map $g_t$. In that case, the
\texttt{generate\_conds} procedure, presented in
Algorithm~\ref{alg:genconds}, will handle the connection of the
subelements of the \texttt{ic} input port.

\subsection{Interconnection of the place and transition component
  instances}
\label{sec:geninter}

After the generation of PCIs and TCIs, and of all constant
associations in their generic and input port maps, the next step of
the transformation performs the interconnections between the
interfaces of PCIs and TCIs. The \texttt{generate\_interconnections}
procedure, presented in Algorithm~\ref{alg:geninter}, produces these
interconnections.

\begin{algorithm}[H]
  \DontPrintSemicolon

  \SetAlFnt{\fontsize{11}{13}\selectfont}
  
  \SetAlCapFnt{\fontsize{11}{13}\selectfont}
  \SetAlCapNameFnt{\fontsize{11}{13}\selectfont}
  % \NoCaptionOfAlgo

  \caption{\texttt{generate\_interconnections}($sitpn$, $d$, $\gamma$)}
  \label{alg:geninter}
  
  \AlFnt % overriding the new font

  \ForEach{$p\in{}P$}{
    \texttt{comp}$(id_p,\mathtt{place},g_p,i_p,o_p)\leftarrow\mathtt{get\_comp}(\gamma(p),d.cs)$\;\label{line:geninter-getpcomp}

    \BlankLine
    $i\leftarrow{}0$\; \label{geninter-start}
    \ForEach{$t\in\mathtt{input}(p)$}{\label{line:foreach-input-cit}
      \texttt{comp}$(id_t,\mathtt{transition},g_t,i_t,o_t)\leftarrow\mathtt{get\_comp}(\gamma(t),d.cs)$\;
      $i_p\leftarrow\{(\mathtt{itf}(i),\mathtt{actual}(\mathtt{fired},o_t))\}$\;\label{line:connect-itf-fired}
      $i\leftarrow{}i+1$\;
    }\label{line:geninter-end-input}

    \BlankLine
    $i\leftarrow{}0$\;
    \ForEach{$t\in\mathtt{output}_c(p)$}{\label{line:foreach-outc}
      \texttt{comp}$(id_t,\mathtt{transition},g_t,i_t,o_t)\leftarrow\mathtt{get\_comp}(\gamma(t),d.cs)$\;
      $i_p\leftarrow{}i_p\cup\{(\mathtt{otf}(i),\mathtt{actual}(\mathtt{fired},o_t))\}$\; \label{line:otf-fired-1}
      \texttt{connect}$(o_p,i_t,\mathtt{oav}(i),\mathtt{iav},d)$\; \label{line:oav-iav-1}
      \texttt{connect}$(o_p,i_t,\mathtt{rtt}(i),\mathtt{rt},d)$\; \label{line:rtt-rt-1}
      \texttt{connect}$(o_p,i_t,\mathtt{pauths}(i),\mathtt{pauths},d)$\; \label{line:pauths-pauths-1}
      \texttt{put\_comp}$(id_t, \mathtt{comp}(id_t,\mathtt{transition},g_t,i_t,o_t), d.cs)$\; \label{geninter-puttcomp}
      $i\leftarrow{}i+1$\;
    }\label{line:end-foreach-outc}
    
    \ForEach{$t\in\mathtt{output}_{nc}(p)$}{
      \texttt{comp}$(id_t,\mathtt{transition},g_t,i_t,o_t)\leftarrow\mathtt{get\_comp}(\gamma(t),d.cs)$\;\label{line:foreach-outnc}
      $i_p\leftarrow{}i_p\cup\{(\mathtt{otf}(i),\mathtt{actual}(\mathtt{fired},o_t))\}$\; \label{line:otf-fired-2}
      \texttt{connect}$(o_p,i_t,\mathtt{oav}(i),\mathtt{iav},d)$\; \label{line:oav-iav-2}
      \texttt{connect}$(o_p,i_t,\mathtt{rtt}(i),\mathtt{rt},d)$\; \label{line:rtt-rt-2}

      $id_s\leftarrow\mathtt{genid}()$\;\label{line:genid-for-pauths}
      $d.sigs\leftarrow{}d.sigs\cup(id_s,\mathtt{boolean})$\;
      $o_p\leftarrow{}o_p\cup\{(\mathtt{pauths}(i),id_s)\}$\;\label{line:pauths-assoc}
      \texttt{cassoc}$(i_t,\mathtt{pauths},\mathtt{true})$\; \label{line:pauths-true}
      
      \texttt{put\_comp}$(id_t, \mathtt{comp}(id_t,\mathtt{transition},g_t,i_t,o_t), d.cs)$\;\label{line:end-foreach-outnc}
      $i\leftarrow{}i+1$\;
    } \label{geninter-end}
    
    \BlankLine
    \texttt{put\_comp}$(id_p, \mathtt{comp}(id_p,\mathtt{place},g_p,i_p,o_p), d.cs)$\;\label{line:putpcomp-cit}
  }
\end{algorithm}

The \texttt{generate\_interconnections} procedure iterates over the
set of places of the $sitpn$ parameter. For each place $p$, the
procedure generates the interconnections between the PCI $id_p$ and
the TCIs that implement the input and output transitions of $p$; we
will refer to them as the input and output TCIs of PCI $id_p$.

At Line~\ref{line:geninter-getpcomp}, the \texttt{get\_comp} function
returns the PCI associated with the identifier $\gamma(p)$ (i.e. the
PCI identifier associated with place $p$ in $\gamma$) by looking up
the behavior of the design $d$. At this step, we assume that all PCIs
and TCIs, and all bindings pertaining to places and transitions in the
$\gamma$ binder, have been previously generated by the
\texttt{generate\_architecture} procedure. Otherwise, the
\texttt{get\_comp} function raises an error if it is not able to find
the PCI $id_p$ in the behavior of design $d$.

Then, from Line~\ref{geninter-start} to Line~\ref{geninter-end}, the
procedure modifies the input and output port map of PCI $id_p$ and the
input port map of its input and output TCIs. Finally,
Line~\ref{line:putpcomp-cit} replaces the old PCI $id_p$ by the
modified one in the behavior of design $d$.

From Line~\ref{geninter-start} to Line~\ref{line:geninter-end-input},
the procedure iterates over the input transitions of place $p$. Note
that the iteration is performed in the same order than the iteration
performed by the \textbf{foreach} loop at Line~\ref{line:foreach-iaw}
of the \texttt{generate_PCIs} procedure; this is mandatory to preserve
a consistency between the index $i$ and the connection to a given
transition (see Remark~\ref{rem:connections-consistency}).  For each
input transition $t$ of $p$, the corresponding TCI $id_t$ is retrieved
from the behavior of design $d$. Then, the internal signal associated
with the \texttt{fired} output port in the output port map of TCI
$id_t$ is retrieved (i.e. \texttt{actual}$(\mathtt{fired},o_t)$), and
the signal is associated with the subelement of the \texttt{itf} input
port with index $i$. We know that the \texttt{generate_TCIs} function
has generated the association between the \texttt{fired} output port
and an internal signal in the output port map of all TCIs. Thus, the
\texttt{actual} function never raises an error.

\begin{remark}[Connections consistency]
  \label{rem:connections-consistency}
  In the behavior of the \texttt{place} design, some processes access
  to the subelements of composite ports through the use of
  indices. For instance, the \texttt{input\_tokens\_sum} process (see
  Appendix~\ref{app:place-design}) increments a local variable $i$ in
  range $0$ to $\mathtt{input\_arcs\_number}-1$ in a for loop. The
  process tests the value of the \texttt{itf} port's subelement with
  index $i$. If the test suceeds, the process adds the value of the
  \texttt{iaw} port's subelement with index $i$ to the local variable
  \texttt{v\_internal\_input\_token\_sum}. Thus, the subelement with
  index $i$ of the \texttt{itf} and \texttt{iaw} ports must refer to
  the connection to the same transition. Otherwise, the process does
  not compute a correct input tokens
  sum. Figure~\ref{fig:consistent-connections} illustrates the correct
  connection of the \texttt{itf} and \texttt{iaw} ports in the input
  port map of PCI $id_p$ w.r.t. to the connection between transitions
  $t_a$, $t_b$, $t_c$ and place $p$.

  \begin{figure}[H]
    \centering
    \includegraphics[keepaspectratio,width=.8\textwidth]{Figures/Transformation/consistent-indexes}
    \caption[An example of correct connections between several TCIs
    and a PCI.]{An example of correct connections between the PCI
      $id_p$ and TCIs $id_{t_a}$, $id_{t_b}$ and $id_{t_c}$. On the
      left, the input SITPN model showing the connections of the
      transitions $t_a$, $t_b$ and $t_c$ to the place $p$. The dots
      indicate that the place $p$ possibly has other input
      transitions. On the right, the TCIs and the PCI generated by the
      transformation. In the input port map of PCI $id_p$, the
      subelements of the \texttt{itf} input port are connected to the
      \texttt{fired} port of TCIs; the subelements of the \texttt{iaw}
      port are connected to constant values, i.e. the weight of the
      arcs between place $p$ and the input transitions of $p$.}
    \label{fig:consistent-connections}
  \end{figure}

  It is the r√¥le of the transformation function to ensure the
  consistency of the connections of the subelements in the input and
  output port maps of PCIs. The input and output port maps of TCIs are
  not subject to such a constraint. The fact that a \textbf{foreach}
  loop always iterates in the same order over the elements of a set
  ensures the consistency of the connections.
\end{remark}

From Line~\ref{line:foreach-outc} to Line~\ref{line:end-foreach-outc},
the procedure connects the PCI $id_p$ to the TCIs implementing the
conflicting output transitions of place $p$. For each conflicting
output transition $t$ of $p$, the corresponding TCI $id_t$ is
retrieved from the behavior of design $d$. The function call
\texttt{actual}$(\mathtt{fired},o_t)$ returns the internal signal
associated with the \texttt{fired} output port in the output port map
of TCI $id_t$. This internal signal is then connected to the
subelement of the \texttt{otf} input port with index $i$ in the input
port map of PCI $id_p$. At Line~\ref{line:oav-iav-1}, the
\texttt{connect} function generates an internal signal $id$ and adds
it to the internal signal declaration list of design $d$. Then, the
function associates the subelement \texttt{oav}$(i)$ (i.e. the
subelement of the \texttt{oav} input port with index $i$) with the
internal signal $id$ in the output port map $o_p$, and it associates
one subelement of the \texttt{iav} input port to the internal signal
$id$ in the input port map $i_t$. The \texttt{connect} function
operates similarly on the \texttt{rtt} output port and the \texttt{rt}
input port at Line~\ref{line:rtt-rt-1}, and on the \texttt{pauths}
input port and the \texttt{pauths} output port at
Line~\ref{line:pauths-pauths-1}. Finally, at
Line~\ref{geninter-puttcomp}, the old TCI $id_t$ is replaced by the
modified one in the behavior of design $d$.

From Line~\ref{line:foreach-outnc} to
Line~\ref{line:end-foreach-outnc}, the procedure connects the TCIs
implementing to the output transitions of $p$ that are not in
conflict. Note that the variable $i$ is not reset between the two
\textbf{foreach} loops to preserve the continuity of indices.  For
each non-conflicting output transition $t$ of $p$, the corresponding
TCI $id_t$ is retrieved from the behavior of design $d$. Then, the
interconnections between PCI $id_p$ and TCI $id_t$ are similarly to
the ones that have been performed for the conflicting transitions of
$p$. The difference lies in the connection the \texttt{pauths} ports.
Between the PCI $id_p$ and its \textit{non-conflicting} TCIs, the
\texttt{pauths} are not connected together; this to reflect the
independence of non-conflicting output transitions regarding the
priority authorizations. Instead, the subelement of the
\texttt{pauths} output port with index $i$ is connected to a newly
generated internal signal $id_s$ in the output port map $o_p$
(Line~\ref{line:genid-for-pauths} to
Line~\ref{line:pauths-assoc}). Also, one subelement of the
\texttt{pauths} input port is associated with \texttt{true} in the
input port map $i_t$ (Line~\ref{line:pauths-true}).

\subsection{Generation of ports, the \texttt{action} and the
  \texttt{function} process}
\label{sec:genports}

\begin{algorithm}[H]
  \DontPrintSemicolon

  \SetAlFnt{\fontsize{11}{13}\selectfont}
  
  \SetAlCapFnt{\fontsize{11}{13}\selectfont}
  \SetAlCapNameFnt{\fontsize{11}{13}\selectfont}
  % \NoCaptionOfAlgo

  \caption{\texttt{generate\_conds}($sitpn$, $d$, $\gamma$)}
  \label{alg:genconds}
  
  \AlFnt % overriding the new font
\end{algorithm}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../main"
%%% End:
