In this section, we give the algorithm underlying the \hilecop{}
model-to-text transformation. This algorithm is the base of the \coq{}
implementation of the \hilecop{} transformation; the implementation is
presented in Section~\ref{sec:trans-coq-impl}. As stated in
Chapter~\ref{chap:hilecop}, there exists a Java implementation of the
\hilecop{} methodology. This implementation embeds the generation of
VHDL code from an SITPN model. However, the algorithm of the
transformation has never been devised, nor a formal specification
given. The following algorithm is one of the contribution of this
thesis. It has been devised through the examination of the code of the
existing Java implementation, and through the discussions with the
designers of the \hilecop{} methodology.

\subsection{The \texttt{sitpn_to_hvhdl} function}
\label{sec:sitpn-to-hvhdl}

The \hilecop{} transformation algorithm, presented in
Algorithm~\ref{alg:sitpn2hvhdl}, generates a \hvhdl{} design and a
SITPN-to-\hvhdl{} binder from an input SITPN. A SITPN-to-\hvhdl{}
design binder is a structure that binds the elements of an SITPN
(places, transitions, actions\dots) to the elements of a \hvhdl{}
design (component instances or signals). As it is generated along the
transformation, the binder links a SITPN element to its \hvhdl{}
\textit{implementation}, i.e. the \hvhdl{} element that will
supposedly behave similarly to the source SITPN element at
runtime. Thus, the SITPN-to-\hvhdl{} design binder is at the center of
the state similarity relation, presented in Chapter~\ref{chap:proof},
and that enables the comparison between an SITPN state and an \hvhdl{}
design state. The formal definition of an SITPN-to-\hvhdl{} design
binder is as follows.

\begin{definition}[SITPN-to-\hvhdl{} design binder]
  \label{def:sitpn-to-hvhdl-binder}
  Given a $sitpn\in{}SITPN$ and a \hvhdl{} design $d\in{}design$, a
  SITPN-to-\hvhdl{} design binder $\gamma\in{}WM(sitpn,d)$ is a tuple\\
  ${<}PMap,TMap,CMap,AMap,FMap{>}$
  where:
  \begin{itemize}
  \item
    $sitpn={<}P,T,pre,test,inhib,post,M_0,{\succ},\mathcal{A},\mathcal{C},\mathcal{F},
    \mathbb{A},\mathbb{C},\mathbb{F},{I_s}{>}$
  \item $d=$ \vhdle|design| \textit{$id_{e}$ $id_{a}$ gens ports sigs cs}
  \item $PMap\in{}P\rightarrow{}\{id~|~\mathtt{comp}(id,\mathtt{place},g,i,o)\in{}cs\}$
  \item $TMap\in{}T\rightarrow{}\{id~|~\mathtt{comp}(id,\mathtt{transition},g,i,o)\in{}cs\}$
  \item $CMap\in\mathcal{C}\rightarrow\{id~|~(\mathtt{in}, id, t)\in{}ports\}$
  \item $AMap\in\mathcal{A}\rightarrow\{id~|~(\mathtt{out}, id, t)\in{}ports\}$
  \item $FMap\in\mathcal{F}\rightarrow\{id~|~(\mathtt{out}, id, t)\in{}ports\}$        
  \end{itemize}
\end{definition}

As presented in Definition~\ref{def:sitpn-to-hvhdl-binder}, the binder
is composed of five sub-environments that map the different SITPN sets
to identifiers. The $PMap$ and $TMap$ sub-environments map the places
to their corresponding PCI identifiers, and the transitions to their
corresponding TCI identifiers. The $CMap$ sub-environment maps the
conditions to input port identifiers. The $AMap$ and $FMap$
sub-environments map the actions and functions to output port
identifiers. In what follows, for a given binder $\gamma$ and an
element of an SITPN structure
$e\in{}P\sqcup{}T\sqcup\mathcal{C}\sqcup\mathcal{A}\sqcup\mathcal{F}$,
we write $\gamma(e)$ where $e$ is looked up in the appropriate
function. For instance, for a given $f\in\mathcal{F}$, $\gamma(f)$ is
a shorthand for $FMap(f)$ where $\gamma={<}\dots,FMap{>}$.

Algorithm~\ref{alg:sitpn2hvhdl} is the algorithm of the \hilecop{}
model-to-text transformation. The algorithm as four parameters; the
first one is the input SITPN model; $id_e$ and $id_a$ are the entity
and the architecture identifiers for the generated \hvhdl{} design;
$mmf\in{}P\rightarrow\mathbb{N}$ is the function associating a maximal
marking value to each place of the input SITPN. This function is the
result of the analysis of the input SITPN.

\begin{remark}[Bounded SITPN]
  \label{rem:bounded-sitpn}
  A part of the analysis is interested in determining the maximal
  number of tokens that a place can hold during the execution of a
  SITPN. If each place of the SITPN can only hold a limited number of
  tokens during the execution, then the model is said to be
  bounded. In that case, a function associated the places with a
  maximal marking value can be computed. Thus, the presence of the
  $mmf$ function as a parameter of the \texttt{sitpn\_to\_hvhdl}
  function implies that the input SITPN model is bounded. In the case
  of an unbounded input model, there exists a place that can
  accumulate an infinite number of tokens during the model
  execution. In the world of hardware description, and especially when
  aiming at the hardware synthesis, every element must have a finite
  dimension. In the definition of the \texttt{place} design, the
  internal signal \texttt{s\_marking} represents the marking value of
  a place. The maximal value of the \texttt{s\_marking} signal is
  bounded by the generic constant \texttt{maximal\_marking}. Thus,
  when generating, a PCI from a place in the course of the
  transformation, we must be able to give a value to the
  \texttt{maximal\_marking} generic constant. However, even with a
  settled \texttt{maximal\_marking} value, the execution of a \hvhdl{}
  design, resulting from the transformation of an unbounded SITPN
  model, could lead to the overflow of the value of the
  \texttt{s\_marking} signals in the internal states of PCIs.  Thus,
  it is impossible to prove the equivalence between the behavior of an
  unbounded SITPN model and its corresponding \hvhdl{} design. 
\end{remark}

\begin{algorithm}[H]
  \DontPrintSemicolon

  \SetAlFnt{\fontsize{11}{13}\selectfont}
  
  \SetAlCapFnt{\fontsize{11}{13}\selectfont}
  \SetAlCapNameFnt{\fontsize{11}{13}\selectfont}
  % \NoCaptionOfAlgo

  \caption{\texttt{sitpn\_to\_hvhdl}($sitpn$, $id_e$, $id_a$, $mmf$)}
  \label{alg:sitpn2hvhdl}
  
  \AlFnt % overriding the new font

  $d\leftarrow\mathtt{design}$ $id_e$ $id_a$ $\emptyset$ $\emptyset$ $\emptyset$ $\mathtt{null}$\; \label{line:init-design}
  $\gamma\leftarrow\emptyset$\; \label{line:init-binder}
  \BlankLine

  \texttt{generate\_architecture}($sitpn$, $d$, $\gamma$, $mmf$)\; \label{line:genarch}
  \texttt{generate\_interconnections}($sitpn$, $d$, $\gamma$)\; \label{line:geninter}
  \texttt{generate\_ports}($sitpn$, $d$, $\gamma$)\; \label{line:genports}
  \BlankLine  

  \Return{($d$,$\gamma$)}\;
\end{algorithm}

In Algorithm~\ref{alg:sitpn2hvhdl}, Line~\ref{line:init-design}
creates the \hvhdl{} design. Initially, the design has an empty port
declaration set, an empty internal signal declaration set, and a
behavior defined by the \texttt{null} statement. The design generated
by the \texttt{sitpn\_to\_hvhdl} function has an empty set of generic
constant, even at the end of the
transformation. Line~\ref{line:init-binder} initializes the $\gamma$
binder with empty sub-environments. From Lines~\ref{line:genarch} to
\ref{line:genports}, the called procedures modify the design and the
binder structures. Each part of the sequence corresponds to one step
of the transformation, which were outlined in
Section~\ref{sec:informal-transf}. The content of the
\texttt{generate\_architecture} function is detailled in Algorithms,
the content of the \texttt{generate\_interconnections} function is
detailled in Algorithms, and the content of the
\texttt{generate\_ports} function is detailled in Algorithms.

\subsection{Primitive functions and sets}
\label{sec:prim-funs}

The description of further functions and algorithms appeals to some
primitive functions and set definitions that we introduce here. Below
are all the sets that we use in the description of the algorithms.

\begin{itemize}
\item
  \texttt{input}$(p)=\{t~\vert~\exists\omega~s.t.~post(t,p)=\omega\}$,
  the set of input transitions of a place $p$.
\item
  \texttt{output}$(p)=\{t~\vert~\exists{}\omega,a~s.t.~pre(p,t)=(\omega,a)\}$,
  the set of output transitions of a place $p$.

\item \texttt{acts}$(p)=\{a~\vert~\mathbb{A}(p,a)=\mathtt{true}\}$,
  the set of actions associated with a place $p$.
\item
  \texttt{input}$(t)=\{p~\vert~\exists\omega,a~s.t.~pre(p,t)=(\omega,a)\}$,
  the set of input places of a transition $t$.
\item
  \texttt{output}$(t)=\{p~\vert~\exists\omega~s.t.~post(t,p)=\omega\}$,
  the set of output places of a transition $t$.
\item
  \texttt{conds}$(t)=\{c~\vert~\mathbb{C}(t,c)=1\lor\mathbb{C}(t,c)=-1\}$,
  the set of conditions associated with a transition $t$.
\item
  \texttt{trs}$(c)=\{t~\vert~\mathbb{C}(t,c)=1\lor\mathbb{C}(t,c)=-1\}$,
  the set of transitions to which a condition $c$ is associated.
\item \texttt{pls}$(a)=\{p~\vert~\mathbb{A}(p,a)=\mathtt{true}\}$, the
  set of places to which an action $a$ is associated.
\item \texttt{trs}$(f)=\{t~\vert~\mathbb{F}(t,f)=\mathtt{true}\}$, the
  set of transitions to which a function $f$ is associated.
\end{itemize}

Every above set are unordered. However, we assume that, every time we
iterate over the elements of an unordered set with a \textbf{foreach}
statement, the iteration respects an arbitrary order. This order is
always the same through the multiple calls to \textbf{foreach}
statements.

Now, let us introduce some primitive functions and procedures that we
use in the description of the following algorithms.

\begin{itemize}
\item \texttt{output}$_c(p)$. The function operates the following
  sequence:
  \begin{enumerate}
  \item if all conflicts between the output transitions of $p$ are
    solved by mutual exclusion, or if the set of conflicting
    transitions of $p$ is a singleton, then returns an empty set.
  \item otherwise, tries to establish a total ordering over the set of
    conflicting transitions of $p$ w.r.t the firing priority relation:
    \begin{itemize}
    \item raises an error if no such ordering can be established (in
      that case, the firing priority relation is ill-formed, and the
      input SITPN is not well-defined).
    \item returns the ordered set, with the top-level priority
      transition at the head.
    \end{itemize}
  \end{enumerate}

\item \texttt{output}$_{nc}(p)$. If all conflicts between the output
  transitions of $p$ are solved by mutual exclusion, or if the set of
  conflicting transitions of $p$ is a singleton, then, the function
  returns the set of output transitions of $p$, i.e
  \texttt{output}$(p)$ as defined above. Otherwise, the function
  returns the set of output transitions of $p$ connected through a
  \texttt{test} or an \texttt{inhib} arc,
  i.e.
  $\{t~\vert~\exists\omega~s.t.~pre(p,t)=(\omega,\mathtt{test})\lor{}pre(p,t)=(\omega,\mathtt{inhib})\}$.

\item \texttt{cassoc}$(map,id,x)$ where $map$ is either a generic map,
  an input port map or an output port map, $id$ is an identifier, $x$
  is an expression, a name (i.e. an simple or indexed identifier) or
  the \texttt{open} keyword. The \texttt{cassoc} procedure adds an
  association of the form $(id(i),x)$ to the $map$ structure. The
  index $i$ is computed as follows based on the content of $map$:
  \begin{enumerate}
  \item looks up $id(j)$ with $max(j)$ in the formal parts of $map$
  \item if no such $j$, adds $(id(0),x)$ in $map$
  \item if such $j$, adds $(id(j+1),x)$ in $map$
  \end{enumerate}

  \noindent{}\textit{Examples:}
  \begin{itemize}
  \item
    \texttt{cassoc}$(~\mathtt{((s(0),\mathtt{true}),(s(1),\mathtt{false}))},~\mathtt{s},~\mathtt{true})$
    yields the resulting map \\
    $\mathtt{((s(0),\mathtt{true}),(s(1),\mathtt{false}),(s(2),\mathtt{true}))}$.
  \item
    \texttt{cassoc}$(~\mathtt{((s(0),\mathtt{true}),(s(1),\mathtt{false}))},~\mathtt{a},~\mathtt{open})$
    yields the resulting map \\
    $\mathtt{((s(0),\mathtt{true}),(s(1),\mathtt{false}),(a(0),\mathtt{open}))}$.
  \end{itemize}

\item \texttt{get\_comp}$(id_c, cstmt)$ where $id_c$ is an
  identifier, and $cstmt\in{}\mathrm{cs}$ is a \hvhdl{} concurrent
  statement. The \texttt{get\_comp} function looks up $cstmt$ for a
  component instantiation statement labelled with $id_c$ as a
  component instance identifier, and returns the component
  instantiation statement when found. The \texttt{get\_comp} function
  throws an error if no component instantiation statement with
  identifier $id_c$ exists in $cstmt$, or if there ecist multiple
  component instantiation statements with identifier $id_c$ in
  $cstmt$.
\item \texttt{put\_comp}$(id_c,cistmt,cstmt)$ where $id_c$ is an
  identifier, $cistmt$ is a component instantiation statement, and
  $cstmt\in{}\mathrm{cs}$ is a \hvhdl{} concurrent statement. The
  \texttt{put\_comp} procedure looks up in $cstmt$ for a component
  instantiation statement with identifier $id_c$, and replaces the
  statement with $cistmt$ in $cstmt$. If no CIS with identifier $id_c$
  exists in $cstmt$, then $cistmt$ is composed with $cstmt$ with the
  \texttt{||} operator. The \texttt{put\_comp} procedure throws an
  error if multiple CIS with identifier $id_c$ exist in $cstmt$.
\item \texttt{actual}$(id,map)$ where $id$ is an identifier and $map$
  is a generic, an input port or an output port map. The
  \texttt{actual} function returns the actual part associated with the
  formal part $id$ in $map$, i.e. returns $a$ if $(id,a)\in{}map$. The
  function throws an error if $id$ is not a formal part in $map$, or
  if there are multiple association with $id$ as a formal part in
  $map$.
\item \texttt{genid}$()$. The \texttt{genid} function returns a fresh
  and unique identifier. During the transformation, we appeal to it
  when a new internal signal, a new port or a new component instance
  must be declared or generated.
\end{itemize}

Algorithm~\ref{alg:connect} presents the \texttt{connect} procedure.
The procedure takes an output port map $o$, an input port map $i$, two
identifiers $id_1,id_2$ and a \hvhdl{} design $d$ as parameters. The
procedure generates an internal signal $id_s$ and adds it to the
internal signal declaration list of design $d$. Then, the procedure
connects a subelement of port $id_1$ (resp. $id_2$) to the internal
signal $id_s$ in the output port map $o$ (resp. input port map $i$).
As the result, a subelement of $id_1$ is connected to a subelement of
$id_2$ through the internal signal $id_s$.

\begin{algorithm}[H] \DontPrintSemicolon

  \SetAlFnt{\fontsize{11}{13}\selectfont}
  
  \SetAlCapFnt{\fontsize{11}{13}\selectfont}
  \SetAlCapNameFnt{\fontsize{11}{13}\selectfont} % \NoCaptionOfAlgo

  \caption{\texttt{connect}($o$, $i$, $n$, $id$, $d$)}
  \label{alg:connect}

  $id_s\leftarrow\mathtt{genid}()$\;
  $d.sigs\leftarrow{}d.sigs\cup(id_s,\mathtt{boolean})$\;
  $o\leftarrow{}o\cup(n,id_s)$\; \texttt{cassoc}$(i,id,id_s)$\;
\end{algorithm}

\paragraph{Complementary notations}
When there is no ambiguity, $id_p$ (resp. $id_t$) denotes the PCI
(resp. TCI) identifier associated to a given place $p$
(resp. transition $t$) through $\gamma(p)=id_p$
(resp. $\gamma(t)=id_t$), where $\gamma$ is the binder returned by the
transformation function. Similarly, $id_c$ (resp. $id_a$ and $id_f$)
denotes the input port (resp. output port) identifier associated to a
given condition $c$ (resp. action $a$ and function $f$) through
$\gamma(c)=id_c$.

\subsection{Generation of component instances and constant parts}
\label{sec:genarch}

The first step of the transformation generates the PCIs and TCIs,
their generic map, and the constant part of their input port maps, in
the behavior of the \hvhdl{} design. This is when places are bound to
PCI identifiers, and transitions are bound to TCI identifiers in the
$\gamma$ binder. Also, the \texttt{marked} output port and the
\texttt{fired} output port are connected in the output port map of
PCIs and TCIs during this first generation
step. Algorithm~\ref{alg:genarch} presents the content of the
\texttt{generate\_architecture} procedure that implements this first
part of code generation. The \texttt{generate\_architecture} procedure
is decomposed in two procedures: \texttt{generate\_PCIs} generates the
PCIs in the behavior of $d$, and binds the PCI identifiers to places
in the $\gamma$ binder; \texttt{generate\_TCIs} generates the TCIs in
the behavior of $d$, and binds the TCI identifiers to transitions in
the $\gamma$ binder. Note that in the following algorithms, the
generic constant, internal signal and port identifiers defined in the
\texttt{place} and \texttt{transition} designs are referred to by
their alias names (see Table~\ref{tab:consts-and-sigs-ref}).

\begin{algorithm}[H]
  \DontPrintSemicolon

  \SetAlFnt{\fontsize{11}{13}\selectfont}
  
  \SetAlCapFnt{\fontsize{11}{13}\selectfont}
  \SetAlCapNameFnt{\fontsize{11}{13}\selectfont}
  % \NoCaptionOfAlgo

  \caption{\texttt{generate\_architecture}($sitpn$, $d$, $\gamma$, $mmf$)}
  \label{alg:genarch}
  
  \AlFnt % overriding the new font

  \texttt{generate\_PCIs}($sitpn$, $d$, $\gamma$, $mmf$)\; \label{line:genpcis}
  \texttt{generate\_TCIs}($sitpn$, $d$, $\gamma$)\; \label{line:gentcis}

\end{algorithm}

Algorithm~\ref{alg:genpcis} presents the content of the
\texttt{generate\_PCIs} procedure. The procedure has four parameters:
$sitpn\in{}SITPN$, the input SITPN model; $d\in{}design$, the \hvhdl{}
design being generated; $\gamma\in{}WM(sitpn,d)$, the binder between
$sitpn$ and $d$; $mmf\in{}P\rightarrow\mathbb{N}$, the function
assigning a maximal marking value to each place. The procedure
iterates over the set of places $P$ of the $sitpn$ parameter.  At
Line~\ref{line:p-isolated}, the procedure checks if place $p$ is
isolated, i.e. without input nor output transitions. An error, with an
associated message, is raised with the \texttt{err} primitive if one
place of $sitpn$ is isolated. The \hilecop{} transformation raises
errors in the presence of an input SITPN model that does not meet the
well-definition property (see Definition~\ref{def:wd-sitpn}). One part
of the well-definition property pertains to the absence of isolated
place in the input model. Then, for each place in set $P$, the
procedure generates a corresponding PCI.

Line~\ref{line:build-gmap} builds the generic map of the PCI. The
three generic constants defined in the generic clause of the
\texttt{place} design receive a value.  In the generated generic map,
the \texttt{input\_arcs\_number} (resp. \texttt{output\_arcs\_number})
generic constant is associated with 1 if the set of input
(resp. output) transitions of $p$ is empty, or with the size of the
set otherwise. The \texttt{maximal\_marking} constant is associated
with the value returned by the $mmf$ function for the place $p$.

From Lines~\ref{line:init-ipmap} to \ref{line:end-ipmap}, the
procedure partially builds the input port map of the PCI; the
generated associations only pertain to the input ports associated with
constant values. At Line~\ref{line:foreach-iaw}, each subelement of
the \texttt{input\_arcs\_weights} input port is associated with the
weight of the arc between place $p$ and one of its input
transition. For example, let us take a place $p$, and
$\{t_0,t_1,t_2\}$, the set of input transitions of $p$; the
\textbf{foreach} loop of Line~\ref{line:foreach-iaw} generates the
following input port map:
$((\mathtt{iaw}(0),post(t_0,p)),(\mathtt{iaw}(1),post(t_1,p)),(\mathtt{iaw}(2),post(t_2,p)))$.
Line~\ref{line:iaw-empty} deals with the particular case where the set
of input transitions of $p$ is empty. From Lines~\ref{line:begin-oaw}
to \ref{line:end-ipmap}, each subelement of the
\texttt{output_arcs_weights} (resp. the \texttt{output_arcs_types})
input port is associated with the weight (resp. type) of the arc
between place $p$ and one of its output
transition. Line~\ref{line:oaw-empty} deals with the case where the
set of output transitions of $p$ is empty.

From Lines~\ref{line:init-opmap} to \ref{line:end-opmap}, the
procedure connects the \texttt{marked} output port in the output port
map $o_p$. In the case where place $p$ is not associated with any
action (Line~\ref{line:acts-empty}), the \texttt{marked} output port
is connected to the \texttt{open} keyword, i.e. not
connected. Otherwise, the \texttt{marked} output port is connected to
a newly generated internal signal of the Boolean type. This connection
will be used later, during the generation of the \texttt{action}
process (see Section~\ref{sec:genports}).

Finally, from Lines~\ref{line:gen-comp-id} to \ref{line:gen-bind-p},
the procedure generates a fresh component identifier for place $p$,
builds a new PCI that holds the previously generated generic map,
input and output port maps, and adds the PCI to the behavior of design
$d$ by composition with the \texttt{||}
operator. Line~\ref{line:gen-bind-p} adds the binding between place
$p$ and the PCI identifier $id_p$ to the $\gamma$ binder.

\begin{algorithm}[H]
  \DontPrintSemicolon

  \SetAlFnt{\fontsize{11}{13}\selectfont}
  
  \SetAlCapFnt{\fontsize{11}{13}\selectfont}
  \SetAlCapNameFnt{\fontsize{11}{13}\selectfont}
  % \NoCaptionOfAlgo

  \caption{\texttt{generate\_PCIs}($sitpn$, $d$, $\gamma$, $mmf$)}
  \label{alg:genpcis}
  
  \AlFnt % overriding the new font

  \ForEach{$p\in{}P$}{

    \lIf{$\mathtt{input}(p)=\emptyset$ and $\mathtt{output}(p)=\emptyset$}{
      \texttt{err}$("p~is~an~isolated~place")$\label{line:p-isolated}
    }
    
    \BlankLine
    $g_p\leftarrow\{(\mathtt{mm},mmf(p))\}$; 
    $i_p\leftarrow\mathtt{()}$; 
    $o_p\leftarrow\mathtt{()}$\; \label{line:init-pcomp}

    \BlankLine
    \uIf{$\mathtt{input}(p)=\emptyset$}{
      $g_p\leftarrow{}g_p\cup\{(\mathtt{ian},1)\}$\; \label{line:ian-empty}
      $i_p\leftarrow{}i_p\cup\{(\mathtt{iaw}(0),0),(\mathtt{itf}(0),\mathtt{false})\}$\; \label{line:iaw-itf-empty}
    }
    \Else{
      $g_p\leftarrow{}g_p\cup\{(\mathtt{ian},\vert\mathtt{input}(p)\vert)\}$\; \label{line:ian-not-empty}
      $i\leftarrow{}0$\;
      \ForEach{$t\in\mathtt{input}(p)$}{ \label{line:foreach-iaw}
        $i_p\leftarrow{}i_p\cup\{(\mathtt{iaw}(i),post(t,p))\}$\;
        $i\leftarrow{}i+1$\;
      }
    }

    \BlankLine
    \uIf{$\mathtt{output}(p)=\emptyset$}{\label{line:oaw-empty}
      $g_p\leftarrow{}g_p\cup\{(\mathtt{oan},1)\}$\; \label{line:oan-empty}
      $i_p\leftarrow{}i_p\cup\{(\mathtt{oaw}(0),0),(\mathtt{oat}(0),\mathtt{basic}),(\mathtt{otf}(0),\mathtt{false})\}$\;
      $o_p\leftarrow{}o_p\cup\{(\mathtt{oav},\mathtt{open}),(\mathtt{pauths},\mathtt{open}),(\mathtt{rtt},\mathtt{open})\}$\;
    }
    \Else{
      $i\leftarrow{}0$\;
      \ForEach{$t\in\mathtt{output}_c(p)\cup\mathtt{output}_{nc}(p)$}{\label{line:begin-oaw}
        $(\omega,a)\leftarrow{}pre(p,t)$\;
        $i_p\leftarrow{}i_p\cup\{(\mathtt{oaw}(i),\omega),(\mathtt{oat}(i),a)\}$\;
        $i\leftarrow{}i+1$\;
      }
    }

    \BlankLine
    \lIf{$\mathtt{acts}(p)=\emptyset$}{$o_p\leftarrow{}o_p\cup\{(\mathtt{marked},\mathtt{open})\}$}\label{line:acts-empty}
    \Else{
      $id_s\leftarrow{}\mathtt{genid}()$\;
      $d.sigs\leftarrow{}d.sigs\cup(id_s,\mathtt{boolean})$\;
      $o_p\leftarrow{}o_p\cup(\mathtt{marked},id_s)$\; \label{line:end-opmap}
    }
    
    \BlankLine
    $id_p\leftarrow{}\mathtt{genid}()$\;\label{line:gen-comp-id}
    $d.cs\leftarrow{}d.cs~\mathtt{||}~\mathtt{comp}(\mathtt{id}_p,\mathtt{place},g_p,i_p,o_p)$\;\label{line:gen-comp}
    $\gamma\leftarrow\gamma\cup(p,\mathtt{id}_p)$\;\label{line:gen-bind-p}
  }
\end{algorithm}

Algorithm~\ref{alg:gentcis} presents the content of the
\texttt{generate\_TCIs} procedure. The procedure iterates over the set
of transitions $T$ of the $sitpn$ parameter, and generates a
corresponding TCI for every transition $t\in{}T$.  At
Line~\ref{line:t-isolated}, the procedure checks if transition $t$ is
isolated, i.e. without input nor output places.

Line~\ref{line:build-gt} builds the generic map of the TCI.  The
\texttt{transition\_type} generic constant is associated with the
result of the function call \texttt{get\_ttype}$(t)$. The
\texttt{get\_ttype} function returns the type of transition $t$,
i.e. either \texttt{NOT\_TEMPORAL}, \texttt{TEMPORAL\_A\_A},
\texttt{TEMPORAL\_A\_B} or \texttt{TEMPORAL\_A\_INFINITE}, based on
the form of the time interval associated to
$t$. Algorithm~\ref{alg:getttype} describes function
\texttt{get\_ttype}.

\begin{algorithm}[H]
  \DontPrintSemicolon

  \SetAlFnt{\fontsize{11}{13}\selectfont}
  
  \SetAlCapFnt{\fontsize{11}{13}\selectfont}
  \SetAlCapNameFnt{\fontsize{11}{13}\selectfont}
  % \NoCaptionOfAlgo

  \caption{\texttt{get\_ttype}($t$)}
  \label{alg:getttype}
  
  \AlFnt % overriding the new font

  \lIf{$t\notin{}\mathtt{dom}(I_s)$}{
    \Return{\texttt{NOT\_TEMPORAL}}
  }
  \lElseIf{$I_s(t)=[a,a]$}{
    \Return{\texttt{TEMPORAL\_A\_A}}
  }
  \lElseIf{$I_s(t)=[a,b]$}{
    \Return{\texttt{TEMPORAL\_A\_B}}
  }
  \lElseIf{$I_s(t)=[a,\infty]$}{\Return{\texttt{TEMPORAL\_A\_INFINITE}}}
  
\end{algorithm}

The \texttt{maximal\_time\_counter} generic constant is associated
with the result of the function call \texttt{get\_mtc}$(t)$. The
\texttt{get\_mtc} function determines the maximal value for the time
counter based on the form of the time interval associated with
transition $t$. Algorithm~\ref{alg:getmtc} describes function
\texttt{get\_mtc}.

\begin{algorithm}[H]
  \DontPrintSemicolon

  \SetAlFnt{\fontsize{11}{13}\selectfont}
  
  \SetAlCapFnt{\fontsize{11}{13}\selectfont}
  \SetAlCapNameFnt{\fontsize{11}{13}\selectfont}
  % \NoCaptionOfAlgo

  \caption{\texttt{get\_mtc}($t$)}
  \label{alg:getmtc}
  
  \AlFnt % overriding the new font

  \lIf{$t\notin{}\mathtt{dom}(I_s)$}{
    \Return{$1$}
  }
  \lElseIf{$I_s(t)=[a,b]$}{
    \Return{$b$}
  }
  \lElseIf{$I_s(t)=[a,\infty]$}{
    \Return{$a$}
  }
  
\end{algorithm}

The \texttt{input\_arcs\_number} (resp. \texttt{conditions\_number})
generic constant is associated with 1 if the set of input places
(resp. conditions) of $t$ is empty, or with the size of the set
otherwise.

From Lines~\ref{line:init-it} to \ref{line:B}, the procedure builds
the input port map of the TCI. Line~\ref{line:conds-empty} deals with
the particular case where the set of conditions of $t$ is empty; in
that case, the $(\mathtt{ic(0)},0)$ association is appended to the
$i_t$ map. In the case where the set of conditions of $t$ is not
empty, the \texttt{genarate\_conds} procedure, presented in
Algorithm~\ref{alg:genconds}, will handle the connection of the
\texttt{input\_conditions} input port in the input port map of TCIs.
Line~\ref{line:A} adds the association $(\mathtt{A},0)$ to the $i_t$
map if $t$ is not a time transition (i.e. $t$ has no associated time
interval, it is not in the domain of function $I_s$), or
$(\mathtt{A},upper(I_s(t)))$ otherwise. Line~\ref{line:B} adds the
association $(\mathtt{B},0)$ to the $i_t$ map if $t$ is not a time
transition or has an infinite upper bound.  Otherwise, the association
$(\mathtt{B},upper(I_s(t)))$ joins the $i_t$ map.

From Lines~\ref{line:genid-fired} to \ref{line:connect-fired}, the
procedure connects the \texttt{fired} input port to a newly generated
internal signal in the output port of the TCI. This internal signal
will then be connected to the input port map of PCIs during the
interconnection phase of the transformation (see
Section~\ref{sec:geninter}). At Line~\ref{line:input-empty-rt}, if the
set of input places of $t$ is empty, then the subelement of index $0$
of the \texttt{reinit\_time} input port must be connected to the
\texttt{fired} output port of the same TCI through the newly generated
internal signal $id_s$. This connection represents the fact that, in
the absence of input places, resetting the value of a transition's
time counter only depends on the firing status of the transition.

Finally, from Lines~\ref{line:gen-tcomp-id} to \ref{line:gen-bind-t},
the procedure generates a fresh component identifier for transition
$t$, builds a new TCI that holds the previously generated generic map,
input and output port maps, and adds the TCI to the behavior of design
$d$ by composition with the \texttt{||}
operator. Line~\ref{line:gen-bind-t} adds the binding transition $t$
and the TCI identifier $id_t$ to the $\gamma$ binder.

\begin{algorithm}[H]
  \DontPrintSemicolon

  \SetAlFnt{\fontsize{11}{13}\selectfont}
  
  \SetAlCapFnt{\fontsize{11}{13}\selectfont}
  \SetAlCapNameFnt{\fontsize{11}{13}\selectfont}
  % \NoCaptionOfAlgo

  \caption{\texttt{generate\_TCIs}($sitpn$, $d$, $\gamma$)}
  \label{alg:gentcis}
  
  \AlFnt % overriding the new font

  \ForEach{$t\in{}T$}{

    \lIf{$\mathtt{input}(t)=\emptyset$ and $\mathtt{output}(t)=\emptyset$}{
      \texttt{err}$("t~is~an~isolated~transition")$\label{line:t-isolated}
    }

    \BlankLine
    $g_t\leftarrow\{(\mathtt{tt},\mathtt{get\_ttype}(t)),(\mathtt{mtc},\mathtt{get\_mtc}(t))\}$\;
    $i_t\leftarrow\{(\mathtt{A},
    \begin{cases}
      0~\mathtt{if}~t\notin{}\mathtt{dom}(I_s) \\
      lower(I_s(t))~otherwise\\
    \end{cases}), (\mathtt{B},
    \begin{cases}
      0~\mathtt{if}~t\notin{}\mathtt{dom}(I_s)\lor{}upper(I_s(t))=\infty \\
      upper(I_s(t))~otherwise\\
    \end{cases})\}$\;

    $id_s\leftarrow{}\mathtt{genid()}$\;\label{line:genid-fired}
    $d.sigs\leftarrow{}d.sigs\cup(id_s,boolean)$\;\label{line:declid-fired}
    $o_t\leftarrow{}\{(\mathtt{fired},id_s)\}$\;\label{line:connect-fired}
    
    \BlankLine
    \uIf{$\mathtt{input}(t)=\emptyset$}{
      $g_t\leftarrow{}g_t\cup\{(\mathtt{ian},1)\}$\;
      $i_t\leftarrow{}i_t\cup\{(\mathtt{iav}(0),\mathtt{true}),(\mathtt{pauths}(0),\mathtt{true}),(\mathtt{rt}(0),id_s)\}$\;
    }
    \Else{
      $g_t\leftarrow{}g_t\cup\{(\mathtt{ian},\vert{}\mathtt{input}(t)\vert)\}$\;
    }
    
    \BlankLine
    \uIf{$\mathtt{conds}(t)=\emptyset$}{
      $g_t\leftarrow{}g_t\cup\{(\mathtt{cn},1)\}$\; \label{line:conds-empty}
      $i_t\leftarrow{}i_t\cup\{(\mathtt{ic}(0),\mathtt{true})\}$\;
    } 
    \Else{
      $g_t\leftarrow{}g_t\cup\{(\mathtt{cn},\vert{}\mathtt{conds}(t)\vert)\}$\;
    }
    
    \BlankLine
    $id_t\leftarrow{}\mathtt{genid}()$\;\label{line:gen-tcomp-id}
    $d.cs\leftarrow{}d.cs~\mathtt{||}~\mathtt{comp}(\mathtt{id}_t,\mathtt{transition},g_t,i_t,o_t)$\;\label{line:gen-tcomp}
    $\gamma\leftarrow\gamma\cup(t,\mathtt{id}_t)$\;\label{line:gen-bind-t}
  }
\end{algorithm}

\subsection{Interconnection of the component instances}
\label{sec:geninter}

After the generation of PCIs and TCIs, and of all constant
associations in their generic and input port maps, the next step of
the transformation performs the interconnections between the
interfaces of PCIs and TCIs. The \texttt{generate\_interconnections}
procedure, presented in Algorithm~\ref{alg:geninter}, iterates over
the set of places of the $sitpn$ parameter. For each place $p$, the
\texttt{connect\_input\_trs} (resp. \texttt{connect\_output\_trs})
procedure generates the interconnection between the PCI $id_p$ and the
TCIs that implement the input (resp. output) transitions of $p$.

\begin{algorithm}[H]
  \DontPrintSemicolon

  \SetAlFnt{\fontsize{11}{13}\selectfont}
  
  \SetAlCapFnt{\fontsize{11}{13}\selectfont}
  \SetAlCapNameFnt{\fontsize{11}{13}\selectfont}
  % \NoCaptionOfAlgo

  \caption{\texttt{generate\_interconnections}($sitpn$, $d$, $\gamma$)}
  \label{alg:geninter}
  
  \AlFnt % overriding the new font

  \ForEach{$p\in{}P$}{
    \texttt{connect\_input\_trs}$(p,sitpn,d,\gamma)$\;
    \texttt{connect\_output\_trs}$(p,sitpn,d,\gamma)$\;
  }
\end{algorithm}

Algorithm~\ref{alg:connect-in-trs} presents the
\texttt{connect\_input\_trs} procedure.  At
Line~\ref{line:getpcomp-cit}, the \texttt{get\_comp} returns the PCI
associated with the identifier $\gamma(p)$ (i.e. the PCI identifier
associated with place $p$ in $\gamma$) by looking up the behavior of
the design $d$. Then, the procedure modifies the input port map of PCI
$id_p$, and finally replaces the old PCI by the modified one in the
behavior of design $d$ (Line~\ref{line:putpcomp-cit}). Between Lines,
the procedure connects the \texttt{input\_transitions\_fired} input
port of PCI $id_p$ to the \texttt{fired} output port of the TCIs
implementing the input transitions of place $p$. At Line, for each
input transition $t$ of place $p$, the \texttt{get\_comp} function
returns the TCI $id_t$ looked up in the behavior of design $d$. Then,
Line~\ref{line:connect-itf-fired} modifies the input port map of PCI
$id_p$. It connects a subelement of the
\texttt{input\_transitions\_fired} input port to the actual part
associated with the \texttt{fired} output port in the output port map
of TCI $id_t$ (i.e. \texttt{actual}$(\mathtt{fired},o_t)$).
Line~\ref{line:input-empty-itf} deals with the particular case where
the set of input transitions of place $p$ is empty.

\begin{algorithm}[H]
  \DontPrintSemicolon

  \SetAlFnt{\fontsize{11}{13}\selectfont}
  
  \SetAlCapFnt{\fontsize{11}{13}\selectfont}
  \SetAlCapNameFnt{\fontsize{11}{13}\selectfont}
  % \NoCaptionOfAlgo

  \caption{\texttt{connect\_input\_trs}($p$, $sitpn$, $d$, $\gamma$)}
  \label{alg:connect-in-trs}
  
  \AlFnt % overriding the new font

  \texttt{comp}$(id_p,\mathtt{place},g_p,i_p,o_p)\leftarrow\mathtt{get\_comp}(\gamma(p),d.cs)$\;\label{line:getpcomp-cit}
  
  \BlankLine
  $i\leftarrow{}0$\;
  \ForEach{$t\in\mathtt{input}(p)$}{\label{line:foreach-input-cit}
    \texttt{comp}$(id_t,\mathtt{transition},g_t,i_t,o_t)\leftarrow\mathtt{get\_comp}(\gamma(t),d.cs)$\;
    $i_p\leftarrow\{(\mathtt{itf}(i),\mathtt{actual}(\mathtt{fired},o_t))\}$\;\label{line:connect-itf-fired}
    $i\leftarrow{}i+1$\;
  }

  \BlankLine
  \texttt{put\_comp}$(id_p, \mathtt{comp}(id_p,\mathtt{place},g_p,i_p,o_p), d.cs)$\;\label{line:putpcomp-cit}  
\end{algorithm}

\begin{remark}[Connections consistency]
  In the behavior of the \texttt{place} design, some processes access
  to the subelements of composite ports through the use of
  indices. For instance, the \texttt{input\_tokens\_sum} process (see
  Appendix~\ref{app:place-design}) increments a local variable $i$ in
  range $0$ to $\mathtt{input\_arcs\_number}-1$ in a for loop. The
  process tests the value of the \texttt{input\_transitions\_fired}
  port's subelement with index $i$. If the test suceeds, the process
  adds the value of the \texttt{input\_arcs\_weights} port's
  subelement with index $i$ to the local variable
  \texttt{v\_internal\_input\_token\_sum}. Thus, the subelement with
  index $i$ of the \texttt{input\_transitions\_fired} and
  \texttt{input\_arcs\_weights} ports must refer to the connection to
  the same transition. Otherwise, the process does not compute a
  correct input tokens sum. Figure~\ref{fig:consistent-connections}
  illustrates the correct connection of the
  \texttt{input\_transitions\_fired} and \texttt{input\_arcs\_weights}
  ports in the input port map of PCI $id_p$ w.r.t. to the connection
  between transitions $t_a$, $t_b$, $t_c$ and place $p$. 

  \begin{figure}[H]
    \centering
    \includegraphics[keepaspectratio,width=.8\textwidth]{Figures/Transformation/consistent-indexes}
    \caption[An example of correct connections between several TCIs
    and a PCI.]{An example of correct connections between the PCI
      $id_p$ and TCIs $id_{t_a}$, $id_{t_b}$ and $id_{t_c}$. On the
      left, the input SITPN model showing the connections of the
      transitions $t_a$, $t_b$ and $t_c$ to the place $p$. The dots
      indicate that the place $p$ possibly has other input
      transitions. On the right, the TCIs and the PCI generated by the
      transformation. In the input port map of PCI $id_p$, the
      subelements of the \texttt{itf} input port are connected to the
      \texttt{fired} port of TCIs; the subelements of the \texttt{iaw}
      port are connected to constant values, i.e. the weight of the
      arcs between place $p$ and the input transitions of $p$.}
    \label{fig:consistent-connections}
  \end{figure}

  It is the r√¥le of the transformation function to ensure the
  consistency of the connections of the subelements in the input and
  output port maps of PCIs. The input and output port maps of TCIs are
  not subject to such a constraint. The fact that a \textbf{foreach}
  loop always iterates in the same order over the elements of a set
  ensures the consistency of the connections.

\end{remark}

Algorithm~\ref{alg:connect-out-trs} presents the
\texttt{connect\_output\_trs} procedure. The procedure interconnects
the input and output port maps of PCI $id_p$ to the input and output
port maps of the TCIs implementing the output transitions of place
$p$. From Lines~\ref{line:foreach-outc} to
\ref{line:end-foreach-outc}, the procedure connects the TCIs bound to
the conflicting output transitions of $p$. From
Lines~\ref{line:foreach-outnc} to \ref{line:end-foreach-outnc}, the
procedure connects the TCIs bound to the output transitions of $p$
that are not in conflict. The difference between the two loops lies in
the connection the \texttt{priority\_authorizations} ports. Between
the PCI $id_p$ and its \textit{conflicting} TCIs, the
\texttt{priority\_authorizations} ports must be connected. Between the
PCI $id_p$ and its \textit{non-conflicting} TCIs, the
\texttt{priority\_authorizations} are not connected together. This
reflects the fact that output transitions that are not in conflict are
not concerned with the sensitization by the residual marking (see
Section~\ref{sec:fired-trans} for explanations about the residual
marking). The information of the sensitization by the residual marking
passes by the \texttt{priority\_authorizations} ports. At the
exception of the \texttt{priority\_authorizations} ports, the two
loops perform the same interconnections. Lines~\ref{line:otf-fired-1}
and \ref{line:otf-fired-2} connect a subelement of the
\texttt{output\_transitions\_fired} input port to the actual part
associated with the \texttt{fired} output port in the output port map
of TCI $id_t$
(i.e. \texttt{actual}$(\mathtt{fired},o_t)$). Lines~\ref{line:oav-iav-1}
and \ref{line:oav-iav-2} connect a subelement of the
\texttt{output_arcs_valid} output port to a subelement of the
\texttt{input_arcs_valid} input port. The connection passes through an
internal signal that is generated by the \texttt{connect} procedure
(presented in Algorithm~\ref{alg:connect}), and added to the internal
signal declaration list of design $d$.  The \texttt{output_arcs_valid}
port is an output port of the \texttt{place} design, and the
\texttt{input_arcs_valid} port is an input port of the
\texttt{transition} design. Lines~\ref{line:rtt-rt-1} and
\ref{line:rtt-rt-2} connect a subelement of the
\texttt{reinit\_transitions\_time} output port to a subelement of the
\texttt{reinit_time} input port through an internal signal. The
\texttt{reinit\_transitions\_time} port is an output port of the
\texttt{place} design, and the \texttt{reinit_time} port is an input
port of the \texttt{transition} design.
 
From Lines~\ref{line:out-empty-cot} to \ref{line:end-out-empty-cot},
the procedure deals with the case where the set of input transitions
of $p$ is empty. In that case, the subelement of the
\texttt{output\_transitions\_fired} port with index $0$ is connected
to \texttt{false} in the input port map $i_p$; also, the
\texttt{output\_arcs\_valid}, \texttt{priority\_authorizations} and
\texttt{reinit\_transitions\_time} ports are left unconnected in the
output port map $o_p$.

\begin{algorithm}[H]
  \DontPrintSemicolon

  \SetAlFnt{\fontsize{11}{13}\selectfont}
  
  \SetAlCapFnt{\fontsize{11}{13}\selectfont}
  \SetAlCapNameFnt{\fontsize{11}{13}\selectfont}
  % \NoCaptionOfAlgo

  \caption{\texttt{connect\_output\_trs}($p$, $sitpn$, $d$, $\gamma$)}
  \label{alg:connect-out-trs}
  
  \AlFnt % overriding the new font

  \texttt{comp}$(id_p,\mathtt{place},g_p,i_p,o_p)\leftarrow\mathtt{get\_comp}(\gamma(p),d.cs)$\;
  
  \BlankLine
  $i\leftarrow{}0$\;
  \ForEach{$t\in\mathtt{output}_c(p)$}{\label{line:foreach-outc}
    \texttt{comp}$(id_t,\mathtt{transition},g_t,i_t,o_t)\leftarrow\mathtt{get\_comp}(\gamma(t),d.cs)$\;
    $i_p\leftarrow{}i_p\cup\{(\mathtt{otf}(i),\mathtt{actual}(\mathtt{fired},o_t))\}$\; \label{line:otf-fired-1}
    \texttt{connect}$(o_p,i_t,\mathtt{oav}(i),\mathtt{iav},d)$\; \label{line:oav-iav-1}
    \texttt{connect}$(o_p,i_t,\mathtt{rtt}(i),\mathtt{rt},d)$\; \label{line:rtt-rt-1}
    \texttt{connect}$(o_p,i_t,\mathtt{pauths}(i),\mathtt{pauths},d)$\;
    \texttt{put\_comp}$(id_t, \mathtt{comp}(id_t,\mathtt{transition},g_t,i_t,o_t), d.cs)$\;\label{line:end-foreach-outc}
    $i\leftarrow{}i+1$\;
  }
  \ForEach{$t\in\mathtt{output}_{nc}(p)$}{
    \texttt{comp}$(id_t,\mathtt{transition},g_t,i_t,o_t)\leftarrow\mathtt{get\_comp}(\gamma(t),d.cs)$\;\label{line:foreach-outnc}
    $i_p\leftarrow{}i_p\cup\{(\mathtt{otf}(j),\mathtt{actual}(\mathtt{fired},o_t))\}$\; \label{line:otf-fired-2}
    \texttt{connect}$(o_p,i_t,\mathtt{oav}(i),\mathtt{iav},d)$\; \label{line:oav-iav-2}
    \texttt{connect}$(o_p,i_t,\mathtt{rtt}(i),\mathtt{rt},d)$\; \label{line:rtt-rt-2}

    $id_s\leftarrow\mathtt{genid}()$\;
    $d.sigs\leftarrow{}d.sigs\cup(id_s,\mathtt{boolean})$\;
    $o_p\leftarrow{}o_p\cup\{(\mathtt{pauths}(i),id_s)\}$\;
    \texttt{cassoc}$(i_t,\mathtt{pauths},\mathtt{true})$\;
    
    \texttt{put\_comp}$(id_t, \mathtt{comp}(id_t,\mathtt{transition},g_t,i_t,o_t), d.cs)$\;\label{line:end-foreach-outnc}
    $i\leftarrow{}i+1$\;
  }

  
  \BlankLine
  \texttt{put\_comp}$(id_p, \mathtt{comp}(id_p,\mathtt{place},g_p,i_p,o_p), d.cs)$\;
  
\end{algorithm}



\subsection{Generation of ports, the \texttt{action} and the
  \texttt{function} process}
\label{sec:genports}

\begin{algorithm}[H]
  \DontPrintSemicolon

  \SetAlFnt{\fontsize{11}{13}\selectfont}
  
  \SetAlCapFnt{\fontsize{11}{13}\selectfont}
  \SetAlCapNameFnt{\fontsize{11}{13}\selectfont}
  % \NoCaptionOfAlgo

  \caption{\texttt{generate\_conds}($sitpn$, $d$, $\gamma$)}
  \label{alg:genconds}
  
  \AlFnt % overriding the new font
\end{algorithm}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../main"
%%% End:
