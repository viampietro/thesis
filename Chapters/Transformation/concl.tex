The purpose of this chapter was to give to the reader a complete
understanding of the \hilecop{} model-to-text transformation function,
and of what makes it a very specific transformation case. We first
gave an informal presentation of the transformation function with a
high-level view of the transformation principles. Then, we presented
our literature review pertaining to transformation functions in the
context of formal verification, with a particular focus on the
expression and the implementation of transformation functions. Two
points, drawn out from the literature review, are of particular
interest. First, the review showed that it is important, during a
transformation, to keep the binding between the elements of the source
representation and their corresponding versions in the target
representation. This binding is the base of the comparison of the
run-time state of the source and target representation that permits to
express the theorem of semantic preservation. Second, if the distance
between the source and the target representation is too important, it
is easier, while aiming at proving a semantic preservation property,
to split the transformation into multiple simple transformation steps.
Then, to each transformation step will correspond an intermediary
representation, and a theorem of semantic preservation will be laid
out and proved for each one of them. In the case of the \hilecop{}
model-to-text transformation, even though the transformation has a lot
of tricky aspects pertaining to particular cases of input models,
there is no need to split the transformation into simple steps with
intermediary representations. Even though the verification task is
quite close, the \hilecop{} transformation is quite different from the
certified GPL or the HDL compilers presented in the literature
review. Indeed, the source representation is an input model not a
programming language. Moreover, due to the interconnection of the
component instances generated by the transformation function, devising
a transformation algorithm that generates modular and independently
executable code is impossible. As everything is connected, one has to
reason over the entire transformation process to get the overall
behavior of the generated \hvhdl{} design. This is also one of the
main difference between the \hilecop{} transformation and compilers
for programming languages. Despite all that, the transformation
algorithm, presented in this chapter, gets as close as possible to a
modular expression of the \hilecop{} transformation. % Our
% implementation of the transformation algorithm uses an intermediate
% format to represent the component instantiation statements. Even
% though this intermediate representation is convenient to handle datas
% during the transformation, it requires an extra transformation step to
% generate the behavior of the resulting \hvhdl{} design. Thus, this
% intermediate format complexifies the transformation function. In the
% future, we will implement the transformation function closer to the
% expression of the transformation algorithm. This will help reasoning
% over the \texttt{sitpn\_to\_hvhdl} function during the mechanization
% of the proof of semantic preservation.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../main"
%%% End:
