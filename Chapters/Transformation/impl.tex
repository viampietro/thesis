This section presents the implementation of the \hilecop{}
model-to-text transformation with the \coq{} proof assistant.  The
full implementation is available under the \texttt{sitpn2hvhdl} folder
of the following Git repository:
\url{https://github.com/viampietro/ver-hilecop}

Listing~\ref{lst:sitpn2hvhdl} gives the \coq{} implementation of the
\texttt{sitpn\_to\_hvhdl} function presented in an imperative
pseudo-code version in Algorithm~\ref{alg:sitpn2hvhdl}.

\begin{lstlisting}[language=coq,label={lst:sitpn2hvhdl},
caption={[The \coq{} implementation of the \texttt{sitpn\_to\_hvhdl} function.] The \coq{} implementation of the \texttt{sitpn\_to\_hvhdl} function presented in Algorithm~\ref{alg:sitpn2hvhdl}.},framexleftmargin=1.5em,xleftmargin=2em,numbers=left,
numberstyle=\tiny\ttfamily]
Definition sitpn_to_hvhdl (sitpn : Sitpn)
   (decpr : forall x y : T sitpn, {pr x y} + {~pr x y})
   ($id_e$ $id_a$ : ident) (b : P sitpn -> nat) :
   (design * Sitpn2HVhdlMap sitpn) + string :=
  RedV 
    ((do _ <- generate_sitpn_infos sitpn decpr;
      do _ <- generate_architecture sitpn b;
      do _ <- generate_ports sitpn;
      do _ <- generate_comp_insts sitpn;
      generate_design_and_binder $id_e$ $id_a$)
      (InitS2HState sitpn Petri.ffid)).
\end{lstlisting}

In Listing~\ref{lst:sitpn2hvhdl}, the \texttt{sitpn\_to\_hvhdl}
function has five parameters: \texttt{sitpn}, the input SITPN model;
\texttt{decpr}, a proof that the \texttt{pr} relation (i.e. the
implementation of the firing priority relation) is decidable over the
set of transitions of \texttt{sitpn} (i.e. \texttt{T sitpn}); $id_e$
and $id_a$, the entity and architecture identifiers for the generated
\hvhdl{} design; the \texttt{b} function that maps the places of the
\texttt{sitpn} parameter to a maximal marking value, i.e. a natural
number. The \texttt{sitpn\_to\_hvhdl} function returns a couple
composed of the generated \hvhdl{} design, of type \texttt{design},
and the generated $\gamma$ binder, of type \texttt{Sitpn2HVhdlMap
  sitpn}; or, the \texttt{sitpn\_to\_hvhdl} function returns a
\texttt{string} corresponding to an error message.

In the body of the \texttt{sitpn\_to\_hvhdl} function, the
\texttt{RedV} is a notation that reduces a monadic function call to a
value. Our implementation of the \hilecop{} transformation function
relies on the state-and-error monad \cite{Wadler1992}. Each function
that implements a part of the transformation function takes a
\emph{compile-time} state as a parameter, and returns either a value
and a new compile-time state, or an error message. The \texttt{bind}
construct of the state-and-error monad permits to pipeline multiple
function calls, and, combined with the \texttt{do} notation, it
permits us to write functional programs in the style of imperative
languages. The sequence defined in the body of the
\texttt{sitpn\_to\_hvhdl} function gives an example of what can be
achieved with the combination of the state-and-error monad and the
\texttt{do} notation. This sequence constitutes a single monadic
function that takes a state of the \texttt{Sitpn2HVhdlState} type (see
Listing~\ref{lst:comp-time-state}) as input, and yields a value with a
new state, or an error message. Here, the \texttt{RedV} notation
retrieves only the value returned by the application of the monadic
function to the parameter \texttt{(InitS2HState sitpn Petri.ffid)}
(i.e. the initial compile-time state), or it retrieves the error
message.

In the \texttt{do} sequence of Listing~\ref{lst:sitpn2hvhdl}, the four
first function calls do not return values that are relevant; thus, we
use the underscore notation to notify that we are not interested in
the returned values.  Indeed, the \texttt{generate\_sitpn\_infos},
\texttt{generate\_architecture}, \texttt{generate\_ports} and
\texttt{generate\_comp\_insts} functions directly modify the
compile-time state without returning a value. They are the functional
implementation of the procedures described in the previous section.
 
Now, let us present the content of the compile-time state. As said
above, the compile-time state is carried from function to function and
modified all along the transformation.
Listing~\ref{lst:comp-time-state} gives the implementation of the
compile-time state structure.

\begin{lstlisting}[language=coq,label={lst:comp-time-state},
caption={[The compile-time state structure.] The compile-time state structure defined as the \coq{} \texttt{Sitpn2HVhdlState} record type.},framexleftmargin=1.5em,xleftmargin=2em,numbers=left,
numberstyle=\tiny\ttfamily]
Record Sitpn2HVhdlState (sitpn : Sitpn) : Type :=
  MkS2HState {
     lofPs : list (P sitpn); #\label{line:lofPs}#
     lofTs : list (T sitpn);
     lofCs : list (C sitpn);
     lofAs : list (A sitpn);
     lofFs : list (F sitpn); #\label{line:lofFs}#
     nextid : ident; #\label{line:nextid}#
     sitpninfos : SitpnInfos sitpn; #\label{line:sitpninfos}#
     iports : list pdecl; #\label{line:iports}#
     oports : list pdecl; #\label{line:oports}#
     arch : Architecture sitpn; #\label{line:arch}#
     beh : cs; #\label{line:beh}#
     $\gamma$ : Sitpn2HVhdlMap sitpn; #\label{line:gamma}#

  }.
\end{lstlisting}

The compile-time state structure is implemented by the
\texttt{Sitpn2HVhdlState} record type. This type depends on a given
\texttt{sitpn} passed as a parameter. It is composed of eleven
fields. The first five fields (Line~\ref{line:lofPs} to
\ref{line:lofFs}) are the list versions of the finite sets of places,
transitions, conditions, actions and functions of the \texttt{sitpn}
parameter. These fields are filled at the very beginning of the
transformation by the \texttt{generate\_sitpn\_infos} function, and
are convenient to write functions in the context of dependent
types. The \texttt{nextid} field (Line~\ref{line:nextid}) permits us to
generate fresh and unique identifiers all along the
transformation. The \texttt{sitpinfos} field
(Line~\ref{line:sitpninfos}) is an instance of the \texttt{SitpnInfos}
type that depends on the \texttt{sitpn} parameter. The
\texttt{sitpninfos} field is filled up by the
\texttt{generate\_sitpn\_infos} function. It is a convenient way to
represent the information associated with the places, transitions,
conditions, actions and functions of the \texttt{sitpn} parameter. The
\texttt{iports} (resp. \texttt{oports}) field, at
Line~\ref{line:iports} (resp. at Line~\ref{line:oports}), gathers the
list of input (resp. output) port declarations of the generated
\hvhdl{} design. The \texttt{arch} field (Line~\ref{line:arch}) is an
intermediary representation of the behavior of the generated \hvhdl{}
design. This representation is easier to modify and to handle than a
\hvhdl{} concurrent statement. The \texttt{beh} field
(Line~\ref{line:beh}) is the behavior of the generated \hvhdl{}
design; it is an instance of the \texttt{cs} type, i.e. the type of
concurrent statements defined in the abstract syntax of \hvhdl{}. The
$\gamma$ field (Line~\ref{line:gamma}) is the SITPN-to-\hvhdl{} binder
generated alongside the \hvhdl{} design, and returned at the end of
the transformation.

At the beginning of the transformation, an initial compile-time state
is built with the \texttt{Init\-S2HState} function. The
\texttt{InitS2HState} function gives an initial value to the fields of
the state structure; mostly, the fields are initialized with empty
lists, and the \texttt{beh} field is initialized with the
\texttt{null} statement. The \texttt{InitS2HState} function takes an
\texttt{Sitpn} instance and an identifier as inputs. The identifier
parameter represents the initial value of the \texttt{nextid}
field. In Listing~\ref{lst:sitpn2hvhdl}, the second parameter of the
\texttt{InitS2HState} function is \texttt{Petri.ffid}. It corresponds
to the \emph{first fresh} identifier that the transformation can use
to produce a \hvhdl{} design that respects the uniqueness of
identifiers.

Let us now present the functions composing the \texttt{do} sequence of
the \texttt{sitpn\_to\_hvhdl} function, and how they modify the
compile-time state to produce the final \hvhdl{} design and the
$\gamma$ binder.

\subsection{The \texttt{generate\_sitpn\_infos} function}
\label{sec:gen-sitpn-infos}

Listing~\ref{lst:gen-infos} presents a part of the
\texttt{generate\_sitpn\_infos}. The part that is let aside,
represented by little dots, pertains to the creation of the
dependently-typed lists constituting the first fields of the
compile-time state structure (Line~\ref{line:lofPs} to
\ref{line:lofFs} in Listing~\ref{lst:comp-time-state}).

\begin{lstlisting}[language=coq,label={lst:gen-infos},
caption={[The \texttt{generate\_sitpn\_infos} function.] A part of the \texttt{generate\_sitpn\_infos} function.},framexleftmargin=1.5em,xleftmargin=2em,numbers=left,
numberstyle=\tiny\ttfamily]
Definition generate_sitpn_infos
           (sitpn : Sitpn)
           (decpr : forall x y : T sitpn, {pr x y} + {~pr x y}) :
    Mon (Sitpn2HVhdlState sitpn) unit :=
  #\dots#
  do _ <- check_wd_sitpn sitpn decpr;
  do _ <- generate_trans_infos sitpn;
  do _ <- generate_place_infos sitpn decpr;
  do _ <- generate_cond_infos sitpn; 
  do _ <- generate_action_infos sitpn;
  generate_fun_infos sitpn.
\end{lstlisting}

The \texttt{generate\_sitpn\_infos} function takes an \texttt{Sitpn}
instance and a proof of decidability for the \texttt{pr} relation as
parameters. It returns a value of type \texttt{Mon (Sitpn2HVhdlState
  sitpn) unit}. A value of this type can either be a couple
$(state,value)$, where $state$ is of type \texttt{(Sitpn2HVhdlState
  sitpn)} and $value$ is of type \texttt{unit}, or an error
message. The \texttt{unit} type as only one possible value
\texttt{tt}. The \texttt{unit} type is used here to represent a
function that modifies the compile-time state without returning a
value.

The aim of the \texttt{generate\_sitpn\_infos} function is to fill the
\texttt{sitpninfos} field of the compile-time state; the
\texttt{sitpninfos} field is an instance of the \texttt{SitpnInfos}
record type. Listing~\ref{lst:infos-types} presents the definition of
the \texttt{SitpnInfos} record type, along with the definition of the
\texttt{PlaceInfo} and \texttt{TransInfo} record types.

\begin{lstlisting}[language=coq,label={lst:infos-types},
caption={[The \texttt{PlaceInfo}, \texttt{TransInfo} and \texttt{SitpnInfos} types.]The \texttt{PlaceInfo}, \texttt{TransInfo} and \texttt{SitpnInfos} record types.},framexleftmargin=1.5em,xleftmargin=2em,numbers=left,
numberstyle=\tiny\ttfamily]
Record PlaceInfo (sitpn : Sitpn) : Type :=
  MkPlaceInfo { tinputs : list (T sitpn);
                tconflict : list (T sitpn);
                toutputs : list (T sitpn) }.

Record TransInfo (sitpn : Sitpn) : Type :=
  MkTransInfo { pinputs : list (P sitpn); conds : list (C sitpn) }.
  
Record SitpnInfos (sitpn : Sitpn) : Type :=
  MkSitpnInfos {
      pinfos : list (P sitpn * PlaceInfo);
      tinfos : list (T sitpn * TransInfo);
      cinfos : list (C sitpn * list (T sitpn));
      ainfos : list (A sitpn * list (P sitpn));
      finfos : list (F sitpn * list (T sitpn));
    }.
\end{lstlisting}

The \texttt{PlaceInfo} record type is composed of three lists that
represent the input transitions, \texttt{tinputs}, the conflicting
output transitions, \texttt{tconflict}, and the non-conflicting output
transitions, \texttt{toutputs}, of a place. In the \texttt{SitpnInfos}
structure, the \texttt{pinfos} field maps the places of the
\texttt{sitpn} parameter to their respective information, i.e. an
instance of the \texttt{PlaceInfo} type. This mapping is built by the
\texttt{generate\_place\_infos} function called in the body of
\texttt{generate\_sitpn\_infos} function. While building an instance
of the \texttt{PlaceInfo} type for a given place $p$, the
\texttt{generate_place_infos} function computes the list of output
transitions of $p$ that are in conflict (in the manner of the
\texttt{output}$_c$ function described in
Section~\ref{sec:prim-funs}). First, it computes the list of output
transitions that are linked to the place $p$ through a \texttt{basic}
arc; then, the function checks if all conflicts between the
transitions of this list are solved by means of mutual exclusion. If
it is the case, the \texttt{tconflict} field is left empty, and all
transitions of the list join the \texttt{toutputs} list. Otherwise,
the function tries to establish a strict total order over the
transitions of the list, by decreasing level of priority.  If no such
order can be established, the function raises an error; otherwise, the
\texttt{tconflict} field is filled with the ordered list. This process
never fails if the input \texttt{sitpn} parameter is indeed
well-defined (cf. Definition~\ref{def:wd-sitpn}).

The \texttt{TransInfo} record type is composed of two lists that
represent the input places, \texttt{pinputs}, and the output places,
\texttt{poutputs}, of a transition. In the \texttt{SitpnInfos}
structure, the \texttt{tinfos} field maps the transitions of the
\texttt{sitpn} parameter to their respective information, i.e. an
instance of the \texttt{TransInfo} type. This mapping is built by the
\texttt{generate\_trans\_infos} function called in the body of
\texttt{generate\_sitpn\_infos} function.

In the \texttt{SitpnInfos} structure, the \texttt{cinfos}
(resp. \texttt{ainfos} and \texttt{finfos}) field maps the conditions
(resp. actions and functions) of the \texttt{sitpn} parameter to the
list of transitions (resp. places and transitions) they are attached
to. This mapping is built by the \texttt{generate\_cond\_infos}
(resp. \texttt{generate\_action\_infos} and
\texttt{generate\_fun\_infos}) function called in the body of
\texttt{generate\_sitpn\_infos} function.

At the beginning of the \texttt{generate\_sitpn\_infos} function, the
\texttt{check\_wd\_sitpn} function partly checks the well-definition
of the \texttt{sitpn} parameter. Precisely, it checks that the set of
places and transitions of the \texttt{sitpn} parameter are not empty,
and that the priority relation is a strict order, i.e. transitive and
reflexive, over the set of transitions. The other parts of the
well-definition checking are performed later during the
transformation. For instance, the \texttt{generate\_place\_infos}
function checks that, for each group of transitions in conflict, the
conflicts are either solved by means of mutual exclusion or that the
priority relation is a strict total order over this group. It also
checks that there are no isolated places in the input \texttt{sitpn}
parameter, etc.

\subsection{The \texttt{generate\_architecture} function}
\label{sec:impl-gen-arch}

Listing~\ref{lst:gen-arch} presents the
\texttt{generate\_architecture} function. The
\texttt{generate\_architecture} function implements the
\texttt{generate\_architecture} and the
\texttt{generate\_interconnections} procedures detailed in
Algorithms~\ref{alg:genarch} and \ref{alg:geninter}.  The composition
of the \texttt{generate\_place\_map} and the
\texttt{generate\_trans\_map} functions implements
\texttt{generate\_architecture} procedure of
Algorithm~\ref{alg:genarch}. Precisely, the
\texttt{generate\_place\_map} function implements the
\texttt{generate\_PCIs} procedure presented in
Algorithm~\ref{alg:genpcis}, and the \texttt{generate\_trans\_map}
function implements the \texttt{generate\_TCIs} procedure presented in
Algorithm~\ref{alg:gentcis}.

\begin{lstlisting}[language=coq,label={lst:gen-arch},
caption={[The \texttt{generate\_architecture} function.]The \texttt{generate\_architecture} function that implements the \texttt{generate\_architecture} procedure of Algorithm~\ref{alg:genarch}.},framexleftmargin=1.5em,xleftmargin=2em,numbers=left,
numberstyle=\tiny\ttfamily]
Definition generate_architecture (sitpn : Sitpn) (b : P sitpn -> nat) :
  Mon (Sitpn2HVhdlState sitpn) unit :=
  do _ <- generate_place_map sitpn b;
  do _ <- generate_trans_map sitpn;
  generate_interconnections.
\end{lstlisting}

The \texttt{generate\_architecture} function takes an \texttt{Sitpn}
instance and the \texttt{b} function as inputs, and modifies the
compile-time state. The \texttt{generate\_architecture} function fills
the \texttt{arch} field of the compile-time state; the \texttt{arch}
field is an instance of the \texttt{Architecture} record
type. Listing~\ref{lst:infos-types} presents the definition of the
\texttt{Architecture} record type, along with the definition of the
\texttt{InputMap}, \texttt{OutputMap} and \texttt{HComponent} type
aliases.

\begin{lstlisting}[language=coq,label={lst:arch-types}, caption={[The
\texttt{Architecture} record type.]The \texttt{Architecture} record
type, and the \texttt{InputMap}, \texttt{OutputMap} and
\texttt{HComponent} subsidiary
types. },framexleftmargin=1.5em,xleftmargin=2em,numbers=left,
numberstyle=\tiny\ttfamily]
Definition InputMap := list (ident * (expr + list expr)).
Definition OutputMap := list (ident * ((option name) + list name)).
Definition HComponent := (genmap * InputMap * OutputMap).

Record Architecture (sitpn : Sitpn) := MkArch {
  sigs  : list sdecl;
  plmap : list (P sitpn * HComponent);
  trmap : list (T sitpn * HComponent);
  fmap  : list (F sitpn * list expr);
  amap  : list (A sitpn * list expr) }.
\end{lstlisting}

The \texttt{HComponent} type is an intermediate representation of an
\hvhdl{} component instantiation statement. This type has been devised
to ease the construction of PCIs and TCIs, and of their generic, input
port and output port maps all along the transformation.  The
\texttt{HComponent} type is a triplet composed of a generic map as
defined in the \hvhdl{} abstract syntax, an instance of the
\texttt{InputMap} type, and an instance of the \texttt{OutputMap}
type.  The \texttt{InputMap} type maps an input port identifier to
either a simple expression or to a list of expressions, where the
\texttt{expr} type is the type of expressions defined in the \hvhdl{}
abstract syntax. In an \texttt{InputMap} instance, an input port
identifier of a scalar type (i.e. Boolean or constrained natural) is
mapped to a simple expression, whereas an input port identifier of the
array type is mapped to a list of expressions. Each expression of the
list represents the actual part associated with one subelement of the
input port. Similarly to the \texttt{InputMap} type, the
\texttt{OutputMap} type maps an output port identifier to either an
option to a signal (the \texttt{None} value representing the
connection to the \texttt{open} keyword) name, or to a list of signal
names. In the definition of the \texttt{OutputMap} type, the
\texttt{name} type represents the type of simple identifiers or
indexed identifiers defined in the \hvhdl{} abstract syntax.

The \texttt{Architecture} record type is an intermediary
representation of the behavioral and declarative part of an \hvhdl{}
design's architecture.  The \texttt{sigs} field of the
\texttt{Architecture} type represents the internal signal declaration
list constituting the declarative part of an \hvhdl{} design's
architecture. The transformation adds a new signal declaration entry
to the \texttt{sigs} field every time an internal signal must be
generated, for example, during the generation of interconnections
between PCIs and TCIs.  The \texttt{plmap} (resp. the \texttt{trmap})
field maps the places (resp. transitions) of the \texttt{sitpn}
parameter to their corresponding PCI (resp. TCI) implemented in an
intermediate format, i.e. an instance of the \texttt{HComponent}
type. The \texttt{fmap} field of the \texttt{Architecture} type maps
the functions of the \texttt{sitpn} parameter to a list of
expressions. For a given function $f$, the associated list of
expressions corresponds to the list of internal signals associated
with the \texttt{fired} port of the TCIs implementing the transitions
of the \texttt{trs}$(f)$ set (i.e. the set of transitions associated
with function $f$). The \texttt{fmap} field is filled by the
\texttt{generate\_ports} function described in
Listing~\ref{lst:impl-gen-ports}. The \texttt{amap} field is the twin
of the \texttt{fmap} field but on the side of the actions of the
\texttt{sitpn} parameter. Thus, in the \texttt{amap} field, the list
of expressions associated with an action $a$ corresponds to the list
of internal signals connected to the \texttt{marked} port of the PCIs
implementing the places of $a$.

In the body of the \texttt{generate\_architecture} function, the
\texttt{generate\_place\_map} function implements the
\texttt{generate\_PCIs} procedure described in
Algorithm~\ref{alg:genpcis}. For each place of the \texttt{sitpn}
parameter, the \texttt{generate\_place\_map} function builds an
instance of the \texttt{HComponent} type, and adds an association
between place and \texttt{HComponent} instance in the \texttt{plmap}
field. The \texttt{generate\_place\_map} function fills the generic,
input port and output port map of the \texttt{HComponent} instances as
described in the \texttt{generate\_PCIs} procedure. Following the
\texttt{generate\_place\_map} function, the
\texttt{generate\_trans\_map} function implements the
\texttt{generate\_TCIs} procedure described in
Algorithm~\ref{alg:gentcis}. For each transition of the \texttt{sitpn}
parameter, the \texttt{generate\_trans\_map} function builds an
instance of the \texttt{HComponent} type, and adds an association
between transition and \texttt{HComponent} instance in the
\texttt{trmap} field. The \texttt{generate\_trans\_map} function fills
the generic, input port and output port map of the \texttt{HComponent}
instances as described in the \texttt{generate\_TCIs} procedure.
Finally, the \texttt{generate\_interconnections} function modifies the
input and output port maps of the \texttt{HComponent} instances in the
\texttt{plmap} and \texttt{trmap} fields, and thus, implements the
interconnections described in the \texttt{generate\_interconnections}
procedure of Algorithm~\ref{alg:geninter}.

\subsection{The \texttt{generate\_ports} function}
\label{sec:impl-gen-ports}

Listing~\ref{lst:impl-gen-ports} presents the \texttt{generate\_ports}
function called in the body of the \texttt{sitpn\_to\_hvhdl} function
(see Listing~\ref{lst:sitpn2hvhdl}). The \texttt{generate\_ports}
function implements the \texttt{generate\_ports} procedure described
in Algorithm~\ref{alg:genports}. The \texttt{generate\_ports} function
calls three functions: the \texttt{generate\_action\_ports\_and\_ps}
function that implements the \texttt{generate_action_ports} procedure
of Algorithm~\ref{alg:genacts}, the
\texttt{generate\_fun\_ports\_and\_ps} function that implements the
\texttt{generate_function_ports} procedure of
Algorithm~\ref{alg:genfuns}, and the
\texttt{generate_and_connect_cond_ports} that implements the
\texttt{generate\_condition_ports} procedure of
Algorithm~\ref{alg:genconds}.

\begin{lstlisting}[language=coq,label={lst:impl-gen-ports},
caption={[The \texttt{generate\_ports} function.]The
  \texttt{generate\_ports} function implementing the
  \texttt{generate\_ports} procedure presented in
  Algorithm~\ref{alg:genports}. },framexleftmargin=1.5em,xleftmargin=2em,numbers=left,
numberstyle=\tiny\ttfamily]
Definition generate_ports (sitpn : Sitpn) : Mon (Sitpn2HVhdlState sitpn) unit :=
  do _ <- generate_action_ports_and_ps;
  do _ <- generate_fun_ports_and_ps;
  generate_and_connect_cond_ports.
\end{lstlisting}

For every action of the \texttt{sitpn} parameter, the
\texttt{generate\_action_ports_and_ps} function adds a port
declaration entry to the \texttt{oports} field of the compile-time
state, and adds a binding between action and output port identifier in
the $\gamma$ field. It also builds the \texttt{action} process as
described in the \texttt{generate_action_ports} procedure, and adds
the process to the \texttt{beh} field of the compile-time state.  The
\texttt{generate_fun_ports_and_ps} does the same for the functions of
the \texttt{sitpn} parameter, and similarly builds the
\texttt{function} process and adds it to the \texttt{beh} field. The
\texttt{generate_and_connect_cond_ports} function add a port
declaration entry for every condition of the \texttt{sitpn} parameter
to the \texttt{iports} field of the compile-time state. Then, it
modifies the input port map of \texttt{HComponent} instances in the
\texttt{trmap} of the compile-time state's \texttt{arch} field. The
modifications pertain to the connection of input ports to the
\texttt{ic} input port of TCIs, as described in the
\texttt{generate\_condition_ports} procedure (see
Algorithm~\ref{alg:genconds}).

\subsection{The \texttt{generate\_comp\_insts} and
  \texttt{generate\_design\_and\_binder} functions}
\label{sec:impl-gen-comp-insts}

At the end of the \texttt{sitpn\_to\_hvhdl} function (see
Listing~\ref{lst:sitpn2hvhdl}), the \texttt{generate\_comp_insts}
function transforms the \texttt{HComponent} instances, associated with
places and transitions in the compile-time state's \texttt{arch}
field, into real component instantiation statements as defined in the
\hvhdl{} abstract syntax. Then, the \texttt{generate_design_and_binder} builds
up the final \hvhdl{} design and the $\gamma$ binder, and returns the couple.
Listing~\ref{lst:gen-comp-insts} presents the 
\texttt{generate_comp_insts} function and the \texttt{generate_design_and_binder} 
function. 

\begin{lstlisting}[language=coq,label={lst:gen-comp-insts},
caption={[The \texttt{generate\_comp\_insts} and the \texttt{generate_design_and_binder} function.]The \texttt{generate\_comp\_insts} and the \texttt{generate_design_and_binder} function.},framexleftmargin=1.5em,xleftmargin=2em,numbers=left,numberstyle=\tiny\ttfamily]
Definition generate_comp_insts (sitpn : Sitpn) : Mon (Sitpn2HVhdlstate sitpn) unit :=
  do _ <- generate_place_comp_insts sitpn; generate_trans_comp_insts sitpn.

Definition generate_design_and_binder (sitpn : Sitpn) ($id_e$ $id_a$ : ident) :
    Mon (Sitpn2HVhdlstate sitpn) (design * Sitpn2HVhdlMap sitpn) :=
  do s <- Get;
  Ret ((design_ $id_e$ $id_a$ [] ((iports s) $\mdoubleplus$ (oports s)) (sigs (arch s)) (beh s)), ($\gamma$ s)).
\end{lstlisting}

The \texttt{generate\_comp\_insts} function is needed because we are
using an intermediary representation for the component instantiation
statements. Even though this representation is convenient to
manipulate data during the different phases of the transformation, it
also implies an extra generation step to complete the generation of
the \hvhdl{} design and the $\gamma$ binder.  The
\texttt{generate_comp_insts} function calls the
\texttt{generate_place_comp_insts} and the
\texttt{generate_trans_comp_insts} functions.  These two functions
being similar in all points, except for the type of their inputs, we
are only presenting the \texttt{generate_place_comp_insts} function
here.  The \texttt{generate_place_comp_insts} function calls the
\texttt{generate\_place\_comp\_inst} function for each place defined
in the set of places of the \texttt{sitpn}
parameter. Listing~\ref{lst:gen-pcomp-inst} presents the code the
\texttt{generate\_place\_comp\_inst} function.

\begin{lstlisting}[language=coq,label={lst:gen-pcomp-inst},
caption={[The \texttt{generate\_place\_comp\_inst} function.]The \texttt{generate\_place\_comp\_inst} function.},framexleftmargin=1.5em,xleftmargin=2em,numbers=left,numberstyle=\tiny\ttfamily]
Definition generate_place_comp_inst (sitpn : Sitpn) (p : P sitpn) :
      Mon (Sitpn2HVhdlstate sitpn) unit :=

      do $id_p$ <- get_nextid;
      do _      <- bind_place p $id_p$;
      do pcomp  <- get_pcomp p;
      do pci    <- HComponent_to_comp_inst $id_p$ place_entid pcomp;
      add_cs pci.
\end{lstlisting}

The \texttt{generate_place_comp_inst} function generates a fresh and unique PCI identifier 
by appealing to the \texttt{get_nextid} function. The \texttt{get_nextid} function returns
and increments the current value of the \texttt{nextid} field, defined in the compile-time state.
Then, the \texttt{bind_place} function adds a binding between the place \texttt{p} and the identifier
$id_p$ in the $\gamma$ field of the compile-time state. The \texttt{get_pcomp} function looks up the 
\texttt{plmap} field (defined under the \texttt{arch} field of the compile-time state) and returns
the \texttt{HComponent} instance associated with the place \texttt{p}, i.e. \texttt{pcomp}.
The \texttt{HComponent_to_comp_inst} function translates the \texttt{HComponent} instance \texttt{pcomp}
into a PCI with the identifier $id_p$. Finally, the \texttt{add_cs} function composes 
the returned PCI with the current \hvhdl{} design behavior, hold in the \texttt{beh} field of the 
compile-time state. 

The transformation of a \texttt{HComponent}
instance into a PCI implies the translation of the input and output port map,
which are instances of the \texttt{InputMap} and \texttt{OutputMap} types, into their equivalent
representation in \hvhdl{} abstract syntax. The translation especially concerns the association
between a port identifier of the array type and a list of expressions, or names.
For instance, let us consider an instance of
\texttt{InputMap} that is an intermediary representation of the input
port map of a PCI $id_p$. In this \texttt{InputMap} instance, the \texttt{itf}
port, which is a composite input port of the \texttt{place}
design, is associated with the list $[id_a, id_b, id_c]$. Then, based on the previous association, the
\texttt{HComponent_to_comp_inst} function generates the following
associations is the concrete input port map of PCI $id_p$: $(\mathtt{rt}(0), id_a)$,
$(\mathtt{rt}(1), id_b)$ and $(\mathtt{rt}(2), id_c)$. 

Getting back to Listing~\ref{lst:gen-comp-insts}, the
\texttt{generate_design_and_binder} function retrieves the current
compile-time state \texttt{s} with the \texttt{Get} function. Then,
based on the value of the different fields of the compile-time state,
the function builds an \hvhdl{} design and returns it along with the
$\gamma$ binder.  The \hvhdl{} design receives the $id_e$ and $id_a$
identifiers, passed as inputs, as the design's entity and architecture
identifiers.  The generic constant declaration list of the \hvhdl{}
design is empty, i.e. it receives the empty list value.  The port
declaration list of the \hvhdl{} design is built by concatenating the
content of the \texttt{iports} and \texttt{oports} fields defined in
state \texttt{s}. The internal signal declaration list is filled by
the \texttt{sigs} field, defined under the \texttt{arch} field of
state \texttt{s}. Finally, the \texttt{beh} field receives the
behavior of the \hvhdl{} design.







%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../main"
%%% End:
