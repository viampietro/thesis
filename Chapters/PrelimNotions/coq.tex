In this section, we present the \coq{} proof assistant
\cite{Coq2021}. The \coq{} proof assistant constitutes our framework
to encode the different semantics, programs and proofs involved in the
verification of the \hilecop{} model-to-text transformation. Here, we
give an overview of the different concepts underlying the \coq{} proof
assistant. The aim is to give to the reader the tools to understand
the different listings presenting \coq{} code in the following
chapters. For a thorough presentation of the \coq{} proof assistant,
the reader can refer to the \coq{} reference
manual\footnote{\url{https://coq.inria.fr/distrib/current/refman/}},
or to \cite{Chlipala2013,Paulin-Mohring2012,Bertot2004}.

\subsection{The Calculus of Inductive Constructions (CIC)}
\label{sec:cic}

The kernel of the \coq{} proof assistant implements the Calculus of
Inductive Constructions (CIC) \cite{CoquandPaulin1990}. The CIC is a
typed lambda-calculus extended with the possibility to define
inductive types. Thus, the CIC permits to define programs and types in
a similar way; both are \textit{terms} of the language. A program is a
term with a certain type, and a type is also a term with a certain
type. The type of a type is called a \textit{sort}. We can mention two
basic sorts built in the \coq{} proof assistant: the \texttt{Prop}
sort which is the type of logical formulas, and the \texttt{Set} sort
which is the type of \textit{small} sets.

The \coq{} proof assistant permits to express logic formulas and to
interactively build proofs of these formulas by using a high-level
tactic language. The sequence of tactics that builds a proof for a
given formula is called a \emph{proof script}. The execution of a
proof script builds a proof term. In the CIC, a logic formula can be
seen as a \textit{type} and a proof of this formula is an
\textit{inhabitant} of the type denoted by the logic formula. Thus,
when building a proof term by executing a proof script, the \coq{}
kernel checks that the proof term is of the type of the logic formula
by applying typing
rules\footnote{\url{https://coq.inria.fr/distrib/current/refman/language/cic.html}}. For
instance, let us take two logical propositions \texttt{A} and
\texttt{B}. In \coq{}, we can declare these propositions as elements
of the \texttt{Prop} type in the \coq{} top-level loop\footnote{\coq{}
  scripts can be either interpreted or compiled.}:

\begin{lstlisting}[language=CoqBare]
  Coq <  Variables A B : Prop.
\end{lstlisting}

The \texttt{Variables} keyword adds the propositions \texttt{A} and
\texttt{B} to the global environment accessed by the \coq{}
kernel. Now, say that we want to prove the \textit{modus ponens}
theorem expressed with the propositions \texttt{A} and \texttt{B},
namely that
$\mathtt{A}\Rightarrow(\mathtt{A}\Rightarrow{}\mathtt{B})\Rightarrow\mathtt{B}$.
In \coq{}, we can express it as follows:

\begin{lstlisting}[language=CoqBare]
  Coq <  Theorem modus_ponens : A -> (A -> B) -> A.
\end{lstlisting}

Here, we declare the modus ponens theorem as an element of type
\coqeb{A -> (A -> B) -> A}. The arrows represent functional arrows; in
fact, \coqeb{A -> B} is a notation for the product type
$\Pi{}x:\mathtt{A}.\mathtt{B}$ where $x$ is not referenced in
$\mathtt{B}$. According to the Curry-Howard correspondence
\cite{Howard1980}, there is an equivalence between a proof term and a
program. Thus, a proof term of the logical implication
$\mathtt{A}\Rightarrow\mathtt{B}$ is equivalent to a program, or a
function, of type \coqeb{A -> B}, i.e. a program that takes an element
of type $\mathtt{A}$ and yields an element of type $\mathtt{B}$. Thus,
the type \coqeb{A -> (A -> B) -> A} is a valid encoding of the formula
$\mathtt{A}\Rightarrow(\mathtt{A}\Rightarrow{}\mathtt{B})\Rightarrow\mathtt{B}$.

The \texttt{Theorem} keyword triggers the interactive proof mode
through which the user will build a proof term for the corresponding
formula. A simple proof term for the modus ponens theorem is a
function that takes an element $x$ of type $\mathtt{A}$ and a function
$f$ of type \coqeb{A -> B} as inputs, and yields an element of type
$\mathtt{B}$ by applying the function $f$ to parameter $x$, i.e.
$(f~x)$. The function takes the form of the following term of the
typed lambda-calculus:

\begin{center}
  $\lambda{}(x:\mathtt{A}).\lambda{}(f:\mathtt{A}\rightarrow\mathtt{B}).(f~x)$
\end{center}

While passing this \textit{lambda-term} as a proof term of the modus
ponens theorem, the \coq{} kernel checks the well-typedness of the
term by building the following derivation tree, which is a simplified
version of the full derivation tree according to the typing rules of
the CIC:

\begin{table}[H]
  \centering
  \begin{tabular}{l}
    {\begin{prooftree}[template=\fontsize{11}{13}\selectfont\inserttext]

        \infer0[\textsc{Var}]{
          $\mathtt{A~B:Prop}[x:\mathtt{A},f:\mathtt{A}\rightarrow\mathtt{B}]\vdash{}f~:~\mathtt{A}\rightarrow\mathtt{B}$
        }

        \infer0[\textsc{Var}]{
          $\mathtt{A~B:Prop}[x:\mathtt{A},f:\mathtt{A}\rightarrow\mathtt{B}]\vdash{}x~:~\mathtt{A}$
        }
        
        \infer2[\textsc{App}]{
          $\mathtt{A~B:Prop}[x:\mathtt{A},f:\mathtt{A}\rightarrow\mathtt{B}]\vdash(f~x)~:~$
          \coqeb{B}
        }
    
        \infer1[\textsc{Lam}]{
          $\mathtt{A~B:Prop}[\mathtt{x:A}]\vdash\lambda{}(f:\mathtt{A}\rightarrow\mathtt{B}).(f~x)~:~$
          \coqeb{(A -> B) -> B}
        }
        
        \infer1[\textsc{Lam}]{
            $\mathtt{A~B:Prop}[]\vdash\lambda{}(x:\mathtt{A}).\lambda{}(f:\mathtt{A}\rightarrow\mathtt{B}).(f~x)~:~$ \coqeb{A -> (A -> B) -> B}
        }
      \end{prooftree}} \\
  \end{tabular}
\end{table}

In the above derivation tree, the global and the local environment are
represented at the left of the thesis symbol $\vdash$. The local
environment is represented by square brackets. The global environment
is represented at the left of the local environment. At the root of
the derivation tree, the global environment contains our two
previously declared logical propositions \texttt{A} and \texttt{B},
whereas the the local environment is empty. The application of the
\textsc{Lam} rule adds new entry to the local environment; the
\textsc{App} triggers the type-checking of the left and the right part
of an application; the \textsc{Var} rule checks that a term is
well-typed if it is referenced as an element of the given type in the
global or the local environment.

As said before, the \texttt{Theorem} keyword triggers the interactive
proof mode. The interactive proof mode will accompany the user to an
incremental building of a proof term for the current goal, i.e. the
current logic formula we want to prove. Then, to prove the modus
ponens theorem, the following interface is first presented to the
user:

\begin{flushleft}
  \coqeb{Coq <  Theorem modus_ponens : A -> (A -> B) -> B.}\\
  \coqeb{1 subgoal}\\
  \texttt{~~}\\
  \texttt{============================}\\
  \coqeb{A -> (A -> B) -> B}\\
\end{flushleft}

The term under the horizontal bar represents the current goal to
prove, i.e. the current formula for which we are building a proof
term. Above the horizontal bar are referenced the variables
constituting the local environment. At the beginning of the proof, the
local environment is empty -- and so is the local environemnt at the
root of the derivation tree presented above. To build a proof term in
interactive mode, the user will then invoke commands called
\textit{tactics}. Each tactic invocation corresponds to the invocation
of a typing rule of the CIC performed by the \coq{} kernel. To build a
proof term for the modus ponens theorem, the first thing to do is to
invoke the \textsc{Lam} rule; this is done by appealing to the
\texttt{intros} tactic.

\begin{flushleft}
\coqeb{Coq <  intros x.}\\
\coqeb{1 subgoal}\\
\texttt{~~}\\
\coqeb{x : A}\\
\texttt{============================}\\
\coqeb{(A -> B) -> B}\\
\end{flushleft}

Here, the user passes to the system the name of the variable that will
be introduce in the local environment by the \textsc{Lam} rule, i.e
the variable \texttt{x}. Then, we repeat the operation, applying the
\textsc{Lam} rule a second time to introduce an element of type
\coqeb{A -> B} in the environment.

\begin{flushleft}
\coqeb{Coq <  intros f.}\\
\coqeb{1 subgoal}\\
\texttt{~~}\\
\coqeb{x : A}\\
\coqeb{f : A -> B}\\
\texttt{============================}\\
\coqeb{B}\\
\end{flushleft}

Then, based on the local environment, we can build an object of type
\texttt{B} by applying \texttt{f} to the input \texttt{x}. We can do
it by appealing to the \texttt{apply} tactic. The \texttt{apply}
tactic invokes the \textsc{App} rule.

\begin{flushleft}
\coqeb{Coq <  apply (f x).}\\
\coqeb{No more subgoals.}\\
\medskip
\coqeb{Coq <  Qed.}\\
\end{flushleft}

After the invocation of the \texttt{apply} tactic, the proof term for
the modus ponens theorem is completely built, thus, the \coq{}
top-level loop displays the message that all goals are completed.
Then, we can close the interactive proof mode and store the proof of
the modus ponens theorem in the global environment by using the
\texttt{Qed} keyword.

\subsection{Inductive types}
\label{sec:ind-types}

One of the major strength of the CIC, and therefore of the \coq{}
proof assistant, is the possibility to enrich the global type system
with the definition of inductive types. For instance, here is the
definition of the type of natural numbers, named \coqeb{nat}:

\begin{lstlisting}[language=CoqBare]
  Inductive nat : Set :=
  | O : nat
  | S : nat -> nat.
\end{lstlisting}

The \coqeb{nat} type is of the \coqeb{Set} sort (remember that the
type of a type is called a sort). The \coqeb{nat} type is defined
through two constructors, represented by the pipe-separated entries.
The \coqeb{O} constructor states that zero is a natural number. The
\coqeb{S} constructor takes a natural number as input and yields the
succesor to this natural number. This corresponds to the structural
definition of natural numbers in Peano's arithmetic. Thus, in this
setting, the number 2 is represented by \coqeb{(S (S O))}, the number
3 by \coqeb{(S (S (S O))}, etc. The result of the evaluation of an
inductive type, declared through the \texttt{Inductive} keyword, is
the addition of this type and each of its constructors to the global
environment accesible by the \coq{} kernel. Also, a corresponding
induction principle is generated at the evaluation of an inductive
type definition. For instance, the \coqeb{nat_ind} induction principle
is generated at the evaluation of the \coqeb{nat} type. The
\coqeb{nat_ind} induction principle is equivalent to the so-called
mathematical induction presented in Section~\ref{sec:math-ind}. It is
a proof term of the logical formula denoting the mathematical
induction, i.e.:

\begin{lstlisting}[language=CoqBare]
  forall P : nat -> Prop, P 0 -> (forall n : nat, P n -> P (S n)) -> forall n : nat, P n
\end{lstlisting}

Then, the induction principle \coqeb{nat_ind} can be used to perform
mathematical induction in a proof involving natural numbers. For
instance, say that we want to prove the following theorem stating that
a natural number elevated at the power 2 is always greater than or
equal to itself. We can write as follows:

\begin{flushleft}
  \coqeb{Coq <  Theorem ge_pow2 : forall n : nat, n <= n * n.}\\
  \coqeb{1 subgoal}\\
  \texttt{~~}\\
  \texttt{============================}\\
  \coqeb{forall n : nat, n <= n * n}\\
\end{flushleft}


Then, we can use the \coqeb{nat_ind} induction principle to prove such
a theorem. Most conveniently, the built-in \coqeb{induction} tactic
chooses the appropriate induction principle based on the type of its
argument. Thus, the following command invokes the \coqeb{nat_ind}
induction principle over the universally quantified variable
\coqeb{n}:

\begin{flushleft}
\coqeb{Coq < induction n.}\\
\coqeb{2 subgoals}\\
\texttt{~~}\\
\texttt{============================}\\
\coqeb{0 <= 0 * 0}\\
\coqeb{subgoal 2 is:}\\
\coqeb{S n <= S n * S n}\\
\end{flushleft}

The result of the invocation of the \coqeb{induction} tactic is a
branching in the proof tree. Thus, the system indicates that two
subgoals must be prove to complete the proof of the \coqeb{gt_pow2}
theorem. These two subgoals corresponds to the proof of $P(0)$ and the
proof that assuming $P(n)$ we can show $P(n+1)$, as agreed with
mathematical induction. Here, the property $P$ is defined by
$P(n)\equiv{}n\le{}n\times{}n$. We can use the built-in \coqeb{lia}
tactic, defined in the \coqeb{Lia} module of the \coq{} standard
library, to solve the two remaining subgoals.  The \coqeb{lia} tactic
implements a whole decision procedure to prove theorems involving
systems of equalities and inequalities over the set of natural
numbers.  We can combine the \coqeb{induction} tactic with the
\coqeb{lia} tactic using the semi-colon operator. Then, the
\coqeb{lia} tactic is applied to all the subgoals generated by the
\coqeb{induction} tactic.

\begin{flushleft}
\coqeb{Coq < induction n; lia.}\\
\coqeb{No more subgoals.}\\
\coqeb{Coq < Qed.}\\
\end{flushleft}

The \coq{} proof assistant permits to define complex proof tactics, as
for example the \coqeb{lia} tactic, in order to automatize some proof
tasks. The \coqeb{Ltac} and \coqeb{Ltac2} languages are the supports
for the definition of these kind of tactics. These languages permit to
compose sequences of tactics, to perform pattern matching over the
local environemnt and the current goal in interactive proof mode, to
define loops or recursive tactics, etc. \\

Leveraging the definition of inductive types, the syntactic constructs
of programming languages are also easily implemented. Here is the
implementation of the syntax of arithmetic expressions presented in
the previous section:

\begin{lstlisting}[language=CoqBare]
Inductive e : Set :=
| enat : nat -> e
| eid : string -> e
| eadd e -> e -> e.
\end{lstlisting}

Each constructor corresponds to a construction case in the definition
of arithmetic expressions in the Backus-Naur form. The \coq{} system
also generates the induction principle following the structure of
arithmetic expressions (thus, a structural induction principle). The
induction principle is a proof term of the following logical formula:

\begin{lstlisting}[language=CoqBare]
  forall P : e -> Prop,
       (forall n : nat, P (enat n)) ->
       (forall id : string, P (eid id)) -> 
       (forall e0 : e, P e0 -> forall e1 : e, P e1 -> P (eadd e0 e1)) -> 
       forall e : e, P e
\end{lstlisting}

The evaluation relation for arithmetic expressions is defined in a
similar way:

\begin{lstlisting}[language=CoqBare]
Inductive evale (s : string -> option nat) : e -> nat -> Prop :=
| evalnat : forall n : nat, evale s (enat n) n
| evalid : forall (id : string) (n : nat), 
             s id = Some n ->
             evale s (eid id) n
| evaladd : forall (e0 e1 : e) (n m : nat), 
              evale s e0 n -> 
              evale s e1 m ->
              evale s (eadd e0 e1) (n + m).
\end{lstlisting}

In the above listing, the state that yields the value of identifiers
present in an arithmetic expression is a named parameter of the
\coqeb{evale} relation, i.e. the \coqeb{s} parameter. Parameters which
are not varying from one construction case to another can be passed as
named parameters while defining an inductive type. The state \coqeb{s}
takes a string identifier as input and yields an \coqeb{option} to a
natural number.  As so, the \coqeb{option} type permits to represent
partial functions.  The identifiers that belong to the domain of state
\coqeb{s} will be associated with \coqeb{Some} natural number, whereas
the unreferenced identifiers will be associated with the \coqeb{None}
value of the \coqeb{option} type. The \coqe{Some} and the \coqeb{None}
constructors are the two constructors of the \coqeb{option} type which
is defined in \coq{} as follows:

\begin{lstlisting}[language=CoqBare]
Inductive option (A : Type) : Type :=
| Some : A -> option A
| None : option A.
\end{lstlisting}

The \coqeb{option} type is parameterized by a type \coqeb{A} that will
set the type of elements passed to the \coqeb{Some} constructor. As
so, the \coqeb{option} type is an example of generic type.

\subsection{Functional programming}
\label{sec:fun-prog}

As told in the presentation of the CIC, the \coq{} proof assistant
permits to write functional programs, including the definition of
recursive functions. The definition of a recursive function is
performed with \coqeb{Fixpoint} keyword. Here is an example of
recursive function defined in \coq{}. The \coqeb{pow} function takes
two natural numbers \coqeb{a} and \coqeb{n} as inputs and yields
\coqeb{a} to the power \coqeb{n}.

\begin{lstlisting}[language=CoqBare]
Fixpoint pow (a n : nat) {struct n} : nat :=
  match n with 
  | O => 1
  | S m => a * pow a m
  end.
\end{lstlisting}

In the body of the \coqeb{pow} function, the \coqeb{match} construct
performs pattern-matching over the structure of the input \coqeb{n}.
The input \coqeb{n} is an element of the \coqeb{nat} type, and thus it
could either have been built with the \coqeb{O} constructor or as the
succesor of another element of the \coqeb{nat} type, i.e. with the
\coqeb{S} constructor. The \coqeb{match} construct enumerates all the
possible construction cases for the given input. Each construction
case leads to a pipe-separated entry; for each entry, the structure of
the input appears at the left of the arrow, and the result returned
appears at the right the arrow. In the above example, \coqeb{1} is
returned if \coqeb{n} equals \coqeb{O}, and the result of the
multiplication of \coqeb{a} with the recursive call \coqeb{pow a m} is
returned if \coqeb{n} is the succesor of a certain \coqeb{m}. In that
case, we have \coqeb{m = n $-$ 1}, and then the recursive call
\coqeb{pow a m} can be read as \coqeb{pow a (n $-$ 1)}.

When declaring a recursive function, the user must specify which
parameter is structurally decrementing through the recursive
call. This is performed through \coqeb|{struct $id$}| annotation,
where $id$ denotes one parameter of the declared function. This
information permits to the \coq{} kernel to generate the fixpoint
equation for the function, thus proving that the function is always
terminating.

\subsection{Dependent types}
\label{sec:dep-types}

In the listings that the reader will find in the following chapters,
and also in the code repository associated with this thesis, some data
structures are \textit{dependently-typed} structures. Thus, we
introduce here the notion of dependent type and how it is expressible
with the \coq{} proof assistant.

A type is said to be dependent when its expression depends on one or
more elements of other types. To give an example of dependent type,
let us take the definition of polymorphic lists that carry their own
length. In \coq{}, these lists are defined as follows:

\begin{lstlisting}[language=CoqBare]
Inductive listn (A : Type) : nat -> Set :=
| niln : list A 0
| consn : forall n : nat, A -> listn A n -> listn A (S n).
\end{lstlisting}

The \coqeb{listn} takes the type \coqeb{A} of its elements as its
first parameter, then its second parameter is an element of the
\coqeb{nat} type which represent the actual length of the list. Note
that the first parameter, i.e. the \coqeb{A} parameter, of the
\coqeb{listn} type alone is not sufficient to qualify \coqeb{listn} as
a dependent type. The \coqe{A} parameter is the expression of the
polymorphism of the elements of the list involved in generic
programming. Polymorphism relates to the fact that the \coqeb{A} type
is general enough to accept multiple types as the type of the list's
elements. The \coqeb{niln} constructor of the \coqeb{listn}, i.e. the
constructor of the empty list, has the type of lists of length 0.  The
\coqeb{consn} constructor permits to add a new element at the head of
an existing \emph{tail} list to build a new list. Thus, the type of
the resulting list is the type of lists of length $n+1$, where $n$ is
the length of the tail list.

To further illustrate the use of dependent types, let us say that we
want to write a function that takes two natural numbers $n$ and $m$ as
inputs, and yields $n-m$ only if $n\ge{}m$. Thus, the function takes
two parameters $n$ and $m$, and a third parameter which is the proof
that $n\ge{}m$. This third parameter \textit{depends} on the two
previous parameters, and thus the function is said to be a
dependently-typed function. In \coq{}, it would be written as follows:

\begin{lstlisting}[language=CoqBare]
Definition my_sub (n m : nat) (pf : m <= n) : nat := n $-$ m.
\end{lstlisting}

Even though, in its definition body, the \coqeb{my_sub} function
simply appeals to the \coq{} built-in substraction function, passing a
proof that $m$ is less than or equal to $n$ adds a constraint to the
computation of the substraction. One can see how dependent types can
help check that the parameters of programs meet some properties at
definition time.  Constraining the type of parameters during the
definition of programs reduces the proof efforts afterwards, but adds
programming complexities at the moment of the definition. Thus, there
is a trade-off between using dependent types to constraint the
structures and programs at the moment of their definition, or letting
the structures and programs as constraint loose as possible at the
cost of having to prove much more properties afterwards.

To conclude the subject of dependent types, we often use
\textit{sigma} types to define a type of elements that meet a given
property. A sigma type expresses the dependence between a parameter
and a proof of a given property that possibly depends on another
parameter. As so, sigma types are useful to express intentional sets
(cf. Section~\ref{sec:set-theory}). In the \coq{} standard library,
the definition of the sigma type is as follows:

\begin{lstlisting}[language=CoqBare]
Inductive sig (A:Type) (P:A -> Prop) : Type := exist : forall x:A, P x -> sig P.
\end{lstlisting}

The \coqeb{sig} type only constructor takes an element \coqeb{x} of
type \coqeb{A} along with a proof that \coqeb{x} meets a certain
property \coqeb{P}. For instance, if we want to define the type of
natural numbers that are strictly greater than zero, we can do it as
follows:

\begin{lstlisting}[language=CoqBare]
Definition natstar := sig nat (fun n : nat => n > 0).
\end{lstlisting}

The property passed as the second argument of the \coqeb{sig} type is
expressed by a lambda abstraction (denoted by the \coqeb{fun} keyword)
that takes a parameter \coqeb{n} of type \coqeb{nat} and returns a
proof that \coqeb{n} is strictly greater than zero.  The \coq{}
standard library defines a notation to write sigma types as
intensional sets. Thus, we can write the \coqeb{natstar} type as
follows:

\begin{lstlisting}[language=CoqBare]
Definition natstar2 := { x : nat | x > 0}.
\end{lstlisting}

We can leverage sigma types to rewrite the \coqeb{my_sub} function
presented above. In the following version, the type of the $m$
parameter carries the proof that $m$ is less than or equal to $n$:

\begin{lstlisting}[language=CoqBare]
Definition my_sub2 (n : nat) (m : { x : nat | x <= n }) : nat := n $-$ (proj1_sig m).
\end{lstlisting}

Here, we can no longer directly substract $n$ with $m$ as the type of
$m$ is no longer \coqeb{nat} but \coqeb{ $\{$ x : nat | x <= n $\}$ }.
We have to extract the first part of the $m$ parameter with the help
of the \coqeb{proj1_sig} function. The first part of an element of the
\coqeb{ $\{$ x : nat | x <= n $\}$ } type corresponds to the natural
number \coqeb{x} verifying the following property \coqeb{x <= n}, and
the second part corresponds to the proof that \coqeb{x} verifies the
property.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../main"
%%% End:
