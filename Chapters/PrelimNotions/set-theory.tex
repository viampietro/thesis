In this section, we introduce classical first-order logic and the
Zermelo-Fraenkel (ZF) set theory which combination constitutes the
base formalism for all our mathematical definitions, and our framework
for the expression and the interpretation of logical formulas.

\subsection{Classical first-order logic}
\label{sec:fol-classical}

In this section, we define the syntax of the first-order logic. Here,
we already use concepts and notations that belong to set theory; set
theory will be presented in the following section.  For now, the
reader has only to consider the \textit{intuitive} definition of a set
as a collection of elements, and a function as an entity that relates
each element of a set to a unique element of another set.

To define the syntax of the first-order logic, let us first define:

\begin{itemize}
\item The set $\mathcal{V}$ of variables x, y, etc.
\item The set $\mathcal{S}_\mathcal{F}$ of function symbols f, g, etc.
\item The set $\mathcal{S}_\mathcal{P}$ of predicate symbols P, Q,
  etc.
\end{itemize}

Let us also consider a function
$a\in{}\mathcal{S}_\mathcal{F}\cup{}\mathcal{S}_\mathcal{P}\rightarrow\mathbb{N}$
that associates a given function or predicate symbol to an arity,
i.e. the number of parameters of the function or the predicate. E.g,
if $f(x,y)$ with $f\in{}\mathcal{S}_\mathcal{F}$ then $a(f)=2$; if
$P(x,y,z)$ with $P\in\mathcal{S}_\mathcal{P}$ then $a(P)=3$. Constants
are functions of arity 0, i.e. with no parameter.

The syntax of classical first-order logic \cite{Moschovakis2018} is
divided between \textit{terms} and \textit{formulas}.  We define a
term of the classical first-order logic with the following BNF entry:

\begin{center}
  $t::=v~\vert{}~f(t_1,\dots,t_n)$
\end{center}

This entry states that a term is either a variable
$v\in{}\mathcal{V}$, or a function symbol
$f\in\mathcal{S}_\mathcal{F}$ of arity $n$ with terms $t_1,\dots,t_n$
as inputs.

We define a formula of the classical
first-order logic with the following BNF entry:

\begin{center}
  $\mathcal{F}::=\bot~\vert~\top~\vert~P(t_1,\dots,t_n)~\vert~\mathcal{F}\land\mathcal{F}$
  $~\vert~\mathcal{F}\lor\mathcal{F}~\vert~\mathcal{F}\Rightarrow\mathcal{F}~\vert~\mathcal{F}\Leftrightarrow\mathcal{F}$
  $~\vert~\neg\mathcal{F}$
  $~\vert~\forall{}x,\mathcal{F}~\vert~\exists{}x,\mathcal{F}$
\end{center}

This entry states that a formula is either:

\begin{itemize}
\item $\bot$ (bottom), the always \textit{false} formula, or $\top$
  (top), the always \textit{true} formula.
\item A predicate $P(t_1,\dots,t_n)$ (i.e. an atomic formula) of arity
  $n$, where $P\in\mathcal{S}_\mathcal{P}$ with terms $t_1,\dots,t_n$
  as inputs.
\item The composition of two subformulas with one of the following
  binary operators: the conjunction $\land$, the disjunction $\lor$,
  the implication $\Rightarrow$, the double implication
  $\Leftrightarrow$.
  
\item The composition of one subformula with the negation operator
  $\neg$.
  
\item A subformula prefixed by the universal quantifier $\forall$ or
  the existential quantifier $\exists$. For instance, the formula
  $(\forall{}x,P(x))$ denotes the atomic formula $P(x)$ where the
  parameter $x$ is a universally quantified variable of the
  formula. As a shorthand notation, we write $\forall{}x,y,z.\dots$ to
  denote $\forall{}x,\forall{}y,\forall{}z.\dots$. The same stands for
  the existential quantifier $\exists$. Variables that are introduced
  in a logical formula by one of the previous quantifiers are called
  the \textit{bound} variables of the formula. Variables that appear
  in a logical formula without being introduced by a quantifier are
  called \textit{free} variables. For instance, in the logical formula
  $(\forall{}x,~P(x)\land{}Q(y))$, $x$ is a bound variable and $y$ is
  a free variable of the formula.
\end{itemize}

In this thesis, our formulas are interpreted as formulas of the
\textit{classical} logic \cite{Shapiro2021}. Thus, during a proof, we
can appeal to the \textit{law of excluded middle} to reason on the
truth value of a given formula.

% The difference between the classical first-order logic and the
% intuitionistic one relies in the absence of the \emph{law of the
%   excluded middle} in the latter logic. In classical logic, the
% \emph{law of the excluded middle} considers that a formula can always
% be either interpreted as true or false, i.e. a formula is always
% \emph{decidable} regardless the valuation of its inputs. In
% intuitionistic logic, such an assumption is discarded. Thus, a formula
% of the intuitionistic logic can be \emph{undecidable}, i.e. given a
% valuation of its input, one can not always state that the formula is
% true or false. The consequence is that one as to exhibit a
% \emph{explicitly-built} proof to show that a given formula is
% true. One can not rely on the law of excluded middle to perform a
% proof by contradiction. As so, the intuitionistic logic is said to be
% \emph{constructive} in the sense that one as to \emph{construct} a
% concrete proof object to show that a formula is true. The
% intuitionistic first-order logic is built in the \coq{} proof
% assistant. Thus, a logic formula expressed with the \coq{} proof
% assistant is an intuitionistic formula by default. For this reason, we
% choose the intuitionistic first-order logic as our mathematical
% framework for the expression of logic formulas.

% In what follows, we often give the definition of a predicate by
% relating its semantics to the semantics of an underlying formula. For
% instance, we define the predicate $IsEven(n)$, for all
% $n\in{}\mathbb{N}$, as follows:
% $IsEven(n)\equiv{}\exists{}k\in\mathbb{N}~s.t.~2k=n$.

\subsection{ZF Set theory}
\label{sec:set-theory}

In this thesis, we use the Zermelo-Fraenkel (ZF) set theory as the
base formalism for all our mathematical definitions and proofs. In
this section, we present the axioms of the ZF set theory, and the
associated definitions and notations that will be used throughout this
memoir. The reader will find further information on the ZF set theory
in \cite{Moschovakis1994}.

In the ZF set theory, a set represents a group of elements called the
members of the set. For every set $A$, we write $a\in{}A$ to denote
that the element $a$ is a member of set $A$. The \textit{membership}
property is a basic set-theoretic property. Given a set $A$, we
sometimes have to express a property $P$ of the elements of $A$ in the
following form: $\forall{}x,x\in{}A\Rightarrow{}P(x)$. When there is
no ambiguity, we equivalently write $\forall{}x\in{}A,~P(x)$.

Now, let us define the axioms of the ZF set theory.

\begin{axiom}[Existence]
  \label{ax:existence}
  There exists a set which has no elements,
  i.e. $\exists{}A,\forall{}a,a\notin{}X$.
\end{axiom}

\begin{definition}[Empty set]
  We call the \textit{empty set} the unique set with no element,
  written $\emptyset$.
\end{definition}

\begin{axiom}[Extensionality]
  \label{ax:extensionality}
  If every element of $A$ is an element of $B$, and vice-versa, then
  $A=B$,
  i.e.
  $\forall{}A,B,x,~(x\in{}A\Leftrightarrow{}x\in{}B)\Rightarrow{}A=B$.
\end{axiom}

\begin{axiom}[Schema of comprehension]
  \label{ax:schema-of-compr}
  Let $P(x)$ be a property of $x$. For all set $A$, there exists a set
  $B$ such that $x\in{}B$ if and only if $x\in{}A$ and $P(x)$
  holds. I.e.
  $\forall{}A,B,x,~x\in{}B\Leftrightarrow{}x\in{}A\land{}P(x)$.
\end{axiom}

\begin{axiom}[Pair]
  \label{ax:pair}
  For all set $A$ and $B$, there exist a set $C$ such that $x\in{}C$
  if and only if $x=A$ and $x=B$. I.e.
  $\forall{}A,B,\exists{}C,\forall{}x,~(x\in{}C\Leftrightarrow{}x=A\lor{}x=B)$.
\end{axiom}

More intuitively, Axiom~\ref{ax:pair} states that if $A$ and $B$ are
sets then their corresponding pair $C$ is also a set.

\begin{axiom}[Union]
  \label{ax:union}
  For all set $A$ having sets as elements, there exists a set $C$
  corresponding to the union of the elements of
  $A$. I.e. $\forall{}A,\exists{}U,~x\in{}U\Leftrightarrow\exists{}B,~B\in{}A\land{}x\in{}B$.
\end{axiom}

\begin{definition}[Subset]
  A set $A$ is a subset of set $B$, written $A\subseteq{}B$, if for
  all $x$ if $x\in{}A$ then $x\in{}B$,
  i.e. $\forall{}x,x\in{}A\Rightarrow{}x\in{}B$.
\end{definition}

\begin{definition}[Union]
  Given a set $A$ and $B$, the set $A\cup{}B$ is the union of the
  members of $A$ and the members of $B$, i.e.
  $\forall{}x,x\in{}A\cup{}B\Leftrightarrow{}x\in{}A\lor{}x\in{}B$.
\end{definition}

\begin{axiom}[Infinity]
  \label{ax:infty}
  There exists a set $A$ such that the empty set belongs to $A$ and
  for all $x$ such that $x\in{}A$ then $x\cup\{x\}\in{}A$. I.e.
  $\exists{}A,\emptyset\in{}A\land(\forall{}x,~x\in{}A\Rightarrow{}x\cup\{x\}\in{}A)$.
\end{axiom}

\begin{axiom}[Power set]
  \label{ax:pow-set}
  For all set $A$, there exists a set $B$ such that for all set $X$,
  $X\in{}B$ if and only if
  $X\subseteq{}A$. I.e.
  $\forall{}A,\exists{}B,\forall{}X,(X\in{}B\Leftrightarrow{}X\subseteq{}A)$.
\end{axiom}

\begin{axiom}[Schema of replacement]
  \label{ax:sch-of-repl}
  Let $P(x,y)$ be a property such that for all $x$ there exists a
  unique $y$ such that $P(x,y)$ holds. For all set $A$, there exists a
  set $B$ such that for all $x\in{}A$, there exists $y\in{}B$ for
  which $P(x,y)$ holds. I.e. $(\forall{}x,\exists{}y,P(x,y))\land{}$
  $\forall{}A,\exists{}B,\forall{}x,(x\in{}A\Leftrightarrow\exists{}y,y\in{}B\land{}P(x,y))$.
\end{axiom}

\begin{definition}[Intersection]
  Given a set $A$ and $B$, the set $A\cap{}B$ denotes the set formed
  by the intersection of set $A$ and $B$, i.e.
  $\forall{}x,x\in{}A\cap{}B\Leftrightarrow{}~x\in{}A\land{}x\in{}B$.
\end{definition}

\begin{axiom}[Foundation]
  \label{ax:foundation}
  For all non-empty set $A$, there exists a set $B$ such that
  $B\in{}A$ and $B$ has no common element with $A$. I.e.
  $\forall{}A,x\neq\emptyset\Rightarrow\exists{}B,B\in{}A\land(A\cap{}B=\emptyset)$.
\end{axiom}

Based on the previous axioms, we can complement the theory with
following definitions and notation.

\begin{notation}[Extension]
  A set is defined by \emph{extension} with the enumeration of all its
  members. For instance, $\{1,0,-1\}$, $\{a,b,c\}$ or
  $\{p_0,\dots,p_n\}$ are all sets defined by extension.
\end{notation}


\begin{notation}[Intension]
  Let $P(x)$ be a property of $x$, we write $\{x~\vert~P(x)\}$ the set
  of $x$ for which $P(x)$ holds. The set $\{x~\vert~P(x)\}$ is defined
  by \textit{intension}.  For instance, here is the intensional
  definition of the set of even numbers:
  $\{n\in\mathbb{N}~\vert~\exists{}k\in\mathbb{N},~n=2k\}$.
\end{notation}

Given two sets $A$ and $B$, the following sets are formed:

\begin{definition}[Difference]
  $A\setminus{}B$ denotes the set formed by the elements of set $A$
  that are not elements of set $B$ (the difference between set $A$ and
  $B$), i.e. $A\setminus{}B=\{x~\vert~x\in{}A\land{}x\notin{}B\}$.
\end{definition}

\begin{definition}[Cartesian product]
  $A\times{}B$ denotes the Cartesian product between the elements
  of set $A$ and set $B$, i.e. the set of all ordered pairs defined by
  $\{(x,y)~\vert~x\in{}A\land{}y\in{}B\}$. We generalize the
  definition to build the set of $n$-tuples
  $A_0\times{}A_1\times\dots\times{}A_n$ defined by
  $\{(x_0,
  (x_1,\dots(\dots,x_n)))~\vert~x_0\in{}A_0,x_1\in{}A_1,\dots,x_n\in{}A_n\}$.
\end{definition}

It is sometimes useful to give a name to the elements of a tuple
without referring to their index. In such a case, a tuple is called a
record where each element, called a field, has been given an explicit
name. This formalism is useful to represent rather complex data
structures. For instance, say that we want to represent the set of
humans by a triplet composed of the size, weight, and eye color of a
given human.  We can define this set as the set of triplet
$\mathbb{R}\times\mathbb{R}\times\{green,blue,brown\}$. If we want to
give a concrete name to the elements of the triplet, we can
equivalently define such a triplet as a record, written
${<}size,weight,eye{>}$, where $size\in\mathbb{R}$,
$weight\in\mathbb{R}$ and $eye\in\{green,blue,brown\}$.

\begin{definition}[Disjoint union]
  $A\sqcup{}B$ denotes the set formed by the disjoint union of set $A$
  and set $B$. The disjoint union is obtained by adjoining an index
  $i$ to the elements of $A$ and an index $j$ to the elements of $B$
  such that $i\neq{}j$. Then, the two sets of couples are joined
  together to build the disjoint union of $A$ and $B$. For instance,
  consider that $A=\{a,b,c\}$ and $B=\{a,b\}$. To obtain the disjoint
  union $A\sqcup{}B$, we create the two sets
  $A_i=\{(i,a),(i,b),(i,c)\}$ and $B_i=\{(j,a),(j,b)\}$, and then join
  the sets together
  s.t. $A\sqcup{}B=\{(i,a),(i,b),(i,c),(j,a),(j,b)\}$.
\end{definition}

When the two sets $A$ and $B$ are disjoint, i.e. $A\cap{}B=\emptyset$,
then $A\sqcup{}B$ is isomorphic to $A\cup{}B$. To stress the fact that
we are building a set from the union of two disjoint sets, we prefer
to use the disjoint union operator. For instance, we write
$\mathbb{N}\sqcup{}\{\infty\}$, instead of
$\mathbb{N}\cup{}\{\infty\}$, to denote the set of values ranging from
the set of natural numbers with the addition of the infinite value
$\infty$.

\begin{definition}[Powerset]
  $\mathcal{P}(A)$ denotes the powerset of $A$ defined by all the
  possible subsets formed with the elements of set $A$, i.e.
  $\mathcal{P}(A)=\{X~\vert~X\subseteq{}Y\}$.
\end{definition}

\paragraph{Relations and functions}

\begin{definition}[Relation]
  A binary relation $R$ between two sets $X$ and $Y$ is a subset of
  the set of pairs $X\times{}Y$, i.e. $R\subseteq{}X\times{}Y$, or an
  element of the powerset $\mathcal{P}(X\times{}Y)$,
  i.e. $R\in\mathcal{P}(X\times{}Y)$. We write $R(x,y)$ to denote
  $(x,y)\in{}R$. We generalize the definition to n-ary relations. An
  n-ary relation between sets $X_0,\dots,X_n$ is a subset of the set
  of n-tuples $X_0\times\dots\times{}X_n$,
  i.e. $R\subseteq{}X_0\times\dots\times{}X_n$, or an element of the
  powerset $\mathcal{P}(X_0\times\dots\times{}X_n)$,
  i.e. $R\in\mathcal{P}(X_0\times\dots\times{}X_n)$. We write
  $R(x_0,\dots,x_n)$ to denote $(x_0,\dots,x_n)\in{}R$.
\end{definition}

\begin{definition}[Partial function]
  A partial function $f$ from set $X$ to set $Y$ is a binary relation
  from $X$ to $Y$ verifying that
  $\forall{}x\in{}X,y,y'\in{}Y,~(x,y)\in{}f\land{}(x,y')\in{}f\Rightarrow{}y=y'$,
  i.e. $x$ appears at most once as the first element of a pair in $f$.
  We note $f\in{}X\nrightarrow{}Y$ to denote a partial function from
  $X$ to $Y$. The set of the first elements of the pairs defined in
  $f$ is called the \emph{domain} of $f$. We write it
  $\mathtt{dom}(f)=\{x~\vert~\exists{}y~s.t.(x,y)\in{}f\}$.  When
  there is no ambiguity, and given an $x\in{}X$ and
  $f\in{}X\nrightarrow{}Y$, we write $x\in{}f$ as a shorthand to
  $x\in\mathtt{dom}(f)$.
\end{definition}

\begin{definition}[Application]
  A total function $a$, or application, from $X$ to $Y$ is a partial
  function verifying that all the elements of $X$ appear as the first
  element of a pair in $a$, i.e. for all $x\in{}X$, there exists
  $y\in{}Y$ such that $(x,y)\in{}a$. In other words, the domain of an
  application from $X$ to $Y$ is equal to the set $X$. We note
  $a\in{}X\rightarrow{}Y$ to denote an application from $X$ to $Y$.
\end{definition}

\subsection{Rule-based definition of sets}
\label{sec:rule-based-def}

All along this memoir, we define sets (especially relations) with rule
instances, also called inference rules or judgments. A rule instance
can take the following forms:

\begin{center}
\begin{prooftree}[template=\inserttext]
  \infer0{ $C$ }
\end{prooftree}
~or~
\begin{prooftree}[template=\inserttext]
  \hypo{$P_1,\dots,P_n$}
  \infer1{ $C$ }
\end{prooftree}
\end{center}

The left form of rule instance is called an axiom.  In the right form
of rule instance, $P_1,\dots,P_n$ are the premises of the rule and $C$
is the conclusion of the rule.

\begin{definition}[Rule instances]
  We define a set $R$ of rule instances as a set of pairs of the form
  $(P/C)$ where $P$ is a finite (possibly empty) set of premises and
  $C$ is an element called the conclusion. A pair $(P/C)$ is a rule
  instance.
\end{definition}

Rule instances define a way to build \textit{derivation trees}. A
derivation of $C$ takes either the form of an axiom,
i.e. \begin{prooftree}[template=\inserttext] \infer0{ $C$ }
\end{prooftree}, or of a tree with $C$ as a root and with branches
composed of the derivation trees of the premises, i.e.

\begin{center}
  \begin{prooftree}[template=\inserttext]
    \hypo{}
    \ellipsis{}{}
    \infer1{$P_1$}

    \hypo{$\dots$}

    \hypo{}
    \ellipsis{}{}
    \infer1{$P_n$}
    
    \infer3{ $C$ }
  \end{prooftree}
\end{center}

Given a set $R$ of rule instances, we define the set $A$ such that if
$(\emptyset/C)\in{}R$ then $C\in{}A$, and if
$(\{P_1,\dots,P_n\}/C)\in{}R$, then if there exists a derivation for
all premises $P_1,\dots,P_n$ then $C\in{}A$. In fact, the set $R$ of
rule instances define the properties that must be verified by the
elements of set $A$. There exists an infinity of sets $A$ that verify
the properties outlined by the rule instances $R$. Thus, we define the
set of elements defined by the rule instances $R$ as the least set
verifying the properties outlined by the rules.  For instance, the two
following rules, named rules \textsc{Ev0} and \textsc{Ev2}, define the
set of even natural numbers:

\begin{table}[H]
  \centering
  
  \begin{tabular}{@{}l}
    {\fontsize{10}{13}\selectfont\textsc{Ev0}} \\
    {\begin{prooftree}[template=\inserttext]
        \infer0{ $IsEven(0)$ }
      \end{prooftree}} \\
  \end{tabular}
  \hspace{50pt}
  \begin{tabular}{@{}l}
    {\fontsize{10}{13}\selectfont\textsc{Ev2}} \\
    {\begin{prooftree}[template=\inserttext]
        \hypo{$IsEven(n-2)$}
        \infer1{ $IsEven(n)$ }
      \end{prooftree}} \\
  \end{tabular}
\end{table}

The rule \textsc{Ev0} states as an axiom that $0$ is an even number;
the rule \textsc{Ev2} states that for all natural number $n$, $n$ is
an even number if one can derive that fact that $n-2$ is an even
number. Thus, we can derive from the previous rules that $4$ is an
even number by building the following derivation tree:

\begin{table}[H]
  \centering
  \begin{prooftree}[template=\inserttext]
    \infer0[\textsc{Ev0}]{$IsEven(0)$}
    \infer1[\textsc{Ev2}]{$IsEven(2)$}
    \infer1[\textsc{Ev2}]{ $IsEven(4)$ }
  \end{prooftree}
\end{table}

Starting from $IsEven(4)$, we can apply the \textsc{Ev2} rule to
derive $IsEven(2)$. Then, another application of the \textsc{Ev2} rule
leads to $IsEven(0)$, and we can close the derivation branch by
applying the \textsc{Ev0} rule. Here, the only branch of the tree has
reached an axiom, and thus the derivation tree is finite. To further
illustrate the use of rule instances in the definition of a set, let
us consider the following minimal language of arithmetic expressions
expressed in the Backus-Naur form:

\begin{table}[H]
  \centering
  \begin{tabular}{lll}
    $e$ & $::=$ & $n~|~id~|~e_0+e_1$ \\
  \end{tabular}
\end{table}

Here, $n$ ranges over the set of natural numbers $\mathbb{N}$; $id$
ranges over the set $\mathtt{string}$ of non-empty strings (i.e. it is
the set of identifiers). To evaluate the arithmetic expressions, we
need a state $s\in\mathtt{string}\nrightarrow{}\mathbb{N}$ that maps
each variable identifier to a natural number value. We assume that
only a certain set of declared identifiers can appear in an arithmetic
expression. Thus, the state is a partial function from the set of
non-empty strings to the set of natural numbers. We define the
evaluation relation for the arithmetic expressions with the three
following rules:

\begin{table}[H]
  \begin{tabular}{l}
    {\fontsize{10}{13}\selectfont\textsc{Nat}} \\
    {\begin{prooftree}[template=\inserttext]
      \infer0{ $s\vdash{}n\rightarrow{}n$ }
    \end{prooftree}} \\
  \end{tabular}
  \hspace{10pt}
  \begin{tabular}{l}
    {\fontsize{10}{13}\selectfont\textsc{Var}} \\
    {\begin{prooftree}[template=\inserttext]
        \infer0[$id\in{}\mathtt{dom}(s)$]{ $s\vdash{}id\rightarrow{}s(id)$ }
      \end{prooftree}} \\
  \end{tabular}
  \hspace{10pt}
  \begin{tabular}{l}
    {\fontsize{10}{13}\selectfont\textsc{Add}} \\
    {\begin{prooftree}[template=\inserttext]
        \hypo{ $s\vdash{}e_0\rightarrow{}n$ }
        \hypo{ $s\vdash{}e_1\rightarrow{}m$ }
        \infer2{ $s\vdash{}e_0+e_1\rightarrow{}n+m$ }
      \end{prooftree}}
  \end{tabular}
\end{table}

Here, the evaluation relation is a subset of the set of triplets
$(\mathtt{string}\nrightarrow\mathbb{N})\times{}e\times\mathbb{N}$. In
the rule instances defining the evaluation relation, the $\vdash$
symbol (pronounced \emph{thesis}) means that the left part implies the
right part, or it is involved in the evaluation of the right part.
For instance, the second rule can be read: in the context of state
$s$, $id$ evaluates to $s(id)$ if $id\in{}\mathtt{dom}(s)$. When the
\emph{context} is not involved in the evaluation of the syntactic
constructs on the right side of the $\vdash$ symbol, we remove the
context and the $\vdash$ from the rule instances. For example, we can
define to the \textsc{Nat} rule by:

\begin{table}[H]
  \centering
  \begin{tabular}{l}
    {\fontsize{10}{13}\selectfont\textsc{Nat}} \\
    {\begin{prooftree}[template=\inserttext]
        \infer0{ $n\rightarrow{}n$ }
      \end{prooftree}} \\
  \end{tabular}
\end{table}

\noindent{}as the state $s$ in not involved in the evaluation of
expressions that are natural numbers. 

Note that in the \textsc{Var} rule, there appears an extra statement,
at the right of the judgment line, called a \emph{side
  condition}. This is an extra condition that must hold with all the
premises of the rule instance, but which does not generate a
derivation tree of its own.

Finally, here is an example of a derivation tree for the evaluation of
the expression $x+(y+1)$ in the context of state $\{(x,1),(y,2)\}$:

\begin{table}[H]
  \centering
  \begin{tabular}{l}
    {\begin{prooftree}[template=\fontsize{11}{13}\selectfont\inserttext]
        \infer[left label={\textsc{Var}}]0[$x\in\{x,y\}$]{ $\{(x,1),(y,2)\}\vdash{}x\rightarrow{}1$ }
        
        \infer[left label={\textsc{Var}}]0[$y\in\{x,y\}$]{ $\{(x,1),(y,2)\}\vdash{}y\rightarrow{}2$ }
        \infer0[\textsc{Nat}]{ $1\rightarrow{}1$ }
        \infer2[\textsc{Add}]{ $\{(x,1),(y,2)\}\vdash{}y+1\rightarrow{}3$ }
        
        \infer2[\textsc{Add}]{
            $\{(x,1),(y,2)\}\vdash{}x+(y+1)\rightarrow{}4$
        }
      \end{prooftree}} \\
  \end{tabular}
\end{table}

Here again, all the branches of the derivation tree have reached
axioms, and thus\\ $\{(x,1),(y,2)\}\vdash{}x+(y+1)\rightarrow{}4$ is a
member of the evaluation relation of arithmetic expressions. It states
that the expression $x+(y+1)$ evaluates to $4$ in the state
$\{(x,1),(y,2)\}$.

The evaluation relation can also include rule instances defining error
cases. For instance, we can add an extra rule to the definition of the
evaluation relation for arithmetic expressions; the following rule
states that an arithmetic expression that is an unreferenced variable
in state $\sigma$ results in an error:

\begin{table}[H]
  \centering
  \begin{tabular}{l}
    {\fontsize{10}{13}\selectfont\textsc{UnrefVar}} \\
    {\begin{prooftree}[template=\inserttext]
        \infer0[$id\notin{}\mathtt{dom}(s)$]{ $s\vdash{}id\rightarrow{}\mathtt{err}$ }
      \end{prooftree}} \\
  \end{tabular}
\end{table}

The special value \texttt{err} is defined to represent error
cases. Thus, the evaluation relation defines a subset of triplets
$(\mathtt{string}\nrightarrow\mathbb{N})\times{}e\times(\mathbb{N}\sqcup{}\{\mathtt{err\}})$.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../main"
%%% End:
