\subsection{Intuitionistic first order logic}
\label{sec:fol-intuitionistic}

The intuitionistic first-order logic \cite{Moschovakis2018}
constitutes our framework for the expression and the interpretation of
logical formulas.  The language to express logical formulas is the
same between classical and intuitionistic first-order logic. A logical
formula is either:

\begin{itemize}
\item $\bot$ (bottom), the always false formula, or $\top$ (top), the
  always true formula
\item a predicate (i.e. an atomic formula). A predicate $P$ possibly
  takes $n$ parameters as inputs and is interpreted to either true,
  represented by the $\top$ symbol, or false, represented by the
  $\bot$ symbol. We write $P(x_0,\dots,x_n)$ to denote an $n$-ary
  predicate $P$ applied to the inputs $x_0,\dots,x_n$.

\item the composition of two subformulas with one of the following
  binary operators: the conjunction $\land$, the disjunction $\lor$, the
  implication $\Rightarrow$, the double implication $\Leftrightarrow$

  
\item the composition of one subformula with the negation operator
  $\neg$
  
\item a subformula prefixed by the universal quantifier $\forall$ or
  the existantial quantifier $\exists$. For instance, the formula
  $\forall{}x.P(x)$ denotes the atomic formula $P(x)$ where the
  parameter $x$ is a universally quantified variable of the
  formula. As a shorthand notation, we write $\forall{}x,y,z.\dots$ to
  denote $\forall{}x,\forall{}y,\forall{}z.\dots$. The same stands for
  the existantial quantifier $\exists$.
\end{itemize}

The difference between the classical first-order logic and the
intuitionistic one relies in the absence of the \emph{law of the
  excluded middle} in the latter logic. In classical logic, the
\emph{law of the excluded middle} considers that a formula can always
be either interpreted as true or false, i.e. a formula is always
\emph{decidable} regardless the valuation of its inputs. In
intuitionistic logic, such an assumption is discarded. Thus, a formula
of the intuitionistic logic can be \emph{undecidable}, i.e. given a
valuation of its input, one can not always state that the formula is
true or false. This is implication is that one as to exhibit a
\emph{explicitly-built} proof to show that a given formula is
true. One can not rely on the law of excluded middle to perform a
proof by contradiction. As so, the intuitionistic logic is said to be
\emph{constructive} in the sense that one as to \emph{construct} a
concrete proof object to show that a formula is true. The
intuitionistic first-order logic is built in the \coq{} proof
assistant. Thus, a logic formula expressed with the \coq{} proof
assistant is an intuitionistic formula by default. For this reason, we
choose the intuitionistic first-order logic as our mathematical
framework for the expression of logic formulas.

In what follows, we often give the definition of a predicate by
relating its semantics to the semantics of an underlying formula. For
instance, we define the predicate $IsEven(n)$, for all
$n\in{}\mathbb{N}$, as follows:
$IsEven(n)\equiv{}\exists{}k\in\mathbb{N}~s.t.~2k=n$.

\subsection{Set theory}
\label{sec:set-theory}

In this thesis, we use set theory as the base formalism for all our
mathematical definitions and proofs. In set theory, a set represents a
group of elements called the members of the set. For every set $X$, we
write $x\in{}X$ to denote that the element $x$ is a member of set
$X$. We note $X\subseteq{}Y$ the fact that a set $X$ is a subset of
set $Y$ such that for all $x$ if $x\in{}X$ then $x\in{}Y$.  From here,
there are multiple ways to define a set.

\paragraph{Extensional definition} A set is defined by
\emph{extension} with the enumeration of all its members. For
instance, $\{1,0,-1\}$, $\{a,b,c\}$ or $\{p_0,\dots,p_n\}$ are all
sets defined by extension.

\paragraph{Intensional definition}
The intensional definition of a set specifies a given property
verified by all the members of the set. For instance, here is the
intensional definition of the set of even numbers:
$\{n\in\mathbb{N}~\vert~\exists{}k\in\mathbb{N}~s.t.~n=2k\}$ or
$\{n\in\mathbb{N}~\vert~IsEven(n)\}$.

\paragraph{Set operators}

Set theory also defines some operators to compose sets together. Given
two sets $A$ and $B$, the following sets are formed:

\begin{itemize}
\item $A\cup{}B$ denotes the set formed by the union of the members of
  $A$ and the members of $B$,
  i.e. $A\cup{}B=\{x~\vert~x\in{}A\lor{}x\in{}B\}$.
  
\item $A\cap{}B$ denotes the set formed by the intersection of set $A$
  and $B$, i.e. $A\cap{}B=\{x~\vert~x\in{}A\land{}x\in{}B\}$.
  
\item $A\setminus{}B$ denotes the set formed by the elements of set
  $A$ that are not elements of set $B$ (the difference between set $A$
  and $B$), i.e. $A\setminus{}B=\{x~\vert~x\in{}A\land{}x\notin{}B\}$.

\item $A\times{}B$ denotes the cartesian product between the elements
  of set $A$ and set $B$, i.e. the set of all ordered pairs defined by
  $\{(x,y)~\vert~x\in{}A\land{}y\in{}B\}$. We generalize the
  definition to build the set of $n$-tuples
  $A_0\times{}A_1\times\dots\times{}A_n$ defined by
  $\{(x_0,
  (x_1,\dots(\dots,x_n)~\vert~x_0\in{}A_0,x_1\in{}A_1,\dots,x_n\in{}A_n\}$.
  It is sometimes useful to give a name to the elements of a tuple
  without refering to their index. In such a case, a tuple is called a
  record where each element, called a field, has been given an
  explicit name. This formalism is useful to represent rather complex
  data structures. For instance, say that we want to represent the set
  of humans by a triplet composed of the size, weight, and eye color.
  We can define this set as the set of triplet
  $\mathbb{R}\times\mathbb{R}\times\{green,blue,brown\}$. If we want
  to give a concrete name to the elements of the triplet, we can
  equivalently define such a triplet as a record, written
  ${<}size,weight,eye{>}$, where $size\in\mathbb{R}$,
  $weight\in\mathbb{R}$ and $eye\in\{green,blue,brown\}$.
  
\item $A\sqcup{}B$ denotes the set formed by the disjoint union of set
  $A$ and set $B$. The disjoint union is obtained by adjoining an
  index $i$ to the elements of $A$ and an index $j$ to the elements of
  $B$ such that $i\neq{}j$. Then, the two sets of couples are joined
  together to build the disjoint union of $A$ and $B$. For instance,
  consider that $A=\{a,b,c\}$ and $B=\{a,b\}$. To obtain the disjoint
  union $A\sqcup{}B$, we create the two sets
  $A_i=\{(i,a),(i,b),(i,c)\}$ and $B_i=\{(j,a),(j,b)\}$, and then join
  the sets together
  s.t. $A\sqcup{}B=\{(i,a),(i,b),(i,c),(j,a),(j,b)\}$. When the two
  sets $A$ and $B$ are disjoint, i.e. $A\cap{}B=\emptyset$, then
  $A\sqcup{}B$ is isomorphic to $A\cup{}B$. To stress the fact that we
  are building a set from the union of two disjoint set, we prefer to
  use the disjoint union operator. For instance, we write
  $\mathbb{N}\sqcup{}\{\infty\}$, instead of
  $\mathbb{N}\cup{}\{infty\}$, to denote the set of values ranging
  from the set of natural numbers with the addition of the infinite
  value.

\item $\mathcal{P}(A)$ denotes the powerset of $A$ defined by all the
  possible subsets formed with the elements of set $A$, i.e.
  $\mathcal{P}(A)=\{X~\vert~X\subseteq{}Y\}$.
\end{itemize}

\paragraph{Relations and functions}

A binary relation $R$ between two sets $X$ and $Y$ is a subset of the
set of pairs $X\times{}Y$, i.e. $R\subseteq{}X\times{}Y$, or an
element of the powerset $\mathcal{P}(X\times{}Y)$,
i.e. $R\in\mathcal{P}(X\times{}Y)$. We write $R(x,y)$ to denote
$(x,y)\in{}R$. We generalize the definition to n-ary relations. A
n-ary relation between sets $X_0,\dots,X_n$ is a subset of the set of
n-tuples $X_0\times\dots\times{}X_n$,
i.e. $R\subseteq{}X_0\times\dots\times{}X_n$, or an element of the
powerset $\mathcal{P}(X_0\times\dots\times{}X_n)$,
i.e. $R\in\mathcal{P}(X_0\times\dots\times{}X_n)$. We write
$R(x_0,\dots,x_n)$ to denote $(x_0,\dots,x_n)\in{}R$. \\

A partial function $f$ from set $X$ to set $Y$ is a binary relation
from $X$ to $Y$ verifying that
$\forall{}x\in{}X,y,y'\in{}Y,~(x,y)\in{}f\land{}(x,y')\in{}f\Rightarrow{}y=y'$,
i.e. $x$ appears at most once as the first element of a pair in $f$.
We note $f\in{}X\nrightarrow{}Y$ to denote a partial function from $X$
to $Y$. The set of the first elements of the pairs defined in $f$ is
called the \emph{domain} of $f$, written $\mathtt{dom}(f)$. We write
it $\mathtt{dom}(f)=\{x~\vert~\exists{}y~s.t.(x,y)\in{}f\}$.

A total function $a$, or application, from $X$ to $Y$ is a partial
function verifying that all the elements of $X$ appear as the first
element of a pair in $a$, i.e. for all $x\in{}X$, there exists
$y\in{}Y$ such that $(x,y)\in{}a$. We note $a\in{}X\rightarrow{}Y$ to
denote an application from $X$ to $Y$.

\subsection{Rule-based definition of sets}
\label{sec:rule-based-def}

While describing the operational semantics of a subset of the \vhdl{}
language in Chapter~\ref{chap:hvhdl}, we define some of the sets (e.g,
simulation relations) with rule instances, also called inference rules
or judgments. A rule instance, defining the members of a set $A$, can
take the following form:

\begin{center}
\begin{prooftree}[template=\inserttext]
  \infer0{ $C$ }
\end{prooftree}
~or~
\begin{prooftree}[template=\inserttext]
  \hypo{$P_1,\dots,P_n$}
  \infer1{ $C$ }
\end{prooftree}
\end{center}

The left form of rule instance is called an axiom; it states that
$C\in{}A$.  The rule instance \begin{prooftree}[template=\inserttext]
  \hypo{$P_1,\dots,P_n$} \infer1{ $C$ }
\end{prooftree} states $C\in{}A$ if $P_1,\dots,P_n$ hold. Also, we say
that $C$ is derivable, if $P_1,\dots,P_n$ are derivable.
$P_1,\dots,P_n$ are the premises of the rule, and $C$ is the
conclusion of the rule. The premises $P_1,\dots,P_n$ hold if there
exists a \emph{finite} derivation tree for each one of them. A
\emph{finite} derivation tree is obtained by applying the rule
instances defining the set until all branches of the derivation reach
axioms. For instance, the two following rules define the $IsEven$
unary relation that states that a given natural number is even:

\begin{table}[H]
  \centering
\begin{prooftree}[template=\inserttext]
  \infer0{ $IsEven(0)$ }
\end{prooftree}
\hspace{50pt}
\begin{prooftree}[template=\inserttext]
  \hypo{$IsEven(n-2)$}
  \infer1{ $IsEven(n)$ }
\end{prooftree}
\end{table}

The first rule states as an axiom that $0$ is an even number; the
second states that for all natural number $n$, $n$ is an even number
if one can derive that fact that $n-2$ is an even number. Thus, we can
derive from the previous rules that $4$ is an even number by building
the following derivation tree:

\begin{table}[H]
  \centering
  \begin{prooftree}[template=\inserttext]
    \infer0{$IsEven(0)$}
    \infer1{$IsEven(2)$}
    \infer1{ $IsEven(4)$ }
  \end{prooftree}
\end{table}

Here, all branches of the tree has reached an axiom, and thus the
derivation tree is finite. The further illustrate the use of rule
instances in the definition of a set, let us consider the following
minimal language of arithmetic expressions expressed in the
Backus-Naur form:

\begin{table}[H]
  \centering
  \begin{tabular}{lll}
    $e$ & $::=$ & $n~|~id~|~e_0+e_1$ \\
  \end{tabular}
\end{table}

$n$ ranges over the set of natural numbers $\mathbb{N}$; $id$ ranges
over the set $\mathtt{string}$ of non-empty strings (i.e. it is the
set of identifiers). To evaluation the arithmetic expressions, we need
a state $s\in\mathtt{string}\rightarrow{}\mathbb{N}$ that maps each
variable identifier to a natural number value. We define the
evaluation relation for these arithmetic expressions with the three
following rules:

\begin{table}[H]
  \begin{tabular}{l}
    {\fontsize{10}{13}\selectfont\textsc{Nat}} \\
    {\begin{prooftree}[template=\inserttext]
      \infer0{ $s\vdash{}n\rightarrow{}n$ }
    \end{prooftree}} \\
  \end{tabular}
  \hspace{10pt}
  \begin{tabular}{l}
    {\fontsize{10}{13}\selectfont\textsc{Var}} \\
    {\begin{prooftree}[template=\inserttext]
        \infer0[$id\in{}\mathtt{dom}(s)$]{ $s\vdash{}id\rightarrow{}s(id)$ }
      \end{prooftree}} \\
  \end{tabular}
  \hspace{10pt}
  \begin{tabular}{l}
    {\fontsize{10}{13}\selectfont\textsc{Add}} \\
    {\begin{prooftree}[template=\inserttext]
        \hypo{ $s\vdash{}e_0\rightarrow{}n$ }
        \hypo{ $s\vdash{}e_1\rightarrow{}m$ }
        \infer2{ $s\vdash{}e_0+e_1\rightarrow{}n+m$ }
      \end{prooftree}}
  \end{tabular}
\end{table}

Here, the evaluation relation is a subset of the set of triplets
$(\mathtt{string}\rightarrow\mathbb{N})\times{}e\times\mathbb{N}$. In
the rule instances defining the evaluation relation, the $\vdash$
symbol (pronounced \emph{thesis}) stresses that the left part implies
the right part, or it is involved in the evaluation of the right part.
For instance, the second rule can be read: in the context of state
$s$, $id$ evaluates to $s(id)$. Thus, when the \emph{context} is not
involved in the evaluation of the syntactic constructs at the right
side of the $\vdash$ symbol, we permit ourselves to remove the context
and the $\vdash$ from the rule instances. For example, we can define
to the \textsc{Nat} rule by

\begin{table}[H]
  \centering
  \begin{tabular}{l}
    {\fontsize{10}{13}\selectfont\textsc{Nat}} \\
    {\begin{prooftree}[template=\inserttext]
        \infer0{ $n\rightarrow{}n$ }
      \end{prooftree}} \\
  \end{tabular}
\end{table}

\noindent{}as the state $s$ in not involved in the evaluation of
expressions that are natural numbers. 

Note that in the \textsc{Var} rule, there appears an extra statement,
at the right of the judgment line, called a \emph{side
  condition}. This is an extra condition that must hold with all the
premises of the rule instance, but which is does not generate a
derivation tree of its own.

Finally, here is an example of a derivation tree for the evaluation of
the expression $x+(y+1)$ in the context of state $\{(x,1),(y,2)\}$:

\begin{table}[H]
  \centering
  \begin{tabular}{l}
    {\begin{prooftree}[template=\fontsize{11}{13}\selectfont\inserttext]
        \infer[left label={\textsc{Var}}]0[$x\in\{x,y\}$]{ $\{(x,1),(y,2)\}\vdash{}x\rightarrow{}1$ }
        
        \infer[left label={\textsc{Var}}]0[$y\in\{x,y\}$]{ $\{(x,1),(y,2)\}\vdash{}y\rightarrow{}2$ }
        \infer0[\textsc{Nat}]{ $1\rightarrow{}1$ }
        \infer2[\textsc{Add}]{ $\{(x,1),(y,2)\}\vdash{}y+1\rightarrow{}3$ }
        
        \infer2[\textsc{Add}]{
            $\{(x,1),(y,2)\}\vdash{}x+(y+1)\rightarrow{}4$
        }
      \end{prooftree}} \\
  \end{tabular}
\end{table}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../main"
%%% End:
