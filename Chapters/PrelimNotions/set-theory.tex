In this section, we introduce classical first-order logic and the
Zermelo-Fraenkel (ZF) set theory which combination constitutes the
base formalism for all our mathematical definitions, and our framework
for the expression and the interpretation of logical formulas.

\subsection{Classical first-order logic}
\label{sec:fol-classical}

In this section, we define the syntax of the first-order logic. Here,
we already use concepts and notations that belong to set theory; set
theory will be presented in the following section.  For now, the
reader has only to consider the \textit{intuitive} definition of a set
as a collection of elements, and a function as an entity that relates
each element of a set to a unique element of another set.

To define the syntax of the first-order logic, let us first define:

\begin{itemize}
\item the set $\mathcal{V}$ of variables x, y, etc.
\item the set $\mathcal{S}_\mathcal{F}$ of function symbols f, g, etc.
\item the set $\mathcal{S}_\mathcal{P}$ of predicate symbols P, Q,
  etc.
\end{itemize}

Let us also consider a function
$a\in{}\mathcal{S}_\mathcal{F}\cup{}\mathcal{S}_\mathcal{P}\rightarrow\mathbb{N}$
that associates a given function or predicate symbol to an arity,
i.e. the number of parameters of the function or the predicate. E.g,
if $f(x,y)$ with $f\in{}\mathcal{S}_\mathcal{F}$ then $a(f)=2$; if
$P(x,y,z)$ with $P\in\mathcal{S}_\mathcal{P}$ then $a(P)=3$. Constants
are functions of arity 0, i.e. with no parameter.

The syntax of classical first-order logic \cite{Moschovakis2018} is
divided between \textit{terms} and \textit{formulas}.  We define a
term of the classical first-order logic with the following BNF entry:

\begin{center}
  $t::=v~\vert{}~f(t_1,\dots,t_n)$
\end{center}

This entry states that a term is either a variable
$v\in{}\mathcal{V}$, or a function symbol
$f\in\mathcal{S}_\mathcal{F}$ of arity $n$ with terms $t_1,\dots,t_n$
as inputs.

We define a formula of the classical
first-order logic with the following BNF entry:

\begin{center}
  $\mathcal{F}::=\bot~\vert~\top~\vert~P(t_1,\dots,t_n)~\vert~\mathcal{F}\land\mathcal{F}$
  $~\vert~\mathcal{F}\lor\mathcal{F}~\vert~\mathcal{F}\Rightarrow\mathcal{F}~\vert~\mathcal{F}\Leftrightarrow\mathcal{F}$
  $~\vert~\neg\mathcal{F}$
  $~\vert~\forall{}x,\mathcal{F}~\vert~\exists{}x,\mathcal{F}$
\end{center}

This entry states that a formula is either:

\begin{itemize}
\item $\bot$ (bottom), the always \textit{false} formula, or $\top$
  (top), the always \textit{true} formula
\item a predicate $P(t_1,\dots,t_n)$ (i.e. an atomic formula) of arity
  $n$, where $P\in\mathcal{S}_\mathcal{P}$ with terms $t_1,\dots,t_n$
  as inputs.
\item the composition of two subformulas with one of the following
  binary operators: the conjunction $\land$, the disjunction $\lor$,
  the implication $\Rightarrow$, the double implication
  $\Leftrightarrow$
  
\item the composition of one subformula with the negation operator
  $\neg$
  
\item a subformula prefixed by the universal quantifier $\forall$ or
  the existential quantifier $\exists$. For instance, the formula
  $(\forall{}x,P(x))$ denotes the atomic formula $P(x)$ where the
  parameter $x$ is a universally quantified variable of the
  formula. As a shorthand notation, we write $\forall{}x,y,z.\dots$ to
  denote $\forall{}x,\forall{}y,\forall{}z.\dots$. The same stands for
  the existential quantifier $\exists$. Variables that are introduced
  in a logical formula by one of the previous quantifiers are called
  the \textit{bound} variables of the formula. Variables that appear
  in a logical formula without being introduced by a quantifier are
  called \textit{free} variables. For instance, in the logical formula
  $(\forall{}x,~P(x)\land{}Q(y))$, $x$ is a bound variable and $y$ is
  a free variable of the formula.
\end{itemize}

In this thesis, our formulas are interpreted as formulas of the
\textit{classical} logic \cite{Shapiro2021}. Thus, during a proof, we
can appeal to the \textit{law of excluded middle} to reason on the
truth value of a given formula.

% The difference between the classical first-order logic and the
% intuitionistic one relies in the absence of the \emph{law of the
%   excluded middle} in the latter logic. In classical logic, the
% \emph{law of the excluded middle} considers that a formula can always
% be either interpreted as true or false, i.e. a formula is always
% \emph{decidable} regardless the valuation of its inputs. In
% intuitionistic logic, such an assumption is discarded. Thus, a formula
% of the intuitionistic logic can be \emph{undecidable}, i.e. given a
% valuation of its input, one can not always state that the formula is
% true or false. The consequence is that one as to exhibit a
% \emph{explicitly-built} proof to show that a given formula is
% true. One can not rely on the law of excluded middle to perform a
% proof by contradiction. As so, the intuitionistic logic is said to be
% \emph{constructive} in the sense that one as to \emph{construct} a
% concrete proof object to show that a formula is true. The
% intuitionistic first-order logic is built in the \coq{} proof
% assistant. Thus, a logic formula expressed with the \coq{} proof
% assistant is an intuitionistic formula by default. For this reason, we
% choose the intuitionistic first-order logic as our mathematical
% framework for the expression of logic formulas.

% In what follows, we often give the definition of a predicate by
% relating its semantics to the semantics of an underlying formula. For
% instance, we define the predicate $IsEven(n)$, for all
% $n\in{}\mathbb{N}$, as follows:
% $IsEven(n)\equiv{}\exists{}k\in\mathbb{N}~s.t.~2k=n$.

\subsection{ZF Set theory}
\label{sec:set-theory}

In this thesis, we use the ZF set theory as the base formalism for all
our mathematical definitions and proofs.

In the ZF set theory, a set represents a group of elements called the
members of the set. For every set $A$, we write $a\in{}A$ to denote
that the element $a$ is a member of set $A$. The \textit{membership}
property is a basic set-theoretic property. Now, let us define the
axioms of the ZF set theory.

\begin{axiom}[Existence]
  \label{ax:existence}
  There exists a set which has no elements,
  i.e. $\exists{}A,\forall{}a,a\notin{}X$.
\end{axiom}

We call the \textit{empty set} the unique set with no element, written
$\emptyset$.

\begin{axiom}[Extensionality]
  \label{ax:extensionality}
  If every element of $A$ is an element of $B$, and vice-versa, then
  $A=B$,
  i.e.
  $\forall{}A,B,x,~(x\in{}A\Leftrightarrow{}x\in{}B)\Rightarrow{}A=B$.
\end{axiom}

\begin{axiom}[Schema of comprehension]
  \label{ax:schema-of-compr}
  Let $P(x)$ be a property of $x$. For all set $A$, there exists a set
  $B$ such that $x\in{}B$ if and only if $x\in{}A$ and $P(x)$
  holds. I.e.
  $\forall{}A,B,x,~x\in{}B\Leftrightarrow{}x\in{}A\land{}P(x)$.
\end{axiom}

\begin{axiom}[Pair]
  \label{ax:pair}
  For all set $A$ and $B$, there exist a set $C$ such that $x\in{}C$
  if and only if $x=A$ and $x=B$. I.e.
  $\forall{}A,B,\exists{}C,\forall{}x,~(x\in{}C\Leftrightarrow{}x=A\lor{}x=B)$.
\end{axiom}

More intuitively, Axiom~\ref{ax:pair} states that if $A$ and $B$ are
sets then their corresponding pair $C$ is also a set.

\begin{axiom}[Union]
  \label{ax:union}
  For all set $A$ having sets as elements, there exists a set $C$
  corresponding to the union of the elements of
  $A$. I.e. $\forall{}A,\exists{}U,~x\in{}U\Leftrightarrow\exists{}B,~B\in{}A\land{}x\in{}B$.
\end{axiom}

We write $A\subseteq{}B$ the fact that a set $A$ is a subset of set
$B$ such that for all $x$ if $x\in{}A$ then $x\in{}B$.

We write $A\cup{}B$ the set formed by the union of the members of $A$
and the members of $B$,
i.e. $\forall{}x,x\in{}A\cup{}B\Leftrightarrow{}x\in{}A\lor{}x\in{}B$.

\begin{axiom}[Infinity]
  \label{ax:infty}
  There exists a set $A$ such that the empty set belongs to $A$ and
  for all $x$ such that $x\in{}A$ then $x\cup\{x\}\in{}A$. I.e.
  $\exists{}A,\emptyset\in{}A\land(\forall{}x,~x\in{}A\Rightarrow{}x\cup\{x\}\in{}A)$.
\end{axiom}

\begin{axiom}[Power set]
  \label{ax:pow-set}
  For all set $A$, there exists a set $B$ such that for all set $X$,
  $X\in{}B$ if and only if
  $X\subseteq{}A$. I.e.
  $\forall{}A,\exists{}B,\forall{}X,(X\in{}B\Leftrightarrow{}X\subseteq{}A)$.
\end{axiom}

\begin{axiom}[Schema of replacement]
  \label{ax:sch-of-repl}
  Let $P(x,y)$ be a property such that for all $x$ there exists a
  unique $y$ such that $P(x,y)$ holds. For all set $A$, there exists a
  set $B$ such that for all $x\in{}A$, there exists $y\in{}B$ for
  which $P(x,y)$ holds. I.e. $(\forall{}x,\exists{}y,P(x,y))\land{}$
  $\forall{}A,\exists{}B,\forall{}x,(x\in{}A\Leftrightarrow\exists{}y,y\in{}B\land{}P(x,y))$.
\end{axiom}

We write $A\cap{}B$ to denote the set formed by the intersection of
set $A$ and $B$,
i.e. $\forall{}x,x\in{}A\cap{}B\Leftrightarrow{}~x\in{}A\land{}x\in{}B$.

\begin{axiom}[Foundation]
  \label{ax:foundation}
  For all non-empty set $A$, there exists a set $B$ such that
  $B\in{}A$ and $B$ has no common element with $A$. I.e.
  $\forall{}A,x\neq\emptyset\Rightarrow\exists{}B,B\in{}A\land(A\cap{}B=\emptyset)$.
\end{axiom}

\paragraph{Extensional definition} A set is defined by
\emph{extension} with the enumeration of all its members. For
instance, $\{1,0,-1\}$, $\{a,b,c\}$ or $\{p_0,\dots,p_n\}$ are all
sets defined by extension.

\paragraph{Intensional definition}
The intensional definition of a set specifies a given property
verified by all the members of the set. For instance, here is the
intensional definition of the set of even numbers:
$\{n\in\mathbb{N}~\vert~\exists{}k\in\mathbb{N}~s.t.~n=2k\}$ or
$\{n\in\mathbb{N}~\vert~IsEven(n)\}$.

\paragraph{Set operators}

Set theory also defines some operators to compose sets together. Given
two sets $A$ and $B$, the following sets are formed:

\begin{itemize}
  
\item $A\cap{}B$ denotes the set formed by the intersection of set $A$
  and $B$, i.e. $A\cap{}B=\{x~\vert~x\in{}A\land{}x\in{}B\}$.
  
\item $A\setminus{}B$ denotes the set formed by the elements of set
  $A$ that are not elements of set $B$ (the difference between set $A$
  and $B$), i.e. $A\setminus{}B=\{x~\vert~x\in{}A\land{}x\notin{}B\}$.

\item $A\times{}B$ denotes the cartesian product between the elements
  of set $A$ and set $B$, i.e. the set of all ordered pairs defined by
  $\{(x,y)~\vert~x\in{}A\land{}y\in{}B\}$. We generalize the
  definition to build the set of $n$-tuples
  $A_0\times{}A_1\times\dots\times{}A_n$ defined by
  $\{(x_0,
  (x_1,\dots(\dots,x_n)))~\vert~x_0\in{}A_0,x_1\in{}A_1,\dots,x_n\in{}A_n\}$.
  It is sometimes useful to give a name to the elements of a tuple
  without refering to their index. In such a case, a tuple is called a
  record where each element, called a field, has been given an
  explicit name. This formalism is useful to represent rather complex
  data structures. For instance, say that we want to represent the set
  of humans by a triplet composed of the size, weight, and eye color
  of a given human.  We can define this set as the set of triplet
  $\mathbb{R}\times\mathbb{R}\times\{green,blue,brown\}$. If we want
  to give a concrete name to the elements of the triplet, we can
  equivalently define such a triplet as a record, written
  ${<}size,weight,eye{>}$, where $size\in\mathbb{R}$,
  $weight\in\mathbb{R}$ and $eye\in\{green,blue,brown\}$.
  
\item $A\sqcup{}B$ denotes the set formed by the disjoint union of set
  $A$ and set $B$. The disjoint union is obtained by adjoining an
  index $i$ to the elements of $A$ and an index $j$ to the elements of
  $B$ such that $i\neq{}j$. Then, the two sets of couples are joined
  together to build the disjoint union of $A$ and $B$. For instance,
  consider that $A=\{a,b,c\}$ and $B=\{a,b\}$. To obtain the disjoint
  union $A\sqcup{}B$, we create the two sets
  $A_i=\{(i,a),(i,b),(i,c)\}$ and $B_i=\{(j,a),(j,b)\}$, and then join
  the sets together
  s.t. $A\sqcup{}B=\{(i,a),(i,b),(i,c),(j,a),(j,b)\}$. When the two
  sets $A$ and $B$ are disjoint, i.e. $A\cap{}B=\emptyset$, then
  $A\sqcup{}B$ is isomorphic to $A\cup{}B$. To stress the fact that we
  are building a set from the union of two disjoint sets, we prefer to
  use the disjoint union operator. For instance, we write
  $\mathbb{N}\sqcup{}\{\infty\}$, instead of
  $\mathbb{N}\cup{}\{\infty\}$, to denote the set of values ranging
  from the set of natural numbers with the addition of the infinite
  value $\infty$.

\item $\mathcal{P}(A)$ denotes the powerset of $A$ defined by all the
  possible subsets formed with the elements of set $A$, i.e.
  $\mathcal{P}(A)=\{X~\vert~X\subseteq{}Y\}$.
\end{itemize}

\paragraph{Relations and functions}

A binary relation $R$ between two sets $X$ and $Y$ is a subset of the
set of pairs $X\times{}Y$, i.e. $R\subseteq{}X\times{}Y$, or an
element of the powerset $\mathcal{P}(X\times{}Y)$,
i.e. $R\in\mathcal{P}(X\times{}Y)$. We write $R(x,y)$ to denote
$(x,y)\in{}R$. We generalize the definition to n-ary relations. A
n-ary relation between sets $X_0,\dots,X_n$ is a subset of the set of
n-tuples $X_0\times\dots\times{}X_n$,
i.e. $R\subseteq{}X_0\times\dots\times{}X_n$, or an element of the
powerset $\mathcal{P}(X_0\times\dots\times{}X_n)$,
i.e. $R\in\mathcal{P}(X_0\times\dots\times{}X_n)$. We write
$R(x_0,\dots,x_n)$ to denote $(x_0,\dots,x_n)\in{}R$. \\

A partial function $f$ from set $X$ to set $Y$ is a binary relation
from $X$ to $Y$ verifying that
$\forall{}x\in{}X,y,y'\in{}Y,~(x,y)\in{}f\land{}(x,y')\in{}f\Rightarrow{}y=y'$,
i.e. $x$ appears at most once as the first element of a pair in $f$.
We note $f\in{}X\nrightarrow{}Y$ to denote a partial function from $X$
to $Y$. The set of the first elements of the pairs defined in $f$ is
called the \emph{domain} of $f$. We write it
$\mathtt{dom}(f)=\{x~\vert~\exists{}y~s.t.(x,y)\in{}f\}$.  When there
is no ambiguity, and given an $x\in{}X$ and $f\in{}X\nrightarrow{}Y$,
we write $x\in{}f$ as a shorthand to $x\in\mathtt{dom}(f)$.\\

A total function $a$, or application, from $X$ to $Y$ is a partial
function verifying that all the elements of $X$ appear as the first
element of a pair in $a$, i.e. for all $x\in{}X$, there exists
$y\in{}Y$ such that $(x,y)\in{}a$. In other words, the domain of an
application from $X$ to $Y$ is equal to the set $X$. We note
$a\in{}X\rightarrow{}Y$ to denote an application from $X$ to $Y$.

\subsection{Rule-based definition of sets}
\label{sec:rule-based-def}

While describing the operational semantics of a subset of the \vhdl{}
language in Chapter~\ref{chap:hvhdl}, we define some of the sets (e.g,
simulation relations) with rule instances, also called inference rules
or judgments. A rule instance, defining the members of a set $A$, can
take the following forms:

\begin{center}
\begin{prooftree}[template=\inserttext]
  \infer0{ $C$ }
\end{prooftree}
~or~
\begin{prooftree}[template=\inserttext]
  \hypo{$P_1,\dots,P_n$}
  \infer1{ $C$ }
\end{prooftree}
\end{center}

The left form of rule instance is called an axiom; it states that
$C\in{}A$.  The rule instance \begin{prooftree}[template=\inserttext]
  \hypo{$P_1,\dots,P_n$} \infer1{ $C$ }
\end{prooftree} states that $C\in{}A$ if $P_1,\dots,P_n$ hold. Also,
we say that $C$ is derivable, if $P_1,\dots,P_n$ are derivable.
$P_1,\dots,P_n$ are the premises of the rule, and $C$ is the
conclusion of the rule. The premises $P_1,\dots,P_n$ hold if there
exists a \emph{finite} derivation tree for each one of them. A
\emph{finite} derivation tree is obtained by applying the rule
instances defining the set until all branches of the derivation reach
axioms. For instance, the two following rules, named rules
\textsc{Ev0} and \textsc{Ev2}, define the $IsEven$ unary relation that
states that a given natural number is even:

\begin{table}[H]
  \centering
  
  \begin{tabular}{@{}l}
    {\fontsize{10}{13}\selectfont\textsc{Ev0}} \\
    {\begin{prooftree}[template=\inserttext]
        \infer0{ $IsEven(0)$ }
      \end{prooftree}} \\
  \end{tabular}
  \hspace{50pt}
  \begin{tabular}{@{}l}
    {\fontsize{10}{13}\selectfont\textsc{Ev2}} \\
    {\begin{prooftree}[template=\inserttext]
        \hypo{$IsEven(n-2)$}
        \infer1{ $IsEven(n)$ }
      \end{prooftree}} \\
  \end{tabular}
\end{table}

The rule \textsc{Ev0} states as an axiom that $0$ is an even number;
the rule \textsc{Ev2} states that for all natural number $n$, $n$ is
an even number if one can derive that fact that $n-2$ is an even
number. Thus, we can derive from the previous rules that $4$ is an
even number by building the following derivation tree:

\begin{table}[H]
  \centering
  \begin{prooftree}[template=\inserttext]
    \infer0[\textsc{Ev0}]{$IsEven(0)$}
    \infer1[\textsc{Ev2}]{$IsEven(2)$}
    \infer1[\textsc{Ev2}]{ $IsEven(4)$ }
  \end{prooftree}
\end{table}

Starting from $IsEven(4)$, we can apply the \textsc{Ev2} rule to
derive $IsEven(2)$. Then, another application of the \textsc{Ev2} rule
leads to $IsEven(0)$, and we can close the derivation branch by
applying the \textsc{Ev0} rule. Here, the only branch of the tree has
reached an axiom, and thus the derivation tree is finite. To further
illustrate the use of rule instances in the definition of a set, let
us consider the following minimal language of arithmetic expressions
expressed in the Backus-Naur form:

\begin{table}[H]
  \centering
  \begin{tabular}{lll}
    $e$ & $::=$ & $n~|~id~|~e_0+e_1$ \\
  \end{tabular}
\end{table}

Here, $n$ ranges over the set of natural numbers $\mathbb{N}$; $id$
ranges over the set $\mathtt{string}$ of non-empty strings (i.e. it is
the set of identifiers). To evaluate the arithmetic expressions, we
need a state $s\in\mathtt{string}\nrightarrow{}\mathbb{N}$ that maps
each variable identifier to a natural number value. We assume that
only a certain set of declared identifiers can appear in an arithmetic
expression. Thus, the state is a partial function from the set of
non-empty strings to the set of natural numbers. We define the
evaluation relation for the arithmetic expressions with the three
following rules:

\begin{table}[H]
  \begin{tabular}{l}
    {\fontsize{10}{13}\selectfont\textsc{Nat}} \\
    {\begin{prooftree}[template=\inserttext]
      \infer0{ $s\vdash{}n\rightarrow{}n$ }
    \end{prooftree}} \\
  \end{tabular}
  \hspace{10pt}
  \begin{tabular}{l}
    {\fontsize{10}{13}\selectfont\textsc{Var}} \\
    {\begin{prooftree}[template=\inserttext]
        \infer0[$id\in{}\mathtt{dom}(s)$]{ $s\vdash{}id\rightarrow{}s(id)$ }
      \end{prooftree}} \\
  \end{tabular}
  \hspace{10pt}
  \begin{tabular}{l}
    {\fontsize{10}{13}\selectfont\textsc{Add}} \\
    {\begin{prooftree}[template=\inserttext]
        \hypo{ $s\vdash{}e_0\rightarrow{}n$ }
        \hypo{ $s\vdash{}e_1\rightarrow{}m$ }
        \infer2{ $s\vdash{}e_0+e_1\rightarrow{}n+m$ }
      \end{prooftree}}
  \end{tabular}
\end{table}

Here, the evaluation relation is a subset of the set of triplets
$(\mathtt{string}\nrightarrow\mathbb{N})\times{}e\times\mathbb{N}$. In
the rule instances defining the evaluation relation, the $\vdash$
symbol (pronounced \emph{thesis}) stresses that the left part implies
the right part, or it is involved in the evaluation of the right part.
For instance, the second rule can be read: in the context of state
$s$, $id$ evaluates to $s(id)$ if $id\in{}\mathtt{dom}(s)$. When the
\emph{context} is not involved in the evaluation of the syntactic
constructs at the right side of the $\vdash$ symbol, we permit
ourselves to remove the context and the $\vdash$ from the rule
instances. For example, we can define to the \textsc{Nat} rule by

\begin{table}[H]
  \centering
  \begin{tabular}{l}
    {\fontsize{10}{13}\selectfont\textsc{Nat}} \\
    {\begin{prooftree}[template=\inserttext]
        \infer0{ $n\rightarrow{}n$ }
      \end{prooftree}} \\
  \end{tabular}
\end{table}

\noindent{}as the state $s$ in not involved in the evaluation of
expressions that are natural numbers. 

Note that in the \textsc{Var} rule, there appears an extra statement,
at the right of the judgment line, called a \emph{side
  condition}. This is an extra condition that must hold with all the
premises of the rule instance, but which does not generate a
derivation tree of its own.

Finally, here is an example of a derivation tree for the evaluation of
the expression $x+(y+1)$ in the context of state $\{(x,1),(y,2)\}$:

\begin{table}[H]
  \centering
  \begin{tabular}{l}
    {\begin{prooftree}[template=\fontsize{11}{13}\selectfont\inserttext]
        \infer[left label={\textsc{Var}}]0[$x\in\{x,y\}$]{ $\{(x,1),(y,2)\}\vdash{}x\rightarrow{}1$ }
        
        \infer[left label={\textsc{Var}}]0[$y\in\{x,y\}$]{ $\{(x,1),(y,2)\}\vdash{}y\rightarrow{}2$ }
        \infer0[\textsc{Nat}]{ $1\rightarrow{}1$ }
        \infer2[\textsc{Add}]{ $\{(x,1),(y,2)\}\vdash{}y+1\rightarrow{}3$ }
        
        \infer2[\textsc{Add}]{
            $\{(x,1),(y,2)\}\vdash{}x+(y+1)\rightarrow{}4$
        }
      \end{prooftree}} \\
  \end{tabular}
\end{table}

Here again, all the branches of the derivation tree have reached
axioms, and thus\\ $\{(x,1),(y,2)\}\vdash{}x+(y+1)\rightarrow{}4$ is a
member of the evaluation relation of arithmetic expressions. It states
that the expression $x+(y+1)$ evaluates to $4$ in the state
$\{(x,1),(y,2)\}$.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../main"
%%% End:
