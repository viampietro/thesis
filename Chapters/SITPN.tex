\chapter{Implementation of the \hilecop{} high-level models}
\label{chap:hilecop-models}

\begin{todobox}
  \begin{itemize}
  \item Keep the $sitpn$ argument in the SITPN full execution
    relation, but remove it from the SITPN execution, cycle and state
    transition relations.
    
  \item Change squig arrow to straight arrow in the SITPN state
    transition relation.
  \end{itemize}
\end{todobox}

\section{SITPN Definitions}
\label{sec:sitpn-defs}

\subsection{SITPN Structure and Well-definition}
\label{sec:struct-and-wd}

\subsubsection{SITPN Structure}
\label{sec:sitpn-struct}

\begin{definition}[SITPN]
\label{def:sitpn}
A synchronously executed, extended, generalized, interpreted, and time Petri net
with priorities is a tuple\\
${<}P,T,pre,post,M_0,{\succ},\mathcal{A},\mathcal{C},\mathcal{F},
\mathbb{A},\mathbb{C},\mathbb{F},{I_s}{>}$, where we have:
%
\begin{enumerate}
\item $P=\{p_0,\ldots,p_n\}$, a set of places.
\item $T=\{p_0,\ldots,p_m\}$, a set of transitions.
\item
  $pre\in{}P\rightarrow{}T\nrightarrow(\mathbb{N}^{*}\times\{\mathtt{basic},\mathtt{inhib},\mathtt{test}\})$,
  the function associating a weight to place-transition edges.
\item $post\in{}T\rightarrow{}P\nrightarrow\mathbb{N}^{*}$, the function
  associating a weight to transition-place edges.
\item $M_0\in{}P\rightarrow\mathbb{N}$, the initial marking of the SITPN.
\item $\succ\subseteq{}(T\times{}T)$, the priority relation which is a
  strict order over the set of transitions.
\item $\mathcal{A}=\{a_0,\ldots,a_n\}$, a set of continuous actions.
\item $\mathcal{C}=\{c_0,\ldots,c_n\}$, a set of conditions.
\item $\mathcal{F}=\{f_0,\ldots,f_n\}$, a set of functions (discrete actions).
\item $\mathbb{A} \in P \rightarrow \mathcal{A} \rightarrow \mathbb{B}$, the
function associating actions to places. $\forall{}p\in{}P$,
$\forall{}a\in\mathcal{A}$, $\mathbb{A}(p,a)=1$, if $a$ is associated to $p$,
$\mathbb{A}(p,a)=0$ otherwise.
\item $\mathbb{F} \in T \rightarrow \mathcal{F} \rightarrow \mathbb{B}$, the
function associating functions to transitions. $\mathbb{F}$ is defined in the
same manner as $\mathbb{A}$.
\item $\mathbb{C} \in T \rightarrow \mathcal{C} \rightarrow\{-1,0,1\}$, the
function associating conditions to transitions.
$\forall t \in T$, $\forall c \in \mathcal{C}$,
$\mathbb{C}(t,c)=1$, if $c$ is associated to $t$,
$\mathbb{C}(t,c)=-1$, if $\bar{c}$ is associated to $t$,
$\mathbb{C}(t,c)=0$ otherwise.
\item $I_s\in{}T\nrightarrow\mathbb{I}^{+}$, the partial function
  associating static time intervals to transitions, where
  $\mathbb{I}^{+}\subseteq(\mathbb{N}^{*}\times(\mathbb{N^{*}}\sqcup\{\infty\}))$.
  $T_i$ denotes the definition domain of $I_s$, i.e. the set of time
  transitions.
\end{enumerate}
\end{definition}

\paragraph{Conflict Definition} In the definition of an SITPN, the
priority relation is a mean to solve a situation of conflict in a pair
of transitions. We will keep the definition of a conflict as simple as
possible. Informally, the transitions of a pair are in conflict if
they have an common input place, and if both are linked to this input
place by a \texttt{basic} arc. Figure~\ref{fig:basic-conflict} depicts
a situation of conflict between two transitions.

At some point of the execution of the SITPN, the marking possibly
enables the two transitions of a conflicting pair in such a manner
that the firing of one transition disables the other; then, the
conflict is said to be \emph{effective}. The behavior of PNs is
fundamentally asynchronous, and a token can only be consumed by one
transition. However, in a synchronous setting as the one of the SITPN,
all transitions are first elected to be fired, and then all fired at
the same time.  Therefore, the situation can arise where a same token
is consumed by two transitions, on behalf of them being transitions in
effective conflict that are both elected to be fired (e.g,
Figure~\ref{fig:basic-conflict}). To prevent the phenomenon of
``double spending'', the well-definition property of an $SITPN$
enforces the resolution of all conflicts, i.e, to be able to decide
which transition in a conflicting pair will be fired when the conflict
becomes effective.

\begin{figure}[H]
  \centering
  \includegraphics[keepaspectratio,width=.3\linewidth]{SITPN/struct-conflict-with-basic}
  \caption{Example of conflict between two transitions}
  \label{fig:basic-conflict}
\end{figure}

The formal definition of a conflict is as follows:

\begin{definition}[Conflict]
  For a given $sitpn\in{}SITPN$, two transitions $t,t'\in{}T$ are in
  conflict if and only if there exists a place $p\in{}P$ such that
  $p\in{}input(t)\cap{}input(t')$ and there exist
  $n,m\in\mathbb{N}^{*}$ such that $pre(p,t)=(n,\mathtt{basic})$ and
  $pre(p,t')=(m,\mathtt{basic})$.
\end{definition}

A confict group qualifies a finite set of transitions that are all in
conflict with each other through the same place. In
Figure~\ref{fig:basic-conflict}, the set $\{t_0,t_1\}$ is a conflict
group.  The formal definition of a conflict group is as follows:

\begin{definition}[Conflict Group]
  For a given $sitpn\in{}SITPN$, $T_c\subseteq{}T$ is a conflict group
  if and only if there exists a place $p$ such that
  $\forall{}t\in{}output(p),\big(\exists{}n\in\mathbb{N}^{*},~pre(p,t)=(n,\mathtt{basic})\big)\Leftrightarrow{}t\in{}T_c$.
\end{definition}

Contrary to the statement made in
\cite[p.67]{Leroux2014}, we no more consider the notion
of conflict as being transitive. To illustrate this,
Figure~\ref{fig:conflict-not-trans} shows two conflict groups:
$\{t_0,t_1\}$ and $\{t_1,t_2\}$. In a well-defined $SITPN$ (see
Section~\ref{sec:sitpn-wd}), all conflicts in a conflict group must be
dealt with, i.e, for all pair of transitions in the group the conflict
must be solved. However, we no more consider transitions $t_0$ and
$t_2$ as in conflict. We argue that even when no conflict resolution
technique is applied between transitions in the same situation as
$t_0$ and $t_2$, the execution of the $SITPN$ can neither result in
the double-spending of a token, nor in the case where a transition is
not elected to be fired even though it ought to be. Therefore, we no
more consider the construction of merged conflict group (i.e, conflict
groups must be merged into one if their intersection is not empty;
e.g, $\{t_0,t_1,t_2\}$ in Figure~\ref{fig:conflict-not-trans}) as
being necessary.

\begin{figure}[H]
  \centering
  \includegraphics[keepaspectratio,width=.4\linewidth]{SITPN/conflict-not-trans}
  \caption{Example of two separate conflict groups}
  \label{fig:conflict-not-trans}
\end{figure}

\subsubsection{Well-definition of an SITPN}
\label{sec:sitpn-wd}

A given $sitpn\in{}SITPN$ is well-defined if it enforces some
properties needed on the \hilecop{} source models before the
transformation into \vhdl{}. If the properties, layed out in
Def.~\ref{def:wd-sitpn}, are not ensured, they will lead to
compile-time errors during the transformation into \vhdl{}.

\begin{definition}[Well-defined SITPN]\label{def:wd-sitpn}
  A given $sitpn\in{}SITPN$ is well-defined if and only if:
  \begin{itemize}
  \item $T\neq\emptyset$, the set of transitions must not be empty.
  \item $P\neq\emptyset$, the set of places must not be empty.
  \item There is no isolated place, i.e, a place that has neither
    input nor output transitions:\\
    $\nexists{}p\in{}P,~input(p)=\emptyset\wedge{}output(p)=\emptyset$,
    where $input(p)$ (resp. $output(p)$) denotes the set of input
    (resp. output) transitions of $p$.
  \item There is no isolated transition, i.e, a transition that has
    neither
    input nor output places:\\
    $\nexists{}t\in{}T,~input(t)=\emptyset\wedge{}output(t)=\emptyset$,
    where $input(t)$ (resp. $output(t)$) denotes the set of input
    (resp. output) places of $t$.
  \item All conflicts must be solved by a mean of mutual exclusion:
    priority relation, mutually exclusive conditions, mutually
    exclusive time intervals, structural mutual exclusion.
  \end{itemize}
\end{definition}

\subsection{SITPN State}
\label{sec:sitpn-state}

\begin{definition}[SITPN State]
  \label{def:sitpnstate}
  For a given $sitpn\in{}SITPN$, let $S(sitpn)$ be the set of possible
  states of $sitpn$. An SITPN state $s\in{}S(sitpn)$ is a tuple
  ${<}M,I,reset_t,ex,cond{>}$, where:
  \begin{enumerate}
  \item $M\in{}P\rightarrow\mathbb{N}$ is the current marking of sitpn.
  \item $I\in{}T_i{}\rightarrow\mathbb{N}\sqcup\{\psi\}$ is the
    function mapping time transitions to their current time counter
    value or to the value \emph{locked}.
  \item $reset_t\in{}T_i\rightarrow\mathbb{B}$ is the function mapping time
    transitions to time interval reset orders (defined as Booleans).
  \item $ex\in{}\mathcal{A}\sqcup\mathcal{F}\rightarrow\mathbb{B}$ is the function
    representing the current activation (resp. execution) state of actions
    (resp. functions).
  \item $cond\in\mathcal{C}\rightarrow\mathbb{B}$ is the function representing the
    current value of conditions (defined as Booleans).
  \end{enumerate}
\end{definition}

\subsection{Fired Transitions}
\label{sec:fired-trans}

\begin{definition}[Sensitization]
  A transition $t\in{}T$ is said to be sensitized by a marking $M$,
  which is noted $t\in{}Sens(M)$, if and only if
  $\forall{}p\in{}P,\omega\in\mathbb{N}^{*},~\big(pre(p,t)=(\omega,\mathtt{basic})\vee{}pre(p,t)=(\omega,\mathtt{test})\big)\Rightarrow{}M(p)\ge{}\omega$,
  and $pre(p,t)=(\omega,\mathtt{inhib})\Rightarrow{}M(p)<{}\omega$.
\end{definition}

\begin{definition}[Sensitization by test and basic arcs]
  A transition $t\in{}T$ is said to be sensitized by its basic and
  test arcs at a marking $M$, which is noted $t\in{}Sens_{bt}(M)$, if
  and only if
  $\forall{}p\in{}P,\omega\in\mathbb{N}^{*},~\big(pre(p,t)=(\omega,\mathtt{basic})\vee{}pre(p,t)=(\omega,\mathtt{test})\big)\Rightarrow{}M(p)\ge{}\omega$.
\end{definition}

\begin{definition}[Firability]
A transition $t\in{}T$ is said to be firable at a state\break{}
$s={<}M,I,reset_t,ex,cond{>}$, which is noted $t\in{}Firable(s)$,
if and only if $t\in{}Sens(M)$, and $t\notin{}T_i$ or $I(t)\in{}I_s(t)$, and
$\forall c \in \mathcal{C}, \mathbb{C}(t, c) = 1 \Rightarrow cond(c) = 1$ and
$\mathbb{C}(t, c) = -1 \Rightarrow cond(c) = 0$.
\end{definition}

\begin{definition}[Fired]
  \label{def:fired}
  A transition $t\in{}T$ is said to be fired at the SITPN state
  $s={<}M,I,reset_t,ex,cond{>}$, which is noted $t\in{}Fired(s)$, if
  and only if $t\in{}Firable(s)$ and
  $t\in{}Sens\big(M-\sum_{t_i\in{}Pr(t)}pre(t_i)\big)$, where
  $Pr(t)=\{t_i~|~t_i\succ{}t\wedge{}t_i\in{}Fired(s)\}$.
\end{definition}

Note that $M'=M-\sum_{t_i\in{}Pr(t)}pre(t_i)$ iff
$\forall{}p\in{}P,~M'(p)=M(p)-\sum_{t_i\in{}Pr(t)}pre(p,t_i)$.

Def.~\ref{def:cons-fired} makes another definition of the set of fired
transitions at a given SITPN state. The approach of
Def.~\ref{def:cons-fired} is more constructive, therefore easing the
way to inductive reasoning.

\begin{definition}[Constructive Fired]
  \label{def:cons-fired}
  A transition $t\in{}T$ is said to be fired at the SITPN state
  $s={<}M,I,reset_t,ex,cond{>}$, iff there exists a subset
  $fset\subseteq{}T$ such that $IsFiredSet(s,fset)$ and $t\in{}fset$.
\end{definition}

\begin{lemma}[Fired Equivalence]
  For all
  $sitpn\in{}SITPN,~s\in{}S(sitpn),~t\in{}T,~t\in{}Fired(s)\Leftrightarrow{}\exists{}fset\subseteq{}T,~s.t.,~IsFiredSet(s,fset)\land{}t\in{}fset$.
\end{lemma}

\begin{proof}
  Yet to be proved.
\end{proof}

\begin{definition}[IsFiredSet]
  Given an $sitpn\in{}SITPN$, a SITPN state $s\in{}S(sitpn)$, and a
  subset $fset\in{}T$, the $IsFiredSet$ relation is defined as follows:\\
  $IsFiredSet(s,fset)\equiv{}IsFiredSetAux(s,\emptyset,T,fset)$
\end{definition}

\begin{definition}[IsFiredSetAux]
  The $IsFiredSetAux$ relation is defined by the following rules:\\
  \begin{tabular}{@{}l}
    {\fontsize{9}{11}\selectfont\textsc{IsFiredSetAuxNil}} \\
    
    {\begin{prooftree}[template={\fontsize{9}{11}\selectfont\inserttext}]        
        \infer0{$FiredAux(s, fired, \emptyset, fired)$}
      \end{prooftree}} 
  \end{tabular}
  \begin{tabular}{@{}l}
    {\fontsize{9}{11}\selectfont\textsc{IsFiredSetAuxCons}} \\
    
    {\begin{prooftree}[template={\fontsize{9}{11}\selectfont\inserttext}]

        \hypo{$IsTopPriorityList(T_i, \emptyset, \emptyset, tp)$}
        \infer[no rule]1{$ElectFired(s, fired, tp, fired')$}
        \infer[no rule]1{$FiredAux(s, fired', T_i\setminus{}tp, fset)$}
        \infer1{$FiredAux(s, fired, T_i, fset)$}
      \end{prooftree}} 
  \end{tabular}
\end{definition}

\begin{definition}[IsTopPriorityList]
  The $IsTopPriorityList$ relation is defined by the following rules:\\
  \begin{tabular}{@{}l}
    {\fontsize{9}{11}\selectfont\textsc{IsTPListNil}} \\
    
    {\begin{prooftree}[template={\fontsize{9}{11}\selectfont\inserttext}]
        \infer0{$IsTopPriorityList(\emptyset, tp, ntp, tp)$}
      \end{prooftree}} 
  \end{tabular}
  \begin{tabular}{@{}l}
    {\fontsize{9}{11}\selectfont\textsc{IsTPListTP}} \\
    
    {\begin{prooftree}[template={\fontsize{9}{11}\selectfont\inserttext}]
        \hypo{$\forall{}t'\in{}T_i\cup{}tp\cup{}ntp,t'\nsucc{}t$}
        \infer[no rule]1{$IsTopPriorityList(T_i, \{t\}\cup{}tp, ntp, tp')$}
        \infer1{$IsTopPriorityList(\{t\}\cup{}T_i, tp, ntp, tp')$}
      \end{prooftree}} 
  \end{tabular}

  \begin{tabular}{@{}l}
    {\fontsize{9}{11}\selectfont\textsc{IsTPListNTP}} \\
    
    {\begin{prooftree}[template={\fontsize{9}{11}\selectfont\inserttext}]
        \hypo{$\exists{}t'\in{}T_i\cup{}tp\cup{}ntp\wedge{}t'\succ{}t$}
        \infer[no rule]1{$IsTopPriorityList(T_i, tp, \{t\}\cup{}ntp, tp')$}
        \infer1{$IsTopPriorityList(\{t\}\cup{}T_i, tp, ntp, tp')$}
      \end{prooftree}} 
  \end{tabular}
\end{definition}

\begin{definition}[ElectFired]
  The $ElectFired$ relation is defined by the following rules:
  
  \begin{tabular}{@{}l}
    {\fontsize{8}{11}\selectfont\textsc{ElectFiredNil}} \\
    
    {\begin{prooftree}[template={\inserttext}]
        \infer0{$ElectFired(s,fired,\emptyset, fired)$}
      \end{prooftree}} 
  \end{tabular}
  \vspace{2ex}
  
  \begin{tabular}{@{}l}
    {\fontsize{8}{11}\selectfont\textsc{ElectFired$\bot$}} \\
    
    {\begin{prooftree}[template={\inserttext},right label template={\fontsize{7}{8}\selectfont\inserttext}]
        \hypo{$\neg\big(t\in{}Firable(s)\wedge{}t\in{}Sens(s.M-\sum_{t_i\in{}Pr(t,fired)}pre(t_i))\big)$}
        \infer[no rule]1{$ElectFired(s, fired, tp, fired')$}
        \infer1[$Pr(t,fired)=\{t_i~|~t_i\succ{}t\wedge{}t_i\in{}fired\}$]{$ElectFired(s, fired, \{t\}\cup{}tp, fired')$}
      \end{prooftree}} 
  \end{tabular}
  \vspace{2ex}
  
  \begin{tabular}{@{}l}
    {\fontsize{8}{11}\selectfont\textsc{ElectFired$\top$}} \\
    
    {\begin{prooftree}[template=\inserttext,right label template={\fontsize{7}{9}\selectfont\inserttext}]
        \hypo{$t\in{}Firable(s)$}
        \hypo{$t\in{}Sens(s.M-\sum_{t_i\in{}Pr(t,fired)}pre(t_i))$}
        \infer[no rule]2{$ElectFired(s, \{t\}\cup{}fired, tp, fired')$}
        \infer1[$Pr(t,fired)=\{t_i~|~t_i\succ{}t\wedge{}t_i\in{}fired\}$]{$ElectFired(s, fired, \{t\}\cup{}tp, fired')$}
      \end{prooftree}}
  \end{tabular}
\end{definition}
    
\subsection{SITPN Semantics}
\label{sec:sitpn-sem}

\begin{todobox}
  \begin{itemize}
  \item Change $E$ into $E_c$.
  \item Change typing of the state transition relation to include the
    environment.
  \end{itemize}
\end{todobox}

\begin{definition}[SITPN Semantics]
  \label{def:semantics}
  The semantics of an SITPN is the transition system
  $<S,L,E,\rightsquigarrow>$ where:
  \begin{itemize}[label=-]
  \item $S$ is the set of states of the SITPN.
  \item
    $s_0=<M_0,O_\mathbb{N},O_\mathbb{B},O_\mathbb{B},O_\mathbb{B}>$
    is the initial state of the SITPN, where $M_0$ is the initial
    marking of the SITPN, $O_\mathbb{N}$ is a function that always
    returns 0, $O_\mathbb{B}$ is a function that always returns false.
  \item $L\subseteq{}Clk\times{}\mathbb{N}$ is the set of transition
    labels, where $Clk\in\{\uparrow,\downarrow\}$. A label is a couple $(clk,\tau)$
    composed of a clock event $clk\in{}Clk$, and a time value $\tau\in\mathbb{N}$
    expressing the current count of clock cycles.

  \item

    $E\in{}\mathbb{N}\rightarrow\mathcal{C}\rightarrow\mathbb{B}$ is the
    environment function, which gives (Boolean) values to conditions ($\mathcal{C}$)
    depending on the count of clock cycles ($\mathbb{N}$).
  \item $\rightsquigarrow\subseteq{}S\times{}L\times{}S$ is the state
    transition relation, which is noted
    $E,\tau\vdash{}s\stackrel{clk}{\rightsquigarrow}s'$ where
    $s,s'\in{}S$ and $(clk,\tau)\in{}L$, and which is defined as
    follows:
    % $s\xrsquigarrow{l}s'$
    \begin{itemize}
    \item $\forall\tau\in\mathbb{N}$,
      $E,\tau\vdash{}s\stackrel{\downarrow}{\rightsquigarrow}s'$,
      where $s=<M,I,reset_t,ex,cond>$ and\\
      $s'=<M,I',reset_t,ex',cond'>$, if:
      % $s\xrsquigarrow{(\downarrow,\tau)}s'$,
      \begin{enumerate}[label=(\arabic*)]
      \item\label{item:cond-env} $cond'$ is the function giving the (Boolean)
        values of conditions that are extracted from the environment at the clock count
        $\tau$, i.e.:\\
        $\forall{}c\in{}\mathcal{C},~cond'(c)=E(\tau,c)$.
      \item\label{item:activate-actions} All the actions associated
        with at least one
        marked place in the marking $M$ are activated, i.e.:\\
        $\forall{}a\in{}\mathcal{A},~ex'(a)=\sum\limits_{p\in{}marked(M)}\mathbb{A}(p,a)$
        where $p\in{}marked(M)\equiv{}M(p)>0$.
      % \item\label{item:activate-actions} All the actions associated with at least one
      %   marked place in the marking $M$ are activated, i.e.:\\
      %   $\forall{}a\in{}\mathcal{A},~\big(\exists{}p\in{}P,~M(p)>0
      %   \land{}\mathbb{A}(p,a)=1\big)\Rightarrow{}ex'(a)=1$.
      % \item\label{item:deactivate-actions} All the actions that are only associated
      %   with unmarked places in the marking $M$ are deactivated, i.e.:\\
      %   $\forall{}a\in{}\mathcal{A},~\big(\forall{}p\in{}P,~M(p)=0
      %   \vee{}\mathbb{A}(p,a)=0\big)\Rightarrow{}ex'(a)=0$.
      \item\label{item:reset-counters} All the time transitions that
        are sensitized by the marking $M$ and received the order to
        reset their time intervals, have their time counter reset and
        incremented, i.e.:\\
        $\forall{}t\in{}T_i,~t\in{}Sens(M)\land{}reset_t(t)=1
        \Rightarrow{}I'(t)=1$.
      \item\label{item:inc-counters} All the time transitions with
        active time counters that are sensitized by the marking $M$
        and
        did not receive a reset order, have their time counters incremented, i.e.:\\
        $\forall{}t\in{}T_i,~t\in{}Sens(M)\land{}reset_t(t)=0
        \land{}(I(t)\le{}upper(I_s(t))\lor{}upper(I_s(t))=\infty)\Rightarrow{}$
        $I'(t)=I(t)+1$.
      \item\label{item:locked-counters} All the time transitions
        verifying the same
        conditions as above, but with locked counters, keep having locked counters, i.e.:\\
        $\forall{}t\in{}T_i,~t\in{}Sens(M)\land{}reset_t(t)=0
        \land{}I(t)>{}upper(I_s(t))\land{}upper(I_s(t))\neq\infty\Rightarrow{}$
        $I'(t)=I(t)$.
      \item\label{item:reset-not-sens} All the time transitions that
        are not sensitized by the marking $M$ have their time counters set to zero, i.e.:\\
        $\forall{}t\in{}T_i,~t\notin{}Sens(M)\Rightarrow{}I'(t)=0$.
      \end{enumerate}
    \item $\forall\tau\in\mathbb{N}$,
      $E,\tau\vdash{}s\stackrel{\uparrow}{\rightsquigarrow}s'$, where
      $s=<M,I,reset_t,ex,cond>$ and\\
      $s'=<M',I,reset_t',ex',cond>$, if:
      % $s'\xrsquigarrow{(\uparrow,\tau)}s''$,
      \begin{enumerate}[label=(\arabic*),resume]
      \item\label{item:new-marking} $M'$ is the new marking resulting from
        the firing of all the transitions contained in $Fired(s)$, i.e.:\\
        $M'=M-\sum_{t_i\in{}Fired(s)}\big(pre(t_i)-post(t_i)\big)$.
      \item\label{item:reset-order} To receive a reset order, a
        transition must be enabled by the
        marking at state $s$ and disabled by the transient marking, or must be fired at state $s$:\\
        $\forall{}t\in{}T_i,~t\in{}Sens(M)~\land~t\notin{}Sens_{bt}\big(M-\sum_{t_i\in{}Fired(s)}pre(t_i)\big)\lor{}t\in{}Fired(s)
        \Rightarrow{}reset'(t)=1$.
      \item\label{item:no-reset-order} A transition that is disabled
        by marking $M$ or enabled on its basic and test arcs by the
        transient marking, and that is not fired a state $s$, receives no reset order:\\
        $\forall{}t\in{}T_i,~
        \big(t\notin{}Sens(M)~\lor~t\in{}Sens_{bt}\big(M-\sum_{t_i\in{}Fired(s)}pre(t_i)\big)\big)
        \land{}t\in{}Fired(s)
        \Rightarrow{}reset'(t)=0$.
      % \item\label{item:reset-order} All the time transitions that are
      %   disabled by a basic or test arc\footnote{Inhibitor arcs are
      %     not considered here; indeed, the retrieval of tokens from an
      %     input place connected to a transition $t$ by an inhibitor
      %     arc can never disable $t$.} at the transient marking, (i.e,
      %   the marking resulting from the retrieval of tokens from the
      %   input places of fired transitions), or that belong to the set
      %   of fired
      %   transitions, receive a reset order, i.e.:\\
      %   $\forall{}t\in{}T_i,~t\notin{}Sens_{bt}\big(M-\sum_{t_i\in{}Fired(s)}pre(t_i)\big)\lor{}t\in{}Fired(s)
      %   \Rightarrow{}reset'(t)=1$.
      % \item\label{item:no-reset-order} All the time transitions that
      %   are sensitized by their basic and test arcs at
      %   the transient marking and do not belong to the set of fired transitions receive no reset order, i.e.:\\
      %   $\forall{}t\in{}T_i,~t\in{}Sens_{bt}\big(M-\sum_{t_i\in{}Fired(s)}pre(t_i)\big)\land{}t\notin{}Fired(s)
      %   \Rightarrow{}reset'(t)=0$.
      % \item\label{item:upper-reached} Time counters are locked for all
      %   time transitions that have reached the upper bound of their
      %   time intervals
      %   and were not fired at this clock cycle, i.e.:\\
      %   $\forall{}t\in{}T_i,~I(t)\ge{}upper(I_s(t))\wedge{}t\notin{}Fired(s)
      %   \Rightarrow{}I'(t)=\psi$.
      % \item\label{item:upper-not-reached} Time counters are unchanged
      %   for all the time transitions that have not yet reached the
      %   upper bound of their time
      %   intervals or were fired at this clock cycle, i.e.:\\
      %   $\forall{}t\in{}T_i,~I(t)=\psi\lor{}I(t)<{}upper(I_s(t))\lor{}t\in{}Fired(s)\Rightarrow$\\
      %   ${}I'(t)=I(t)$.
        
      \item\label{item:exec-fun} All functions associated with at least one fired transition ar executed, i.e:\\
        $\forall{}f\in{}\mathcal{F},~ex'(f)=\sum\limits_{t\in{}Fired(s)}\mathbb{F}(t,f)$.
      % \item\label{item:exec-fun} All the functions associated with
      %   fired transitions
      %   are executed, i.e.:\\
      %   $\forall{}f\in{}\mathcal{F},~\big(\exists{}t\in{}Fired(s),~\mathbb{F}(t,f)=1\big)
      %   \Rightarrow{}ex'(f)=1$.
      % \item\label{item:not-exec-fun} All the functions associated with none of the
      %   fired transitions are not executed, i.e.:\\
      %   $\forall{}f\in{}\mathcal{F},~\big(\forall{}t\in{}Fired(s),~\mathbb{F}(t,f)=0\big)
      %   \Rightarrow{}ex'(f)=0$.
      \end{enumerate}
    \end{itemize}
  \end{itemize}
\end{definition}

\subsection{SITPN Execution}
\label{sec:sitpn-exec}

\begin{definition}[SITPN Execution Cycle]
  For a given $sitpn\in{}SITPN$, two states $s,s''\in{}S(sitpn)$, a
  clock cycle count $\tau\in\mathbb{N}$, and an environment
  $E_c\in\mathbb{N}\rightarrow{}\mathcal{C}\rightarrow{}\mathbb{B}$,
  $sitpn$ passes from state $s$ to state $s''$ in one clock cycle,
  written $E,\tau\vdash{}sitpn,s\xrightarrow{\uparrow,\downarrow}s''$
  iff $\exists{}s'$
  s.t. $E_c,\tau\vdash{}sitpn,s\xrightarrow{\uparrow}s'$ and
  $E_c,\tau\vdash{}sitpn,s'\xrightarrow{\downarrow}s''$.
\end{definition}

\begin{definition}[SITPN Execution]
  For a given $sitpn\in{}SITPN$, a starting state $s\in{}S(sitpn)$, a
  clock cycle count $\tau\in\mathbb{N}$, and an environment
  $E_c\in\mathbb{N}\rightarrow{}\mathcal{C}\rightarrow{}\mathbb{B}$,
  $sitpn$ yields the execution trace $\theta$ from starting state $s$,
  written $E_c,\tau\vdash{}sitpn,s\rightarrow{}\theta$, by following
  the two rules below.
  
  \begin{tabular}{@{}l}
    {\fontsize{7}{10}\selectfont\textsc{ExecutionEnd}} \\
    
    {\begin{prooftree}[template={\fontsize{9}{12}\selectfont\inserttext}]
        \infer0 {$E_c,0\vdash$ $sitpn,s\rightarrow{}[~]$ }
      \end{prooftree}} 
  \end{tabular}  
  \begin{tabular}{@{}l}
    {\fontsize{7}{10}\selectfont\textsc{ExecutionLoop}} \\
    
    {\begin{prooftree}[template={\fontsize{8}{11}\selectfont\inserttext}]

        \hypo{$E_c,\tau\vdash{}sitpn,s\xrightarrow{\uparrow,\downarrow}s'$}

        \hypo{$E_c,\tau-1\vdash{}sitpn,s'\rightarrow{}\theta$}
        
        \infer2[$\tau>0$]{$E_c,\tau\vdash{}sitpn,s\rightarrow{}(s' :: \theta)$}
      \end{prooftree}} 
  \end{tabular}
\end{definition}

\begin{definition}[SITPN Full Execution]
  For a given $sitpn\in{}SITPN$, a clock cycle count
  $\tau\in\mathbb{N}$, and an environment
  $E_c\in\mathbb{N}\rightarrow{}\mathcal{C}\rightarrow{}\mathbb{B}$,
  $sitpn$ yields the execution trace $\theta$ starting from its
  initial state $s_0\in{}S(sitpn)$ (as defined in
  Def.~\ref{def:semantics}), written
  $E_c,\tau\vdash{}sitpn\rightarrow{}\theta$, by following the two
  rules below.
  
  \begin{tabular}{@{}l}
    {\fontsize{7}{10}\selectfont\textsc{FullExec0}} \\
    
    {\begin{prooftree}[template={\fontsize{8}{11}\selectfont\inserttext}]
        
        \infer0{$E_c,0\vdash{}sitpn\xrightarrow{full}[s_0]$}
      \end{prooftree}} 
  \end{tabular}
  
  \begin{tabular}{@{}l}
    {\fontsize{7}{10}\selectfont\textsc{FullExecCons}} \\
    
    {\begin{prooftree}[template={\fontsize{8}{11}\selectfont\inserttext}]
        \hypo{$E_c,\tau\vdash{}s_0\srarrow{\uparrow_0}{\fontsize{6}{8}\selectfont}s_0$}
        \hypo{$E_c,\tau\vdash{}s_0\srarrow{\downarrow}{\fontsize{6}{8}\selectfont}s$}
        \hypo{$E_c,\tau-1\vdash{}sitpn,s\rightarrow\theta_s$}
        \infer3[$\tau>0$]{$E_c,\tau\vdash{}sitpn\xrightarrow{full}(s_0 :: s :: \theta_s)$}
      \end{prooftree}} 
  \end{tabular}
\end{definition}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
