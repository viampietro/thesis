\chapter{Implementation of the \hilecop{} high-level models}
\label{chap:hilecop-models}

\section{SITPN Definitions}
\label{sec:sitpn-defs}

\subsection{SITPN Structure and Well-definition}
\label{sec:struct-and-wd}

\subsubsection{SITPN Structure}
\label{sec:sitpn-struct}

\begin{definition}[SITPN]
  \label{def:sitpn}
  A synchronously executed, extended, generalized, interpreted, and time Petri net
  with priorities is a tuple\\
  ${<}P,T,pre,post,M_0,{\succ},\mathcal{A},\mathcal{C},\mathcal{F},
  \mathbb{A},\mathbb{C},\mathbb{F},{I_s}{>}$, where we have:
  % 
  \begin{enumerate}
  \item $P=\{p_0,\ldots,p_n\}$, a finite set of places.
  \item $T=\{t_0,\ldots,t_m\}$, a finite set of transitions.
  \item
    $pre\in{}P\rightarrow{}T\nrightarrow(\mathbb{N}^{*}\times\{\mathtt{basic},\mathtt{inhib},\mathtt{test}\})$,
    the function associating a weight to place-transition edges.
  \item $post\in{}T\rightarrow{}P\nrightarrow\mathbb{N}^{*}$, the function
    associating a weight to transition-place edges.
  \item $M_0\in{}P\rightarrow\mathbb{N}$, the initial marking of the SITPN.
  \item $\succ\subseteq{}(T\times{}T)$, the priority relation which is a
    strict order over the set of transitions.
  \item $\mathcal{A}=\{a_0,\ldots,a_i\}$, a set of continuous actions.
  \item $\mathcal{C}=\{c_0,\ldots,c_j\}$, a set of conditions.
  \item $\mathcal{F}=\{f_0,\ldots,f_k\}$, a set of functions (discrete actions).
  \item $\mathbb{A}$ $\in$ ${}P$ $\rightarrow$ $\mathcal{A}$ $\rightarrow$ $\mathbb{B}$,
    the function associating actions to places.  $\forall{}p\in{}P$,
    $\forall{}a\in\mathcal{A}$, $\mathbb{A}(p,a)=\mathtt{true}$, if
    $a$ is associated to $p$, $\mathbb{A}(p,a)=\mathtt{false}$
    otherwise.
  \item $\mathbb{F}\in{}T\rightarrow\mathcal{F}\rightarrow\mathbb{B}$,
    the function associating functions to transitions.\\
    $\forall{}t\in{}T,~\forall{}f\in\mathcal{F},$
    $\mathbb{F}(t,f)=\mathtt{true}$, if $f$ is associated to $t$,
    $\mathbb{F}(t,f)=\mathtt{false}$ otherwise.
    
  \item $\mathbb{C} \in T \rightarrow \mathcal{C} \rightarrow\{-1,0,1\}$, the
    function associating conditions to transitions.\\
    $\forall t \in T$, $\forall c \in \mathcal{C}$,
    $\mathbb{C}(t,c)=1$, if $c$ is associated to $t$,
    $\mathbb{C}(t,c)=-1$, if $\bar{c}$ is associated to $t$,
    $\mathbb{C}(t,c)=0$ otherwise.
  \item $I_s\in{}T\nrightarrow\mathbb{I}^{+}$, the partial function
    associating static time intervals to transitions, where
    $\mathbb{I}^{+}\subseteq(\mathbb{N}^{*}\times(\mathbb{N^{*}}\sqcup\{\infty\}))$.
    $T_i$ denotes the definition domain of $I_s$, i.e. the set of time
    transitions.
  \end{enumerate}
\end{definition}

\paragraph{Conflict Definition} In the definition of an SITPN, the
priority relation is a mean to solve a situation of conflict in a pair
of transitions. We will keep the definition of a conflict as simple as
possible. Informally, the transitions of a pair are in conflict if
they have an common input place, and if both are linked to this input
place by a \texttt{basic} arc. Figure~\ref{fig:basic-conflict} depicts
a situation of conflict between two transitions.

At some point of the execution of the SITPN, the marking possibly
enables the two transitions of a conflicting pair in such a manner
that the firing of one transition disables the other; then, the
conflict is said to be \emph{effective}. The behavior of PNs is
fundamentally asynchronous, and a token can only be consumed by one
transition. However, in a synchronous setting as the one of the SITPN,
all transitions are first elected to be fired, and then all fired at
the same time.  Therefore, the situation can arise where a same token
is consumed by two transitions, on behalf of them being transitions in
effective conflict that are both elected to be fired (e.g,
Figure~\ref{fig:basic-conflict}). To prevent the phenomenon of
``double spending'', the well-definition property of an $SITPN$
enforces the resolution of all conflicts, i.e, to be able to decide
which transition in a conflicting pair will be fired when the conflict
becomes effective.

\begin{figure}[H]
  \centering
  \includegraphics[keepaspectratio,width=.3\linewidth]{Figures/SITPN/struct-conflict-with-basic}
  \caption{Example of conflict between two transitions}
  \label{fig:basic-conflict}
\end{figure}

The formal definition of a conflict is as follows:

\begin{definition}[Conflict]
  For a given $sitpn\in{}SITPN$, two transitions $t,t'\in{}T$ are in
  conflict if and only if there exists a place $p\in{}P$ such that
  $p\in{}input(t)\cap{}input(t')$ and there exist
  $n,m\in\mathbb{N}^{*}$ such that $pre(p,t)=(n,\mathtt{basic})$ and
  $pre(p,t')=(m,\mathtt{basic})$.
\end{definition}

A confict group qualifies a finite set of transitions that are all in
conflict with each other through the same place. In
Figure~\ref{fig:basic-conflict}, the set $\{t_0,t_1\}$ is a conflict
group.  The formal definition of a conflict group is as follows:

\begin{definition}[Conflict Group]
  For a given $sitpn\in{}SITPN$, $T_c\subseteq{}T$ is a conflict group
  if and only if there exists a place $p$ such that
  $\forall{}t\in{}output(p),\big(\exists{}n\in\mathbb{N}^{*},~pre(p,t)=(n,\mathtt{basic})\big)\Leftrightarrow{}t\in{}T_c$.
\end{definition}

Contrary to the statement made in \cite[p. 67]{Leroux2014}, we no more
consider the notion of conflict as being transitive. To illustrate
this, Figure~\ref{fig:conflict-not-trans} shows two conflict groups:
$\{t_0,t_1\}$ and $\{t_1,t_2\}$. In a well-defined $SITPN$ (see
Section~\ref{sec:sitpn-wd}), all conflicts in a conflict group must be
dealt with, i.e, for all pair of transitions in the group the conflict
must be solved. However, we no more consider transitions $t_0$ and
$t_2$ as in conflict. We argue that even when no conflict resolution
technique is applied between transitions in the same situation as
$t_0$ and $t_2$, the execution of the $SITPN$ can neither result in
the double-spending of a token, nor in the case where a transition is
not elected to be fired even though it ought to be. Therefore, we no
more consider the construction of merged conflict group (i.e, conflict
groups must be merged into one if their intersection is not empty;
e.g, $\{t_0,t_1,t_2\}$ in Figure~\ref{fig:conflict-not-trans}) as
being necessary.

\begin{figure}[H]
  \centering
  \includegraphics[keepaspectratio,width=.4\linewidth]{Figures/SITPN/conflict-not-trans}
  \caption{Example of two separate conflict groups}
  \label{fig:conflict-not-trans}
\end{figure}

\subsubsection{Well-definition of an SITPN}
\label{sec:sitpn-wd}

A given $sitpn\in{}SITPN$ is well-defined if it enforces some
properties needed on the \hilecop{} source models before the
transformation into \vhdl{}. If the properties, layed out in
Def.~\ref{def:wd-sitpn}, are not ensured, they will lead to
compile-time errors during the transformation into \vhdl{}.

\begin{definition}[Well-defined SITPN]\label{def:wd-sitpn}
  A given $sitpn\in{}SITPN$ is well-defined if and only if:
  \begin{itemize}
  \item $T\neq\emptyset$, the set of transitions must not be empty.
  \item $P\neq\emptyset$, the set of places must not be empty.
  \item There is no isolated place, i.e, a place that has neither
    input nor output transitions:\\
    $\nexists{}p\in{}P,~input(p)=\emptyset\wedge{}output(p)=\emptyset$,
    where $input(p)$ (resp. $output(p)$) denotes the set of input
    (resp. output) transitions of $p$.
  \item There is no isolated transition, i.e, a transition that has
    neither
    input nor output places:\\
    $\nexists{}t\in{}T,~input(t)=\emptyset\wedge{}output(t)=\emptyset$,
    where $input(t)$ (resp. $output(t)$) denotes the set of input
    (resp. output) places of $t$.
  \item All conflicts must be solved by a mean of mutual exclusion:
    priority relation, mutually exclusive conditions, mutually
    exclusive time intervals, structural mutual exclusion.
  \end{itemize}
\end{definition}

\subsection{SITPN State}
\label{sec:sitpn-state}

\begin{definition}[SITPN State]
  \label{def:sitpnstate}
  For a given $sitpn\in{}SITPN$, let $S(sitpn)$ be the set of possible
  states of $sitpn$. An SITPN state $s\in{}S(sitpn)$ is a tuple
  ${<}M,I,reset_t,ex,cond{>}$, where:
  \begin{enumerate}
  \item $M\in{}P\rightarrow\mathbb{N}$ is the current marking of sitpn.
  \item $I\in{}T_i{}\rightarrow\mathbb{N}\sqcup\{\psi\}$ is the
    function mapping time transitions to their current time counter
    value or to the value \emph{locked}.
  \item $reset_t\in{}T_i\rightarrow\mathbb{B}$ is the function mapping time
    transitions to time interval reset orders (defined as Booleans).
  \item $ex\in{}\mathcal{A}\sqcup\mathcal{F}\rightarrow\mathbb{B}$ is the function
    representing the current activation (resp. execution) state of actions
    (resp. functions).
  \item $cond\in\mathcal{C}\rightarrow\mathbb{B}$ is the function representing the
    current value of conditions (defined as Booleans).
  \end{enumerate}
\end{definition}

\subsection{Fired Transitions}
\label{sec:fired-trans}

\begin{remark}[Relations between markings]
  For all relation $\mathcal{R}$ existing between two marking
  functions $M$ and $M'$, the expression $\mathcal{R}(M,M')$ is a
  notation for $\forall{}p\in{}P,~\mathcal{R}(M(p),M'(p))$. For
  instance, $M'=M-\sum\limits_{t_i\in{}Pr(t)}pre(t_i)$ is a notation
  for
  $\forall{}p\in{}P,~M'(p)=M(p)-\sum\limits_{t_i\in{}Pr(t)}pre(p,t_i)$.
\end{remark}

\begin{remark}[Sum expressions and arc types]
  Many times in this document, we need to express the number of tokens
  coming in or out of places, after the firing of a certain subset of
  transitions. To do so, we use two kinds of sum expression:
  \begin{enumerate}
  \item The first kind of expression computes a number of output
    tokens. For instance, for a given place $p$,
    $\sum\limits_{t\in{}T'}pre(p,t)$ where $T'\subseteq{}T$. This
    expression is a notation for
    $\sum\limits_{t\in{}T'}\begin{cases}\omega~if~pre(p,t)=(\omega,\mathtt{basic})\\
      0~otherwise \\ \end{cases}$. Indeed, when computing a sum of
    output tokens (i.e, resulting of a firing process), we want to add
    to the sum the weight of the arc between place $p$ and a
    transition $t\in{}T'$ only if there exists an arc of type
    $\mathtt{basic}$ from $p$ to $t$ (remember that the test and
    inhibitor never lead to the withdrawal of tokens during the firing
    process). Otherwise, we add 0 to the sum as it is a neutral
    element of the addition operator over natural numbers.
  \item The second kind expression computes a number of input tokens.
    For instance, for a given place $p$,
    $\sum\limits_{t\in{}T'}post(p,t)$ where $T'\subseteq{}T$. This
    expression is a notation for
    $\sum\limits_{t\in{}T'}\begin{cases}\omega~if~post(t,p)=\omega\\
      0~otherwise \\ \end{cases}$. Here, we add the weight of the arc
    from $t$ to $p$ only if there exists such an arc; we add 0 to the
    sum otherwise.
  \end{enumerate}
  Therefore, in the remainder of the document, we will use the
  conciser notations $\sum\limits_{t\in{}T'}pre(p,t)$ to denote output
  token sums, and $\sum\limits_{t\in{}T'}post(t,p)$ to denote input
  token sums.
\end{remark}

\begin{definition}[Sensitization]
  A transition $t\in{}T$ is said to be sensitized by a marking $M$,
  which is noted $t\in{}Sens(M)$, if and only if
  $\forall{}p\in{}P,\omega\in\mathbb{N}^{*},~\big(pre(p,t)=(\omega,\mathtt{basic})\vee{}pre(p,t)=(\omega,\mathtt{test})\big)\Rightarrow{}M(p)\ge{}\omega$,
  and $pre(p,t)=(\omega,\mathtt{inhib})\Rightarrow{}M(p)<{}\omega$.
\end{definition}

\begin{definition}[Sensitization by test and basic arcs]
  A transition $t\in{}T$ is said to be sensitized by its basic and
  test arcs at a marking $M$, which is noted $t\in{}Sens_{bt}(M)$, if
  and only if
  $\forall{}p\in{}P,\omega\in\mathbb{N}^{*},~\big(pre(p,t)=(\omega,\mathtt{basic})\vee{}pre(p,t)=(\omega,\mathtt{test})\big)\Rightarrow{}M(p)\ge{}\omega$.
\end{definition}

\begin{definition}[Firability]
  \label{def:firable}
  A transition $t\in{}T$ is said to be firable at a state
  $s={<}M,I,reset_t,ex,cond{>}$, which is noted $t\in{}Firable(s)$, if
  and only if $t\in{}Sens(M)$, and $t\notin{}T_i$ or
  $I(t)\in{}I_s(t)$, and
  $\forall c \in \mathcal{C}, \mathbb{C}(t, c) = 1 \Rightarrow cond(c)
  = 1$ and $\mathbb{C}(t, c) = -1 \Rightarrow cond(c) = 0$.
\end{definition}

\begin{definition}[Fired]
  \label{def:fired}
  A transition $t\in{}T$ is said to be fired at the SITPN state
  $s={<}M,I,reset_t,ex,$ $cond{>}$, which is noted $t\in{}Fired(s)$, if
  and only if $t\in{}Firable(s)$ and
  $t\in{}Sens\big(M-\sum_{t_i\in{}Pr(t)}pre(t_i)\big)$, where
  $Pr(t)=\{t_i~|~t_i\succ{}t\wedge{}t_i\in{}Fired(s)\}$.
\end{definition}
    
\subsection{SITPN Semantics}
\label{sec:sitpn-sem}

\begin{definition}[SITPN Semantics]
  \label{def:semantics}
  The semantics of an SITPN is the transition system
  $<S,L,E,\rightsquigarrow>$ where:
  \begin{itemize}[label=-]
  \item $S$ is the set of states of the SITPN.
  \item
    $s_0=<M_0,O_\mathbb{N},O_\mathbb{B},O_\mathbb{B},O_\mathbb{B}>$
    is the initial state of the SITPN, where $M_0$ is the initial
    marking of the SITPN, $O_\mathbb{N}$ is a function that always
    returns 0, $O_\mathbb{B}$ is a function that always returns false.
  \item $L\subseteq{}Clk\times{}\mathbb{N}$ is the set of transition
    labels, where $Clk\in\{\uparrow,\downarrow\}$. A label is a couple $(clk,\tau)$
    composed of a clock event $clk\in{}Clk$, and a time value $\tau\in\mathbb{N}$
    expressing the current count of clock cycles.
  \item $E\in{}\mathbb{N}\rightarrow\mathcal{C}\rightarrow\mathbb{B}$ is the
    environment function, which gives (Boolean) values to conditions ($\mathcal{C}$)
    depending on the count of clock cycles ($\mathbb{N}$).
  \item $\rightsquigarrow\subseteq{}S\times{}L\times{}S$ is the state
    transition relation, which is noted
    $E,\tau\vdash{}s\stackrel{clk}{\rightsquigarrow}s'$ where
    $s,s'\in{}S$ and $(clk,\tau)\in{}L$, and which is defined as
    follows:
    % $s\xrsquigarrow{l}s'$
    \begin{itemize}
    \item $\forall\tau\in\mathbb{N}$,
      $E,\tau\vdash{}s\stackrel{\downarrow}{\rightsquigarrow}s'$,
      where $s=<M,I,reset_t,ex,cond>$ and\\
      $s'=<M,I',reset_t,ex',cond'>$, if:
      % $s\xrsquigarrow{(\downarrow,\tau)}s'$,
      \begin{enumerate}[label=(\arabic*)]
      \item\label{it:cond-env} $cond'$ is the function giving the (Boolean)
        values of conditions that are extracted from the environment at the clock count
        $\tau$, i.e.:\\
        $\forall{}c\in{}\mathcal{C},~cond'(c)=E(\tau,c)$.
      \item\label{it:activate-actions} All the actions associated
        with at least one
        marked place in the marking $M$ are activated, i.e.:\\
        $\forall{}a\in{}\mathcal{A},~ex'(a)=\sum\limits_{p\in{}marked(M)}\mathbb{A}(p,a)$
        where $p\in{}marked(M)\equiv{}M(p)>0$.
      \item\label{it:reset-counters} All the time transitions that are
        sensitized by the marking $M$ and received the order to reset
        their time intervals, have their time counter reset and
        incremented, i.e.:\\
        $\forall{}t\in{}T_i,~t\in{}Sens(M)\land{}reset_t(t)=1
        \Rightarrow{}I'(t)=1$.
      \item\label{it:inc-counters} All the time transitions with
        active time counters that are sensitized by the marking $M$
        and
        did not receive a reset order, have their time counters incremented, i.e.:\\
        $\forall{}t\in{}T_i,~t\in{}Sens(M)\land{}reset_t(t)=\mathtt{false}
        \land{}(I(t)\le{}upper(I_s(t))\lor{}upper(I_s(t))=\infty)\Rightarrow{}$
        $I'(t)=I(t)+1$.
      \item\label{it:locked-counters} All the time transitions
        verifying the same
        conditions as above, but with locked counters, keep having locked counters, i.e.:\\
        $\forall{}t\in{}T_i,~t\in{}Sens(M)\land{}reset_t(t)=\mathtt{false}
        \land{}I(t)>{}upper(I_s(t))\land{}upper(I_s(t))\neq\infty\Rightarrow{}$
        $I'(t)=I(t)$.
      \item\label{it:reset-not-sens} All the time transitions that
        are not sensitized by the marking $M$ have their time counters set to zero, i.e.:\\
        $\forall{}t\in{}T_i,~t\notin{}Sens(M)\Rightarrow{}I'(t)=0$.
      \end{enumerate}
    \item $\forall\tau\in\mathbb{N}$,
      $E,\tau\vdash{}s\stackrel{\uparrow}{\rightsquigarrow}s'$, where
      $s=<M,I,reset_t,ex,cond>$ and\\
      $s'=<M',I,reset_t',ex',cond>$, if:
      % $s'\xrsquigarrow{(\uparrow,\tau)}s''$,
      \begin{enumerate}[label=(\arabic*),resume]
      \item\label{it:new-marking} $M'$ is the new marking resulting
        from
        the firing of all the transitions contained in $Fired(s)$, i.e.:\\
        $M'=M-\sum\limits_{t\in{}Fired(s)}pre(t)+\sum\limits_{t\in{}Fired(s)}post(t)$.
      \item\label{it:reset-order} A time transition receives a reset
        order if it is fired at state $s$, or, if there exists a place
        $p$ connected to $t$ by a \texttt{basic} or \texttt{test arc}
        and at least one output transition of $p$ is fired and the
        transient marking of $p$ disables $t$; no reset order is sent otherwise:
        \begin{equation*}
          \begin{split}
            \forall{}t\in{}T_i,~& t\in{}Fired(s) \\
            & \lor\big(\exists{}p\in{}P,\omega\in\mathbb{N}^{*},~pre(p,t)=(\omega,\mathtt{basic})\lor{}pre(p,t)=(\omega,\mathtt{test}) \\
            & \quad\quad\land\sum\limits_{t_i\in{}Fired(s)}pre(p,t_i)>0 \\
            & \quad\quad\land{}s.M(p)-\sum\limits_{t_i\in{}Fired(s)}pre(p,t_i)<\omega\big)\Rightarrow{}reset'_t(t)=\mathtt{true}, \\
            & and~reset'_t(t)=\mathtt{false}~otherwise. \\
          \end{split}
        \end{equation*}
      \item\label{it:exec-fun} All functions associated with at least one fired transition ar executed, i.e:\\
        $\forall{}f\in{}\mathcal{F},~ex'(f)=\sum\limits_{t\in{}Fired(s)}\mathbb{F}(t,f)$.
      \end{enumerate}
    \end{itemize}
  \end{itemize}
\end{definition}

\subsection{SITPN Execution}
\label{sec:sitpn-exec}

\begin{definition}[SITPN Execution Cycle]
  For a given $sitpn\in{}SITPN$, two states $s,s''\in{}S(sitpn)$, a
  clock cycle count $\tau\in\mathbb{N}$, and an environment
  $E_c\in\mathbb{N}\rightarrow{}\mathcal{C}\rightarrow{}\mathbb{B}$,
  $sitpn$ passes from state $s$ to state $s''$ in one clock cycle,
  written $E,\tau\vdash{}sitpn,s\xrightarrow{\uparrow,\downarrow}s''$
  iff $\exists{}s'$
  s.t. $E_c,\tau\vdash{}sitpn,s\xrightarrow{\uparrow}s'$ and
  $E_c,\tau\vdash{}sitpn,s'\xrightarrow{\downarrow}s''$.
\end{definition}

\begin{definition}[SITPN Execution]
  For a given $sitpn\in{}SITPN$, a starting state $s\in{}S(sitpn)$, a
  clock cycle count $\tau\in\mathbb{N}$, and an environment
  $E_c\in\mathbb{N}\rightarrow{}\mathcal{C}\rightarrow{}\mathbb{B}$,
  $sitpn$ yields the execution trace $\theta$ from starting state $s$,
  written $E_c,\tau\vdash{}sitpn,s\rightarrow{}\theta$, by following
  the two rules below.
  
  \begin{tabular}{@{}l}
    {\fontsize{7}{10}\selectfont\textsc{ExecutionEnd}} \\
    
    {\begin{prooftree}
        \infer0 {E_c,0\vdash{}sitpn,s\rightarrow{}[~]}
      \end{prooftree}} 
  \end{tabular}
  
  \begin{tabular}{@{}l}
    {\fontsize{7}{10}\selectfont\textsc{ExecutionLoop}} \\
    
    {\begin{prooftree}[template={\inserttext}]

        \hypo{$E_c,\tau\vdash{}sitpn,s\xrightarrow{\uparrow}s'$}
        \hypo{$E_c,\tau\vdash{}sitpn,s'\xrightarrow{\downarrow}s''$}
        \hypo{$E_c,\tau-1\vdash{}sitpn,s''\rightarrow{}\theta$}
        
        \infer3[$\tau>0$]{$E_c,\tau\vdash{}sitpn,s\rightarrow{}(s' :: s'' :: \theta)$}
      \end{prooftree}} 
  \end{tabular}
\end{definition}

\begin{definition}[SITPN Full Execution]
  For a given $sitpn\in{}SITPN$, a clock cycle count
  $\tau\in\mathbb{N}$, and an environment
  $E_c\in\mathbb{N}\rightarrow{}\mathcal{C}\rightarrow{}\mathbb{B}$,
  $sitpn$ yields the execution trace $\theta$ starting from its
  initial state $s_0\in{}S(sitpn)$ (as defined in
  Def.~\ref{def:semantics}), written
  $E_c,\tau\vdash{}sitpn\rightarrow{}\theta$, by following the two
  rules below.
  
  \begin{tabular}{@{}l}
    {\fontsize{7}{10}\selectfont\textsc{FullExec0}} \\
    
    {\begin{prooftree}[template={\inserttext}]
        
        \infer0{$E_c,0\vdash{}sitpn\xrightarrow{full}[s_0]$}
      \end{prooftree}} 
  \end{tabular}
  \begin{tabular}{@{}l}
    {\fontsize{7}{10}\selectfont\textsc{FullExecCons}} \\
    
    {\begin{prooftree}[template={\inserttext}]
        \hypo{$E_c,\tau\vdash{}s_0\srarrow{\uparrow_0}{\fontsize{6}{8}\selectfont}s_0$}
        \hypo{$E_c,\tau\vdash{}s_0\srarrow{\downarrow}{\fontsize{6}{8}\selectfont}s$}
        \hypo{$E_c,\tau-1\vdash{}sitpn,s\rightarrow\theta_s$}
        \infer3[$\tau>0$]{$E_c,\tau\vdash{}sitpn\xrightarrow{full}(s_0 :: s_0 :: s :: \theta_s)$}
      \end{prooftree}} 
  \end{tabular}
\end{definition}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
