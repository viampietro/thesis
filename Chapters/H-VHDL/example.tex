In this section, we will demonstrate the full simulation of a \hvhdl{}
top-level design on the example of Listing~\ref{lst:tl-design-ex}. The
aim here is to illustrate the formal rules of the \hvhdl{}
semantics. Listing~\ref{lst:tl-design-ex} is the result of the
transformation of the SITPN model presented in
Figure~\ref{fig:sitpn-ex-full-sim} into a \hvhdl{} design. To keep the
examples within a reasonable size, Listing~\ref{lst:tl-design-ex}, and
the other listings and derivation trees used in this section, refer to
the generic constants and ports of the transition and place designs by
their short names. See Table~\ref{tab:consts-and-sigs-ref} for a
correspondence between the short names and the full names of constants
and signals of the place and transition designs.

\begin{lstlisting}[language=VHDL,label={lst:tl-design-ex},
caption={[An example of \hvhdl{} design generated by \hilecop{}.] An example of \hvhdl{} top-level design generated by the \hilecop{} transformation.},framexleftmargin=1.5em,xleftmargin=2em,numbers=left,
numberstyle=\tiny\ttfamily]
design tl tla

-- Generic constants
$\emptyset$

-- Ports ($ports_{tl}$)
((in, $id_{c0}$, boolean), (out, $id_{f0}$, boolean), (out, $id_{a0}$, boolean))

-- Declared (internal) signals ($sigs_{tl}$)
(($id_{ft}$, boolean), ($id_{av}$, boolean), ($id_{rt}$, boolean),($id_m$, boolean))

-- Behavior ($cs_{tl}$)

-- Place component instance $id_p$
comp ($id_p$, place,
-- Generic map
((ian, 1), (oan, 1), (mm, 1)),

-- Input port map
((im, 1), (iaw(0), 1), (oat(0), 0), (oaw(0), 1), (itf(0), $id_{ft}$), (otf(0), $id_{ft}$))

-- Output port map
((oav(0), $id_{av}$), (pauths, open), (rtt(0), $id_{rt}$), (marked, $id_m$)))

||

-- Transition component instance $id_t$
comp ($id_t$, transition,
-- Generic map
((tt, 0), (ian, 1), (cn, 1)),

-- Input port map
((ic(0), $id_{c0}$), (A, 0), (B, 0), (iav(0), $id_{av}$), (rt(0), $id_{rt}$), (pauths(0), true)),

-- Output port map
((fired, $id_{ft}$)))

||

-- The marked process
process (marked, {clk}, $\emptyset$,
(rst ($id_{a0}$ <= false)
     (falling ($id_{a0}$ <= $id_m$ or false))))

||

-- The fired process
process (fired, {clk}, $\emptyset$,
(rst ($id_{f0}$ <= false)
     (rising ($id_{f0}$ <= $id_{ft}$ or false))))
\end{lstlisting}

\begin{figure}[H]
  \centering
  \includegraphics[keepaspectratio,width=.15\textwidth]{Figures/H-VHDL/sitpn-ex-full-sim}
  \caption[An SITPN model transformed into a \hvhdl{} top-level design.]{The SITPN model at the base of the generation of the top-level design presented in Listing~\ref{lst:tl-design-ex}.}
  \label{fig:sitpn-ex-full-sim}
\end{figure}

The following rule states that the full simulation of the \texttt{tl}
design (presented in Listing~\ref{lst:tl-design-ex}) over 1 clock
cycle yields the simulation trace $(\sigma_0::\sigma_1::\sigma_2)$.
The simulation over one clock cycle (the rightmost premise) yields a
trace composed of the two states: the state $\sigma_1$ at half the
clock period, and the state $\sigma_2$ at the end of the first
cycle. The full simulation happens in the context of the \hilecop's
design store $\mathcal{D}_\mathcal{H}$, the elaborated design
$\Delta$, an empty dimensioning function and an simulation environment
$E_p$. Here, $ports_{tl}$ is an alias for the list of ports of
\texttt{tl}, $sigs_{tl}$ for the list of internal signals of
\texttt{tl}, and $cs_{tl}$ for the behavior of \texttt{tl}. In what
follows, we will detail the premises of the \textsc{FullSim} rule.

\begin{figure}[H]
  \begin{prooftree}[template={\fontsize{11}{12}\selectfont\inserttext}]

    % Design elab.
    \hypo{}
    \ellipsis{}{}
    \infer1{$\mathcal{D}_\mathcal{H},\emptyset\vdash$ \vhdle|design tl| $\dots\xrightarrow{elab}\Delta,\sigma_e$}

    % Initialization.
    \hypo{}
    \ellipsis{}{}
    \infer1{$\mathcal{D}_\mathcal{H},\Delta,\sigma_e\vdash{}cs_{tl}\xrightarrow{init}\sigma_0$}
       
    % Simulation loop.
    \hypo{}
    \ellipsis{}{}
    \infer1{$\mathcal{D}_\mathcal{H},E_p,\Delta,1,\sigma_0\vdash{}cs_{tl}\rightarrow(\sigma_1::\sigma_2)$}
    
    \infer3[\fontsize{7}{10}\selectfont\textsc{FullSim}]{
        $\mathcal{D}_\mathcal{H},\Delta,\emptyset,E_p,1\vdash$      
        \vhdle|design tl tla| $\empty$ $ports_{tl}$ $sigs_{tl}$ $cs_{tl}$ $\xrightarrow{full}(\sigma_0::\sigma_1::\sigma_2)$
    }
  \end{prooftree}
  \label{fig:ex-full-sim-tl}
  \caption{The \textsc{FullSim} rule applied to the \texttt{tl} design.}
\end{figure}

\subsection{Elaboration of the \texttt{tl} design}
\label{sec:ex-elab-of-tl}

The following rule state the elaborated design $\Delta$ and the
default design state $\sigma_e$ are the result of the elaboration of
the \texttt{tl} design. From left to right in the premises of the
rule, the three premises pertain to the elaboration of the declarative
parts of the \texttt{tl} design, i.e. the generic constant declaration
list, the port declaration list and the internal signal declaration
list. The leftmost premise pertains to the elaboration of the behavior
of the \texttt{tl} design.

\begin{figure}[H]
  \begin{prooftree}[template={\fontsize{9}{12}\selectfont\inserttext}]

    % Gens elab.
    \hypo{}
    \ellipsis{}{}
    \infer1{$\emptyset,\emptyset\vdash{}gens_{tl}\xrightarrow{egens}\Delta_0$}

    % Ports elab.
    \hypo{}
    \ellipsis{}{}
    \infer1{ $\Delta_0,\emptyset\vdash$
      $ports_{tl}\xrightarrow{eports}\Delta_1,\sigma_{e1}$}

    % Sigs elab.
    \hypo{}
    \ellipsis{}{}
    \infer1{
      $\Delta_1,\sigma_{e1}\vdash$
      $sigs_{tl}\xrightarrow{esigs}\Delta_2,\sigma_{e2}$}

    % Behavior elab.
    \hypo{}
    \ellipsis{}{}
    \infer1{$\mathcal{D}_\mathcal{H},\Delta_2,\sigma_{e2}\vdash$
      $cs_{tl}\xrightarrow{ebeh}\Delta,\sigma_e$}
        
    \infer4[\fontsize{7}{10}\selectfont\textsc{DesignElab}]{
      {\fontsize{12}{12}\selectfont
      $\mathcal{D}_\mathcal{H},\emptyset\vdash$
      \vhdle|design tl tla| $gens_{tl}$ $ports_{tl}$ $sigs_{tl}$ $cs_{tl}$
      $\xrightarrow{elab}\Delta,\sigma_e$}
    }
  \end{prooftree}
  \caption{The \textsc{DesignElab} rule applied to the \texttt{tl} design.}
  \label{fig:ex-elab-tl}
\end{figure}

\subsubsection{Elaboration of the declarative parts}
\label{sec:ex-elab-decl}

The elaboration of the declarative parts populates the $Gens$, $Ins$,
$Outs$ and $Sigs$ sub-environments of the elaborated design
$\Delta$. Here is the content of the $Gens$, $Ins$, $Outs$ and $Sigs$
sub-environments of $\Delta_2$, where $\Delta_2$ is the partial
elaborated design after the elaboration of the declarative parts of
the \texttt{tl} design (passed as a parameter of third and the fourth
premises of the rule described in Figure~\ref{fig:ex-elab-tl}).

\begin{itemize}
\item $Gens(\Delta_2):=\emptyset$
\item $Ins(\Delta_2):=\{(id_{c0}, bool)\}$
\item $Outs(\Delta_2):=\{(id_{f0}, bool), (id_{a0}, bool)\}$
\item $Sigs(\Delta_2):=\{(id_{ft}, bool), (id_{av}, bool), (id_{rt}, bool), (id_m, bool)\}$
\end{itemize}

The top-level design generated by the \hilecop{} transformation all
have an empty list of generic constants (see
Chapter~\ref{chap:transformation} for more details about the
transformation). Also, all ports and internal signals are of the
Boolean type. Thus, there are no range constraint or index constraint
to solve here. The \texttt{boolean} type indication is simply
transformed into the $bool$ semantic type.

The elaboration of the declarative parts also gives a default value to
the signals in the signal store of the default design state
$\sigma_{e2}$, where $\sigma_{e2}$ is the partial default design state
at the end of the elaboration of the declarative parts of the
\texttt{tl} design (passed as a parameter of the third and the fourth
premises of the rule described in Figure~\ref{fig:ex-elab-tl}).  Here
is the content of the signal store $\mathcal{S}$ of $\sigma_{e2}$.

\begin{itemize}
\item
  $\mathcal{S}(\sigma_{e2}):=\{(id_{c0},\bot),(id_{f0},\bot),(id_{a0},\bot),(id_{ft},
  \bot), (id_{av}, \bot), (id_{rt}, \bot), (id_m, \bot)\}$
\end{itemize}

The default value associated to the $bool$ type is $\bot$, thus, all
signals of the \texttt{tl design} are initialized to $\bot$ in the
signal store of $\sigma_{e2}$.

\subsubsection{Elaboration of the behavioral part}
\label{sec:ex-elab-beh}

The behavior of the \texttt{tl} design contains two component
instantiation statements and two process statements. Each one of these
statements will be elaborated in sequence. First, we present the
elaboration of the \texttt{marked} process to illustrate the
elaboration of a process statement; then, we present the elaboration
of place component instance $id_p$ to illustrate the elaboration of a
component instantiation statement.

\paragraph{Elaboration of a process statement}

The following rule presents the elaboration of the \texttt{marked}
process defined in the behavior of the \texttt{tl} design.

\begin{figure}[H]
  \begin{prooftree}[template={\fontsize{11}{12}\selectfont\inserttext}]

    % Sigs elab.
    \infer0{
      $\Delta_2,\emptyset\vdash$
      $\emptyset\xrightarrow{evars}\emptyset$}

    % Behavior elab.
    \hypo{}
    \ellipsis{}{}
    \infer1[\fontsize{7}{10}\selectfont\textsc{WTRst}]{$\Delta_2,\sigma_{e2},\emptyset\vdash$
      $\mathtt{valid}_{ss}\Big($
      \begin{tabular}{@{}l@{}}
        $\mathtt{rst}~(id_{a0}\Leftarrow{}\mathtt{false})$ \\
        $(\mathtt{falling}(id_{a0}\Leftarrow{}id_m~\mathtt{or}~\mathtt{false}))$ \\
      \end{tabular}$\Big)$}
    
    \infer2[\fontsize{7}{10}\selectfont\textsc{PsElab}]{
      {\fontsize{12}{12}\selectfont
        $\mathcal{D}_\mathcal{H},\Delta_2,\sigma_{e2}\vdash$
        \vhdle|process(marked, {clk},| $\emptyset$, $\dots$)
        $\xrightarrow{ebeh}\Delta_2\cup(\mathtt{marked},\emptyset),\sigma_{e2}$}
    }
  \end{prooftree}
  \caption{The elaboration of the \texttt{marked} process defined in
    the behavior of the \texttt{tl} design.}
  \label{fig:ex-elab-marked-ps}
\end{figure}


The \texttt{marked} process is elaborated in the context
$\mathcal{D}_\mathcal{H},\Delta_2,\sigma_{e2}$ where $\Delta_2$ and
$\sigma_{e2}$ are the partially-built elaborated design and default
design state at a certain point of the elaboration of the behavioral
part of the \texttt{tl} design. The elaboration of a process statement
associates the process identifier to a local variable environment in
the $Ps$ sub-environment of the being-built elaborated design. The
local variable environment is built out of the variable declaration
list of the process. Here, the \texttt{marked} process has an empty
variable declaration list. Thus, the binding
(\texttt{marked},$\emptyset$) is added in the $Ps$ sub-environment of
$\Delta_2$.  % As other concurrent statements could have been
% elaborated before the \texttt{marked} process, the $\Delta_2$ and
% $\sigma_{e2}$ of the above rule are not necessarily equal the
% $\Delta_2$ and $\sigma_{e2}$ of the rightmost premise of
% Figure~\ref{fig:ex-elab-tl}.
% The elaboration of the behavior of a design only acts on the $Ps$ and
% $Comps$ sub-environments of the being-built elaborated design, and
% only of the component store of the being-built default design
% state. Thus, we have $Gens(\Delta_2)=Gens(Delta)$,
% $Ins(\Delta_2)=Ins(\Delta)$, $Outs(\Delta_2)=Outs(\Delta)$ and
% $Sigs(\Delta_2)=Sigs(\Delta)$ where $\Delta$ is the final elaborated
% design. Also, we have $\mathcal{S}(\sigma_{e2})=\mathcal{S}(\sigma_e)$
% where $\sigma_e$ is the final default design state.

The elaboration of process statement also performs static
type-checking on the process statement body leveraging the
$\mathtt{valid}_{ss}$ relation. The following rule details the static
type-checking of the statement body of the \texttt{marked} process
(rightmost premise of the rule presented in
Figure~\ref{fig:ex-elab-marked-ps}). To keep the example within a
reasonable size, we do not detail the context of all rules. We
annotate the rule names to describe the side conditions associated to
a derivation.

\begin{figure}[H]
  \begin{prooftree}[template={\fontsize{11}{12}\selectfont\inserttext}]

    % First rst block
    \infer0[\fontsize{7}{10}\selectfont\textsc{False}]{$\mathtt{false}\xrightarrow{e}\bot$}
    \infer0[\fontsize{7}{10}\selectfont\textsc{IsBool}]{$\bot\in_c{}bool$}
    \infer2[\fontsize{7}{10}\selectfont\textsc{WTSig}$^1$]{$\vdash{}\mathtt{valid}_{ss}(id_{a0}\Leftarrow{}\mathtt{false})$}

    % Second rst block
    \infer0[\fontsize{7}{10}\selectfont\textsc{Sig}$^{2}$]{$id_m\xrightarrow{e}\bot$}
    \infer0[\fontsize{7}{10}\selectfont\textsc{False}]{$\mathtt{false}\xrightarrow{e}\bot$}
    \infer2[\fontsize{7}{10}\selectfont\textsc{BoolBinOp}]{$\vdash{}id_m~\mathtt{or}~\mathtt{false}\xrightarrow{e}\bot$}
    \infer0[\fontsize{7}{10}\selectfont\textsc{IsBool}]{$\bot\in_c{}bool$}
    \infer2[\fontsize{7}{10}\selectfont\textsc{WTSig}$^{1}$]{$\vdash{}\mathtt{valid}_{ss}(id_{a0}\Leftarrow{}id_m~\mathtt{or}~\mathtt{false})$}
    \infer1[\fontsize{7}{10}\selectfont\textsc{WTFalling}]{$\vdash{}\mathtt{valid}_{ss}(\mathtt{falling}(id_{a0}\Leftarrow{}id_m~\mathtt{or}~\mathtt{false}))$}
    
    % Conclusion
    \infer2[\fontsize{7}{10}\selectfont\textsc{WTRst}]{$\Delta_2,\sigma_{e2},\emptyset\vdash$
      $\mathtt{valid}_{ss}\Big($
      \begin{tabular}{@{}l@{}}
        $\mathtt{rst}~(id_{a0}\Leftarrow{}\mathtt{false})$ \\
        $(\mathtt{falling}(id_{a0}\Leftarrow{}id_m~\mathtt{or}~\mathtt{false}))$ \\
      \end{tabular}$\Big)$}
    
  \end{prooftree}
  \caption{Static type-checking of the \texttt{marked} process
    statement body.}
  \label{fig:ex-wt-marked-ps}
\end{figure}

\noindent{}where:
\begin{enumerate}
\item $\Delta_2(id_{a0})=bool$
\item $\sigma_{e2}(id_m)=\bot$
\end{enumerate}

At the end of the elaboration of the \texttt{tl} design's behavior,
the $Ps$ sub-environment of $Delta$ is as follows:
$Ps(\Delta):=\{(\mathtt{marked},\emptyset),
(\mathtt{fired},\emptyset)\}$

\paragraph{Elaboration of a component instantiation statement}

The rule of Figure~\ref{fig:ex-elab-pci-idp} presents the elaboration
of the place component instance $id_p$ belonging to the behavior of
the \texttt{tl} design.

\begin{figure}[H]
  \begin{prooftree}[template={\fontsize{9}{10}\selectfont\inserttext}, separation=4pt]

    % Dimensioning function
    \hypo{}
    \ellipsis{}{}
    \infer1{$\emptyset\vdash{}g_p\xrightarrow{emapg}\mathcal{M}$}

    % Elaboration of the place design
    \hypo{}
    \ellipsis{}{}
    \infer1[\fontsize{7}{10}\selectfont]{
      $\mathcal{D}_\mathcal{H},\mathcal{M}\vdash\mathtt{design}~\mathtt{place}\dots\xrightarrow{elab}\Delta_p,\sigma_p$
    }

    % Valid ipmap
    \hypo{}
    \ellipsis{}{}
    \infer1{
      $\Delta_2,\Delta_p,\sigma_{e2}\vdash{}\mathtt{valid}_{ipm}(i_p)$
    }

    % Valid opmap
    \hypo{}
    \ellipsis{}{}
    \infer1{
      $\Delta_2,\Delta_p\vdash{}\mathtt{valid}_{opm}(o_p)$
    }
    
    % Conclusion
    \infer4[\fontsize{7}{10}\selectfont\textsc{CompElab}$^{1}$]{
      {\fontsize{11}{13}\selectfont
        $\mathcal{D}_\mathcal{H},\Delta_2,\sigma_{e2}\vdash$
        $\mathtt{comp}~(id_p,\mathtt{place},g_p,i_p,o_p)\xrightarrow{ebeh}$
        $\Delta_2\cup(id_p,\Delta_p),\sigma_{e2}\cup(id_p,\sigma_p)$}
    }
    
  \end{prooftree}
  \caption{The elaboration of the $id_p$ component instance defined in
    the behavior of the \texttt{tl} design.}
  \label{fig:ex-elab-pci-idp}
\end{figure}

\noindent{}where:

\begin{enumerate}
\item
  \begin{tabular}{@{}l@{}}
    $id_p\notin\Delta_2$ \\
    $id_p\notin{}\sigma_{e2}$ \\
    $\mathtt{place}\in\mathcal{D}_\mathcal{H}$ \\
    $\mathcal{M}\subseteq{}Gens(\Delta_p)$ \\
  \end{tabular}
\end{enumerate}

The elaboration of a component instantiation statement is divided in
three parts. First, a dimensioning function is built out of the
generic map of the component instance. Figure~\ref{fig:ex-emapg} shows
a part of the creation of the dimensioning functioning $\mathcal{M}$
from the generic map of the component instance $id_p$. Basically, the
elaboration of a generic map is a transformation from a syntactic
construct, i.e. the generic map, into a function, i.e. the
dimensioning function $\mathcal{M}$. For each association of the
generic map, the elaboration checks that the actual part of the
association is a locally static expression (see
Section~\ref{subsubsec:loc-static}).

\begin{figure}[H]
  \begin{prooftree}[template={\fontsize{10}{13}\selectfont\inserttext}, separation=10pt]

    % Elab of assocg
    \infer0[\fontsize{7}{10}\selectfont\textsc{LSENat}]{$SE_l(1)$}
    \infer0[\fontsize{7}{10}\selectfont\textsc{Nat}]{$1\xrightarrow{e}1$}
    \infer2[\fontsize{7}{10}\selectfont\textsc{AssocGElab}$^1$]{$\emptyset\vdash{}(\mathtt{ian},1)\xrightarrow{emapg}$
      $\{(\mathtt{ian},1)\}$}

    % Ind. call
    \hypo{}
    \ellipsis{}{}
    \infer1[\fontsize{7}{10}\selectfont\textsc{GMElab}]{$\{(\mathtt{ian},1)\}\vdash{}(\mathtt{oan},1),(\mathtt{mm},1)\xrightarrow{emapg}$
      $\{(\mathtt{ian},1),(\mathtt{oan},1),(\mathtt{mm},1)\}$}
    
    % Conclusion 
    \infer2[\fontsize{7}{10}\selectfont\textsc{GMElab}]{$\emptyset\vdash{}(\mathtt{ian},1),(\mathtt{oan},1),(\mathtt{mm},1)\xrightarrow{emapg}$
      $\{(\mathtt{ian},1),(\mathtt{oan},1),(\mathtt{mm},1)\}$}
    
  \end{prooftree}
  \caption{The elaboration of the generic map of the $id_p$ component
    instance defined in the behavior of the \texttt{tl} design.}
  \label{fig:ex-emapg}
\end{figure}

\noindent{}where:
\begin{enumerate}
\item $\mathtt{ian}\notin\emptyset$
\end{enumerate}

The second step of the elaboration of a component instance is to
retrieve from the design store the design associated with the
component instance, and to elaborate this design. Here, the design
store is the \hilecop{} design store $\mathcal{D}_\mathcal{H}$, and
the design associated with $id_p$ is the \texttt{place} design. The
dimensioning function $\mathcal{M}$ sets the value of the generic
constants declared in the \texttt{place} design.  The full code of
\texttt{place} design is available in
Appendix~\ref{app:place-design}. In
Figures~\ref{fig:ex-elab-version-of-idp} and
\ref{fig:ex-default-state-of-idp}, we give the elaborated design
$\Delta_p$ and the default design state $\sigma_p$ resulting of the
elaboration of the \texttt{place} design given the dimensioning
function $\mathcal{M}$.

\begin{figure}[H]
\begin{tabular}{@{}rl@{}}
  $\Delta_p:=\{$ & \\
               & \begin{tabular}{@{}ll@{}}
                   $Gens := $ & $\{(\mathtt{ian}, (nat(0,\mathtt{NATMAX}, 1)),$ \\
                              & $(\mathtt{oan}, (nat(0,\mathtt{NATMAX}), 1))$ \\
                              & $(\mathtt{mm}, (nat(0,\mathtt{NATMAX}), 1))\}$ \\
                 \end{tabular} \\
               & \\
               & \begin{tabular}{@{}ll@{}}
                   $Ins :=$ & $\{(\mathtt{im}, nat(0,1)),$ \\
                            & $(\mathtt{iaw}, array(nat(0,255),0,0)),$ \\
                            & $(\mathtt{oat}, array(nat(0,2),0,0)),$ \\
                            & $(\mathtt{oaw}, array(nat(0,255),0,0)),$ \\
                            & $(\mathtt{itf}, array(bool,0,0)),$ \\
                            & $(\mathtt{otf}, array(bool,0,0))\},$ \\
                 \end{tabular} \\
               & \\
               & \begin{tabular}{@{}ll@{}}
                   $Outs :=$ & $\{(\mathtt{oav}, array(bool,0,0)),$ \\
                             & $(\mathtt{pauths}, array(bool,0,0)),$ \\
                             & $(\mathtt{rtt}, array(bool,0,0))\}$ \\
                 \end{tabular} \\
                 & \\
               & \begin{tabular}{@{}ll@{}}
                   $Sigs :=$ & $\{(\mathtt{sits}, nat(0,1)),$ \\
                             & $(\mathtt{sm}, nat(0,1)),$ \\
                             & $(\mathtt{sots}, nat(0,1))\},$ \\
                 \end{tabular} \\
               & \\
               & \begin{tabular}{@{}ll@{}}
                   $Ps :=$ & $\{(\mathtt{input\_tokens\_sum}, \{("v\_internal\_its", (nat(0,1), 0))\}),$ \\
                           & $(\mathtt{output\_tokens\_sum}, \{("v\_internal\_ots", (nat(0,1), 0))\})\}$ \\
                           & $(\mathtt{priority\_evaluation}, \{("v\_saved\_ots", (nat(0,1), 0))\})\}$ \\
                 \end{tabular} \\
               & \\
               & $Comps := \emptyset$ \\
  $\}$ &  \\
\end{tabular}

\caption[An elaborated version of the place design with a given
dimensioning function.]{An elaborated version of the place design
  built with the dimensioning function deduced from the generic map of
  the component instance $id_p$.}
\label{fig:ex-elab-version-of-idp}
\end{figure}

In $\Delta_p$, all the types associated with ports and internal
signals of the \texttt{place} design have been \emph{resolved};
i.e. the expressions qualifying the bounds of the range and index
constraints in type indications have been evaluated.  For example,
\texttt{array(boolean, 0, input_arcs_number-1)} is the type indication
associated with the \texttt{input_transitions_fired} input port
(i.e. \texttt{itf}) defined in the port clause of the \texttt{place}
design. The dimensioning function $\mathcal{M}$ sets the value of the
\texttt{input_arcs_number} (i.e. \texttt{ian}) generic constant to
1. After the elaboration, the type indication \texttt{array(boolean,
  0, input_arcs_number-1)} is thus transformed into the semantic type
$array(bool, 0, 0)$. Thus, we have
$\Delta_p(\mathtt{itf})=array(bool,0,0)$ in the resulting $\Delta_p$.

Figure~\ref{fig:ex-default-state-of-idp} shows the default design
state $\sigma_p$ of $\Delta_p$.

\begin{figure}[H]
  \begin{tabular}{@{}rl@{}}
    $\sigma_p:=\{$ & \\
                   & \begin{tabular}{@{}ll@{}}
                       $\mathcal{S} :=$ & $\{(\mathtt{im}, (0)),$ $(\mathtt{iaw}, (0)),$ $(\mathtt{oat}, (0)),$\\
                                        & $(\mathtt{oaw}, (0)),$ $(\mathtt{itf}, (\bot)),$ $(\mathtt{otf}, (\bot)),$ \\
                                        & $(\mathtt{oav}, (\bot)),$ $(\mathtt{pauths},(\bot)),$ $(\mathtt{rtt},(\bot))$ \\
                                        & $(\mathtt{sits}, 0),$ $(\mathtt{sm}, 0),$ $(\mathtt{sots}, 0)\},$ \\
                     \end{tabular} \\
                   & \\
                   & $\mathcal{C}:=\emptyset$ \\
                   & $\mathcal{E}:=\emptyset$ \\
    $\}$ &  \\
  \end{tabular}

\caption[An example of default design state for the place design.]{The
  default design state $\sigma_p$ of the elaborated design $\Delta_p$.}
\label{fig:ex-default-state-of-idp}
\end{figure}

The component store of design state $\sigma_p$ is empty as there are
no component instantiation statements in the behavior of the place
design. The same stands for the $Comps$ sub-environment of $\Delta_p$.
Also, the set of events of a default design state is always empty.

The final step in the elaboration of a component instantiation
statement is to check the well-formedness and the well-typedness of
the input and output port maps. The $\mathtt{valid}_{ipm}$ and
$\mathtt{valid}_{opm}$ relations, defined in
Section~\ref{subsec:valid-pm}, state the validity of the port maps.
The rule of Figure presents a part of the construction of the
$valid_{opm}$ relation applied to the output port map of the place
component instance $id_p$. Note that $\Delta_p$ is necessary to check
the validity of the output port map of $id_p$, as it holds the
correspondence between port identifiers and port types.

\begin{figure}[H]
  \centering
  \begin{prooftree}[template={\fontsize{10}{13}\selectfont\inserttext}]

    % Elab of assocop
    \infer0[\fontsize{7}{10}\selectfont\textsc{LSENat}]{$SE_l(0)$}
    \infer0[\fontsize{7}{10}\selectfont\textsc{Nat}]{$0\xrightarrow{e}0$}
    \infer0[\fontsize{7}{10}\selectfont\textsc{IsCNat}]{$0\in_c{}nat(0,0)$}
    \infer3[$^1$]{
      $\Delta_2,\Delta_p,\emptyset,\emptyset\vdash$
      $(\mathtt{oav}(0), id_{av})$
      $\xrightarrow{list_{opm}}$
      $\{(\mathtt{oav}, 0)\},\{id_{av}\}$
    }

    % Ind. call
    \hypo{}
    \ellipsis{\fontsize{7}{10}\selectfont\textsc{ListOPMCons}$_B$}{}

    % List OPM
    \infer2[\fontsize{7}{10}\selectfont\textsc{ListOPMCons}$_A$]{
      $\Delta_2,\Delta_p,\emptyset,\emptyset\vdash$
      \begin{tabular}{@{}l@{}}
        $(\mathtt{oav}(0), id_{av}),$ $(\mathtt{pauths}, \mathtt{open})$ \\
        $(\mathtt{rtt}(0), id_{rt}),$ $(marked, id_m)$ \\
      \end{tabular}
      $\xrightarrow{list_{opm}}$
      \begin{tabular}{@{}l@{}}
        $\{(\mathtt{oav}, 0), \mathtt{pauths},$ \\
        $(\mathtt{rtt}, 0), \mathtt{marked}\}$ \\
      \end{tabular},
      \begin{tabular}{@{}l@{}}
        $\{id_{av}, id_{rt}, id_m\}$ \\
      \end{tabular}
    }
    
    % Conclusion 
    \infer1[\fontsize{7}{10}\selectfont\textsc{ValidOPM}]{
      $\Delta_2,\Delta_p\vdash$
      $\mathtt{valid}_{opm}\Big($
      \begin{tabular}{@{}l@{}}
        $(\mathtt{oav}(0), id_{av}),$ $(\mathtt{pauths}, \mathtt{open})$ \\
        $(\mathtt{rtt}(0), id_{rt}),$ $(\mathtt{marked}, id_m)$ \\
      \end{tabular}
      $\Big)$
    }
    
  \end{prooftree}
  
  \vspace{40pt}
  
  \begin{prooftree}[template={\fontsize{10}{13}\selectfont\inserttext}, separation=10pt]
    % Ind. call
    \hypo{}
    \ellipsis{}{}
    \infer1[\fontsize{7}{10}\selectfont\textsc{ListOPMCons}$_B$]{
      {$\Delta_2,\Delta_p,\{(\mathtt{oav},0)\},\{id_{av}\}\vdash$
        \begin{tabular}{@{}l@{}}
          $(\mathtt{pauths}, \mathtt{open}),$ \\
          $(\mathtt{rtt}(0), id_{rt}),$ \\
          $(marked, id_m)$ \\
        \end{tabular}
        $\xrightarrow{list_{opm}}$
        \begin{tabular}{@{}l@{}}
          $\{(\mathtt{oav}, 0),$ \\
          $\mathtt{pauths},$ \\
          $(\mathtt{rtt}, 0),$ \\
          $\mathtt{marked}\}$ \\
        \end{tabular},
        \begin{tabular}{@{}l@{}}
          $\{id_{av}, id_{rt}, id_m\}$ \\
        \end{tabular}}
    }

  \end{prooftree}
  
  \caption{An example of validity checking performed on the output
    port map of the place component instance $id_p$. The bottom proof
    tree represents the top-right premise of the top proof tree.}
  \label{fig:ex-valid-opm}
\end{figure}

\noindent{}where:
\begin{enumerate}
\item
  \begin{tabular}{@{}l@{}}
    $\Delta_p(\mathtt{oav})=array(bool,0,0)$ \\
    $\Delta_2(id_{av})=bool$ \\
    $\mathtt{oav}\notin\emptyset$ and $(\mathtt{oav},0)\notin\emptyset$ \\
    $id_{av}\notin\emptyset$ \\
  \end{tabular}
\end{enumerate}

At the end of the elaboration of the \texttt{tl} design's behavior,
the $Comps$ sub-environment of $\Delta$ is as follows:
$Comps(\Delta):=\{(id_p,\Delta_p), (id_t,\Delta_t)\}$. Here,
$\Delta_t$ represents the elaborated version of the transition design
obtained from the elaboration of the transition component instance
$id_t$.

Also, at the end of the elaboration, the component store of $\sigma_e$
is as follows:
$\mathcal{C}(\sigma_e):=\{(id_p,\sigma_p),(id_t,\sigma_t)\}$. Here,
$\sigma_t$ is the default design state of the transition component
instance $id_t$.

\subsection{Simulation of the tl design}
\label{sec:ex-tl-sim}

Let us now present the rules pertaining to the simulation of the
\texttt{tl} design, that is, pertaining to the execution of the
\texttt{tl} design's behavior with respect to our formal simulation
algorithm.

\subsubsection{Initialization}
\label{sec:ex-init-tl}

The rule of Figure~\ref{fig:ex-init-tl} presents the initialization
phase in the proceeding of the simulation of the \texttt{tl}
design. The initialization phase builds the initial state of the
simulation. The first step of the initialization, formalized by the
$runinit$ relation, runs the processes and the internal behavior of
component instances exactly once (with the execution of the first part
of reset blocks). Then, a stabilization phase follows.

\begin{figure}[H]
  \centering
  \begin{prooftree}[template={\fontsize{12}{13}\selectfont\inserttext}]

    % Runinit
    \hypo{}
    \ellipsis{}{}
    \infer1[]{
      $\mathcal{D}_\mathcal{H},\Delta,\sigma_e\vdash$
      $cs_{tl}$
      $\xrightarrow{runinit}$
      $\sigma'$
    }
    
    % Stabilization
    \hypo{}
    \ellipsis{}{}
    \infer1[]{
      $\mathcal{D}_\mathcal{H},\Delta,\sigma_e\vdash$
      $cs_{tl}$
      $\xrightarrow{\rightsquigarrow}$
      $\sigma_0$
    }
    
    % Conclusion 
    \infer2[\fontsize{7}{10}\selectfont\textsc{Init}]{
      $\mathcal{D}_\mathcal{H},\Delta,\sigma_e\vdash$
      $cs_{tl}$
      $\xrightarrow{init}$
      $\sigma_0$
    }
    
  \end{prooftree}
  
  \caption{The initialization phase, first step of the simulation of
    the \texttt{tl} design.}
  \label{fig:ex-init-tl}
\end{figure}

The rule in Figure~\ref{fig:ex-runinit-tl} presents the execution of
the \texttt{tl} design's behavior during the $runinit$ phase. The
\texttt{tl} design's behavior is defined by the composition of
concurrent statements. Here, the \texttt{marked} process is at the
head of the behavior, whereas it is not the case in
Listing~\ref{lst:tl-design-ex}. We formally proved, with the \coq{}
proof assistant, that the $\mathtt{||}$ composition operator for
concurrent statements is commutative and associative with respect to
the $runinit$ relation. In Figure, the \texttt{marked} process is
executed and yields the state $\sigma'_e$. Then, the rest of the
\texttt{tl} design's behavior is executed and yields the state
$\sigma''_e$. Finally, the starting state $\sigma_e$ and the two
states $\sigma'_e$ and $\sigma''_e$ are merged into one by the
\texttt{merge} function.

\begin{figure}[H] \centering
  \begin{prooftree}[template={\fontsize{12}{13}\selectfont\inserttext}]
    
    % Runinit marked process
    \hypo{}
    \ellipsis{}{}
    \infer1[]{
      $\mathcal{D}_\mathcal{H},\Delta,\sigma_e\vdash$
      $\mathtt{process}(\mathtt{marked},\dots)$ $\xrightarrow{runinit}$
      $\sigma'_e$ }

    % Runinit tail
    \hypo{}
    \ellipsis{}{}
    \infer1[]{
      $\mathcal{D}_\mathcal{H},\Delta,\sigma_e\vdash$ $cs'_{tl}$
      $\xrightarrow{runinit}$ $\sigma''_e$ }

    % Conclusion
    \infer2[\fontsize{7}{10}\selectfont\textsc{CompRunInit}$^1$]{
      $\mathcal{D}_\mathcal{H},\Delta,\sigma_e\vdash$
      $\mathtt{process}(\mathtt{marked},\dots)~\mathtt{||}~cs'_{tl}$
      $\xrightarrow{runinit}$
      $\mathtt{merge}(\sigma_e,\sigma'_e,\sigma''_e)$ }

  \end{prooftree}

  \caption{The $runinit$ phase applied to the concurrent statements
    composing the behavior of the \texttt{tl} design.}
  \label{fig:ex-runinit-tl}
\end{figure}

\noindent{}where:
\begin{enumerate}
\item $\mathcal{E}'_e\cap\mathcal{E}''_e$
\end{enumerate}

In what follows, we detail the execution of a process statement and of
a component instantiation statement during the first part of the
initialization, i.e. the $runinit$ phase.

\paragraph{Execution of a process statement with the $runinit$ relation}

The rule in Figure shows the execution of the \texttt{marked} process
during the $runinit$ phase. The first part of the reset block defining
the statement body of the \texttt{marked} process is executed. This
first part assigns the expression $\mathtt{false}$ to signal
$id_{a0}$.

\begin{figure}[H] \centering
  \begin{prooftree}[template={\fontsize{12}{13}\selectfont\inserttext}]

    \infer0[\fontsize{7}{10}\selectfont\textsc{False}]{$\vdash\mathtt{false}\xrightarrow{e}\bot$}
    \infer0[\fontsize{7}{10}\selectfont\textsc{IsBool}]{$\bot\in_c{}bool$}
    
    % Execute fst part of rst block
    \infer2[\fontsize{7}{10}\selectfont\textsc{SigAssign}$^2$]{
      $\mathcal{D}_\mathcal{H},\Delta,\sigma_e,\sigma_e\vdash$
      $id_{a0}\Leftarrow\mathtt{false}$
      $\xrightarrow{ss_i}$
      $\sigma'_e,\emptyset$}

    % Execute rst block
    \infer1[\fontsize{7}{10}\selectfont\textsc{RstExec}]{
      $\mathcal{D}_\mathcal{H},\Delta,\sigma_e\vdash$
      $\mathtt{rst}(id_{a0}\Leftarrow\mathtt{false})(\dots)$
      $\xrightarrow{ss_i}$
      $\sigma'_e,\emptyset$ }

    % Conclusion
    \infer1[\fontsize{7}{10}\selectfont\textsc{PsRunInit}$^1$]{
      $\mathcal{D}_\mathcal{H},\Delta,\sigma_e\vdash$
      $\mathtt{process}(\mathtt{marked},\dots)$
      $\xrightarrow{runinit}$
      $\sigma'_e$ }
  \end{prooftree}

  \caption{The $runinit$ phase applied to the concurrent statements
    composing the behavior of the \texttt{tl} design.}
  \label{fig:ex-runinit-ps}
\end{figure}

\noindent{}where:

\begin{enumerate}
\item $\Delta(\mathtt{marked})=\emptyset$
\item
  \begin{tabular}{@{}l@{}}
    $\Delta(id_{a0})=bool$ \\
    $\sigma'_e={<}\mathcal{S}'_e,\mathcal{C}'_e,\mathcal{E}'_e{>}$ \\
    $\mathcal{S}'_e=\mathcal{S}_e(id_{a0})\leftarrow\bot$ \\
    $\mathcal{E}'_e=\mathcal{E}_e\cup(\mathcal{S}_e\dcap\mathcal{S}'_e)$ \\
  \end{tabular}
\end{enumerate}

In the side conditions of the \textsc{SigAssign} rule, an new event
set $\mathcal{E}'_e$ is computed based on the event set
$\mathcal{E}_e$ joined to the expression
$\mathcal{S}_e\dcap\mathcal{S}'_e$. This expression returns the set of
signals with a different value between signal store $\mathcal{S}_e$
and singal store $\mathcal{S}'_e$. The only signal that possibly has a
different value from $\mathcal{S}_e$ to $\mathcal{S}'_e$ is the
assigned signal $id_{a0}$. Thus, this expression is a shorthand to
test if the value of signal $id_{a0}$ has changed after the execution
of the signal assignment statement. If it is the case, then the event
set receives the signal identifier $id_{a0}$; $id_{a0}$ is then an
eventful signal. In the present case, the value of signal $id_{a0}$
was $\bot$ at state $\sigma_e$ and is still $\bot$ after the execution
of the signal assignment statement. Therefore, no event is registered
on signal $id_{a0}$. When states $\sigma_e$, $\sigma'_e$ and
$\sigma''_e$ will be merged (cf. Figure~\ref{fig:ex-runinit-tl}), if
$id_{a0}$ is part of the event set of state $\sigma''_e$, then, the
merged state will return the value associated to $id_{a0}$ in state
$\sigma''_e$. We would have
$\mathtt{merge}(\sigma_e,\sigma'_e,\sigma''_e)(id_{a0})=\sigma''_e(id_{a0})$.
However, signal $id_{a0}$ would be a potentially multiply-driven
signal because both the \texttt{marked} process and the concurrent
statement $cs'_{tl}$ (cf. Figure~\ref{fig:ex-runinit-tl}) assigns the
signal value.

\paragraph{Execution of a component instantiation statement with the $runinit$ relation}

The rule of Figure presents the execution of the \texttt{place}
component instance $id_p$ during the $runinit$ phase. The execution of
a component instantiation statement is pretty much the same in all the
phases of the simulation algorithm. The difference lies in the choice
of the relation used to execute of the internal behavior of the
component instance. During the $runinit$ phase, it is the $runinit$
relation that executes the internal behavior of component instances;
during the falling edge phase, it is the $\downarrow$ relation that
executes the internal behaviors, etc.

\begin{figure}[H] \centering
  \begin{prooftree}[template={\fontsize{11}{13}\selectfont\inserttext}]
    
    % Execute mapip
    \hypo{}
    \ellipsis{}{}
    \infer1{
      $\Delta,\Delta_p,\sigma_e,\sigma_p\vdash$
      $i_p$
      $\xrightarrow{mapip}$
      $\sigma'_p$}

    % Execute internal behavior
    \hypo{}
    \ellipsis{}{}
    \infer1{
      $\mathcal{D}_\mathcal{H},\Delta_p,\sigma'_p\vdash$
      $cs_p$
      $\xrightarrow{runinit}$
      $\sigma''_p$ }

    % Execute mapop
    \hypo{}
    \ellipsis{}{}
    \infer1{
      $\Delta,\Delta_p,\sigma_e,\sigma''_p\vdash$
      $o_p$
      $\xrightarrow{mapop}$
      $\sigma'_e$}

    % Conclusion
    \infer3[\fontsize{7}{10}\selectfont\textsc{CompRunInit}$^1$]{
      $\mathcal{D}_\mathcal{H},\Delta,\sigma_e\vdash$
      $\mathtt{comp}(id_p,\mathtt{place},g_p,i_p,o_p)$
      $\xrightarrow{runinit}$
      $\sigma''_e$ }
  \end{prooftree}

  \caption[The execution of the \texttt{place} component instance
    $id_p$ during the $runinit$ phase.]{The execution of the \texttt{place} component instance
    $id_p$ during the $runinit$ phase (first part of the
    initialization).}
  \label{fig:ex-runinit-pci-idp}
\end{figure}

\noindent{}where:

\begin{enumerate}
\item
  \begin{tabular}{@{}l@{}}
    $\sigma'_e={<}\mathcal{S}'_e,\mathcal{C}'_e,\mathcal{E}'_e{>}$ \\
    $\sigma''_e={<}\mathcal{S}'_e,\mathcal{C}''_e,\mathcal{E}'_e\cup(\mathcal{C}_e\dcap\mathcal{C}''_e){>}$ \\
    $\mathcal{C}''_e=\mathcal{C}'_e(id_p)\leftarrow{}\sigma''_p$ \\
  \end{tabular}
\end{enumerate}



The execution of a component instantiation statement is decomposed in
four parts. First, the input ports of the component instance receive
new values through the evaluation of the input port map. Second, the
internal behavior of the component instance is executed. Thirdly, the
evaluation of the output port map propagates the values coming from
the output interface to the component to the signals of the embedding
design. Finally, the component instance is assigned to its new
internal state in the component store of the embedding design; here,
$\sigma''_p$ is assigned to $id_p$ in component store
$\mathcal{C}''_e$. Moreover, if the new internal state of the
component instance is different from its older internal state, then
the component instance identifier is added to the event set of the
embedding design. Here, the expression
$\mathcal{C}_e\dcap\mathcal{C}''_e$ performs the state comparison; we
have:

{\raggedleft
  \begin{tabular}{ll}
    $\mathcal{C}_e\dcap\mathcal{C}''_e$ & $=\mathcal{C}_e\dcap(\mathcal{C}'_e\leftarrow\sigma''_p)$ \\
                                      & $=\mathcal{C}_e\dcap(\mathcal{C}_e\leftarrow\sigma''_p)$ \\
                                      &$=
                                        \begin{cases}
                                          \{id_p\}~\mathtt{if}~\sigma_p\neq\sigma''_p \\
                                          \emptyset~otherwise \\
                                        \end{cases}$
  \\
\end{tabular}
}

In the second line, we have $\mathcal{C}_e=\mathcal{C}'_e$ because the
evaluation of the output port map (performed by the $mapop$ relation)
does not change the component store.

The rule of Figure~\ref{fig:ex-eval-ipm} gives a part of the
evaluation of the input port map of $id_p$.

\begin{figure}[H]
  \centering
  \begin{prooftree}[template={\fontsize{10}{13}\selectfont\inserttext}]

    % MapipSimple
    \infer0[\fontsize{7}{10}\selectfont\textsc{Nat}]{$\Delta,\sigma_e\vdash{}1\xrightarrow{e}1$}
    \infer0[\fontsize{7}{10}\selectfont\textsc{IsCNat}]{$1\in_c{}nat(0,1)$}
    \infer2[\fontsize{7}{10}\selectfont\textsc{MapipSimple}$^1$]{
      $\Delta,\Delta_p,\sigma_e,\sigma_p\vdash$
      $(\mathtt{im}, 1)\xrightarrow{mapip}\sigma'_{p0}$
    }

    % MapipComp
    \hypo{}
    \ellipsis{}{}
    \infer1{
      $\Delta,\Delta_p,\sigma_e,\sigma'_{p0}\vdash$
      \begin{tabular}{@{}l@{}}
        $(\mathtt{iaw}(0), 1)$ \\
        $(\mathtt{oat}(0), 0),$ $(\mathtt{oaw}(0), 1),$ \\
        $(\mathtt{itf}(0), id_{ft}),$ $(\mathtt{otf}(0), id_{ft})$ \\
      \end{tabular}
      $\xrightarrow{mapip}$
      $\sigma'_p$
    }
    
    % Conclusion 
    \infer2[\fontsize{7}{10}\selectfont\textsc{MapipComp}]{
      $\Delta,\Delta_p,\sigma_e,\sigma_p\vdash$
      \begin{tabular}{@{}l@{}}
        $(\mathtt{im}, 1),$ $(\mathtt{iaw}(0), 1)$ \\
        $(\mathtt{oat}(0), 0),$ $(\mathtt{oaw}(0), 1),$ \\
        $(\mathtt{itf}(0), id_{ft}),$ $(\mathtt{otf}(0), id_{ft})$ \\
      \end{tabular}
      $\xrightarrow{mapip}$
      $\sigma'_p$
    }
    
  \end{prooftree}
  
  \caption{The evaluation of the input port map of the \texttt{place}
    component instance $id_p$.}
  \label{fig:ex-eval-ipm}
\end{figure}

\noindent{}where:
\begin{enumerate}
\item
  \begin{tabular}{@{}l@{}}
    $\Delta_p(\mathtt{im})=nat(0,1)$ \\
    $\sigma_p={<}\mathcal{S},\mathcal{C},\mathcal{E}{>}$ \\
    $\mathcal{S}'=\mathcal{S}(\mathtt{im})\leftarrow{}1$ \\
    $\sigma'_{p0}={<}\mathcal{S}',\mathcal{C},\mathcal{E}{>}$ \\
  \end{tabular}
\end{enumerate}

The evaluation of the input port map of $id_p$ changes the value of
the \texttt{initial\_marking} input port (i.e. \texttt{im}). We have
$\sigma_p(\mathtt{im})=0$ and $\sigma'_p(\mathtt{im})=1$. As the value
of one of its input port has changed, the \texttt{place} component
instance $id_p$ will be registered as an eventful component instance.

The rule of Figure~\ref{fig:ex-eval-opm} gives a part of the
evaluation of the output port map of $id_p$.

\begin{figure}[H]
  \centering
  \begin{prooftree}[template={\fontsize{10}{13}\selectfont\inserttext}]

    % MapipSimple
    \infer0[]{$\vdash{}0\xrightarrow{e}0$}
    \infer0{$0\in_c{}nat(0,0)$}
    \infer2[\fontsize{7}{10}\selectfont\textsc{IdxSig}$^2$]{$\Delta_p,\sigma''_p\vdash\mathtt{oav}(0)\xrightarrow{e_o}\top$}
    \infer0[\fontsize{7}{10}\selectfont\textsc{IsBool}]{$\top\in_c{}bool$}
    \infer2[$^1$]{
      $\Delta,\Delta_p,\sigma_e,\sigma''_p\vdash$
      $(\mathtt{oav}(0), id_{av})$
      $\xrightarrow{mapop}\sigma'_{e0}$
    }

    % MapipComp
    \hypo{}
    \ellipsis{}{}
    \infer1{
      $\Delta,\Delta_p,\sigma'_{e0},\sigma''_p\vdash$
      \begin{tabular}{@{}l@{}}
        $(\mathtt{pauths}, \mathtt{open})$ \\
        $(\mathtt{rtt}(0), id_{rt}),$ $(\mathtt{marked}, id_m)$ \\
      \end{tabular}
      $\xrightarrow{mapop}$
      $\sigma'_e$
    }
    
    % Conclusion 
    \infer2[\fontsize{7}{10}\selectfont\textsc{MapopComp}]{
      $\Delta,\Delta_p,\sigma_e,\sigma''_p\vdash$
      \begin{tabular}{@{}l@{}}
        $(\mathtt{oav}(0), id_{av}),$ $(\mathtt{pauths}, \mathtt{open})$ \\
        $(\mathtt{rtt}(0), id_{rt}),$ $(\mathtt{marked}, id_m)$ \\
      \end{tabular}
      $\xrightarrow{mapop}$
      $\sigma'_e$
    }
    
  \end{prooftree}
  
  \caption{The evaluation of the output port map of the \texttt{place}
    component instance $id_p$.}
  \label{fig:ex-eval-opm}
\end{figure}

\noindent{}where:
\begin{enumerate}
\item
  \begin{tabular}{@{}l@{}}
    $\Delta(id_{av})=bool$ \\
    $\sigma_e={<}\mathcal{S},\mathcal{C},\mathcal{E}{>}$ \\
    $\mathcal{S}'=\mathcal{S}(id_{av})\leftarrow{}\top$ \\
    $\mathcal{E}'=\mathcal{E}\cup(\mathcal{S}\dcap\mathcal{S}')$ \\
    $\sigma'_{e0}={<}\mathcal{S}',\mathcal{C},\mathcal{E}'{>}$ \\
  \end{tabular} (Rule~\textsc{MapopPartialToSimple}).
\item
  \begin{tabular}{@{}l@{}}
    $\Delta_p(\mathtt{oav})=array(bool,0,0)$ \\
    $\sigma''_p(\mathtt{oav})=(\top)$ \\
    $\mathtt{get\_at}(0,(\top))=\top$ \\
  \end{tabular}
\end{enumerate}

\subsubsection{Stabilization}
\label{sec:ex-stabilize-tl}

A stabilization phase happens after the $runinit$ during the
initialization phase, but also after the rising edge phase and the
falling edge phase in the course of a simulation cycle. The
stabilization phase executes the combinational parts of the design's
behavior. The \texttt{tl} design holds no combinational processes in
its behavior. The \texttt{marked} and \texttt{fired} processes are
both synchronous. To illustrate the execution of a combinational
process during a stabilization phase, let us consider the
\texttt{fired_evaluation} process defined in the behavior of
\texttt{transition} design. The \texttt{fired_evaluation} process will
be executed with the internal behavior of the \texttt{transition}
component instance $id_t$ during the stabilization phase.  The rule of
Figure presents the execution of the internal behavior of the
\texttt{transition} component instance $id_t$. As shown, the internal
behavior $cs_t$ is executed three times before reaching a stable
state. Here, the number of execution before stabilization is
arbitrary. In Figure, $\sigma_{t0}$ corresponds to the state of $id_t$
after the $runinit$ phase and after the evaluation of its input port
map. Remember that the evaluation of the input port map of a component
instance always precedes the execution of the internal behavior of the
same component. Since $\sigma_{t0}$ and $\sigma_{t1}$ are not stable
states, it means that their event set is not empty. Thus, we have
$\mathcal{E}(\sigma_{t0})\neq\emptyset$ and
$\mathcal{E}(\sigma_{t1})\neq\emptyset$. On the contrary,
$\sigma_{t2}$ is a stable state, and thus,
$\mathcal{E}(\sigma_{t2})=\emptyset$.



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../main"
%%% End:
