This section presents the implementation of the \hvhdl{} abstract
syntax, and also of the elaboration and the simulation semantics of
\hvhdl{} designs with the \coq{} proof assistant. The full code is
available under the \texttt{hvhdl} folder of the following repository:
\url{https://github.com/viampietro/ver-hilecop}.

\subsection{Implementation of the \texorpdfstring{\hvhdl{}}{H-VHDL}
  abstract syntax, elaborated design and design state}
\label{sec:impl-abss-and-env}

\paragraph{\hvhdl{} abstract syntax}

The implementation of the \hvhdl{} abstract syntax is naturally done
leveraging the \texttt{Inductive} construct of the \coq{} proof
assistant. The result is strictly similar to the formal definition of
the abstract syntax given in Section~\ref{sec:abstractSyntax}. The
reader can refer to the \texttt{AbstractSyntax.v} under the
\texttt{hvhdl} folder for the details of the implementation.

\paragraph{Elaborated design}

Listing~\ref{lst:elab-design-struct} presents the implementation of
the elaborated design structure
(cf. Definition~\ref{def:elab-design}). Two definitions are involved
in the implementation of the elaborated design structure.  The first
one defines the \texttt{SemanticObject} inductive type. Each
constructor of this type corresponds to a sub-environment of the
elaborated design. For instance, the \texttt{Generic} constructor
corresponds to the couple $(type\times{}value)$ associated with a
generic constant identifier in the $Gens$ sub-environment of
Definition~\ref{def:elab-design}. The \texttt{Process} constructor
corresponds to the local variable environment associated with the
process identifiers in the $Ps$ sub-environment. A local variable
environment is implemented by the \texttt{LEnv} type. The
\texttt{LEnv} type is a map between identifiers and couples
$(type\times{}value)$. Identifiers are implemented by the
\texttt{ident} type, an alias of the \texttt{nat} type. The
\texttt{type} and \texttt{value} types are the implementation of the
semantic $type$ and $value$ presented in
Table~\ref{tab:type-value}. The \texttt{ElDesign} type implements the
elaborated design structure. It is an alias to the \texttt{IdMap
  SemanticObject} type. The \texttt{IdMap} is the type of maps from
identifiers (i.e. belonging to the \texttt{ident} type) to instances
of the type passed as an input. Here, the input is the
\texttt{SemanticObject} type. Thus, an elaborated design is
implemented as a map between identifiers and terms of the
\texttt{SemanticObject} type. We leverage the \texttt{FMaps} module
defined in the \coq{} standard library to implement the \texttt{IdMap}
type. The \texttt{IdMap} type ensures that an identifier is only
mapped once. Thus, the implementation of the elaborated design
structure verifies that there are no intersection between the domains
of sub-environments. For instance, a generic constant identifier can
not be an input port identifier, and, as it is implemented, an
identifier \texttt{id} can not be mapped to a \texttt{Generic} object
and to an \texttt{Input} object in the same instance of
\texttt{ElDesign}.
 
\begin{lstlisting}[language=coq,label={lst:elab-design-struct},
caption={[\coq{} implementation of the elaborated design structure.]The implementation of the elaborated design structure with the \coq{} proof assistant.},framexleftmargin=1.5em,xleftmargin=2em,numbers=left,
numberstyle=\tiny\ttfamily]
Inductive SemanticObject : Type :=
| Generic (t : type) (v : value)
| Input (t : type)
| Output (t : type)
| Declared (t : type)
| Process (lenv : LEnv)
| Component ($\Delta_c$ : IdMap SemanticObject).

Definition ElDesign := IdMap SemanticObject.
\end{lstlisting}

\paragraph{Design state}

Listing~\ref{lst:design-state-impl} gives the implementation of the
design state structure through the definition of the \texttt{DState}
inductive type. The constructor of the \texttt{DState} type defines
three fields: \texttt{sigstore}, implementing the signal store
$\mathcal{S}$ of the design state, \texttt{compstore}, implementing
the component store $C$, and \texttt{events}, implementing the set of
events $\mathcal{E}$ of the design state. The \texttt{sigstore} field
is a map from identifiers to values. The \texttt{compstore} field is a
map from identifiers to design states, justifying the inductive
definition of the \texttt{DState} type. The \texttt{events} field is
an instance of the \texttt{IdSet} type. The \texttt{IdSet} is the type
of sets of identifiers (i.e. sets of natural numbers). The
\texttt{IdSet} type is defined leveraging the \texttt{MSets} module of
the \coq{} standard library.

\begin{lstlisting}[language=coq,label={lst:design-state-impl},
  caption={[\coq{} implementation of the design state structure.]The implementation of the design state structure with the \coq{} proof assistant.},framexleftmargin=1.5em,xleftmargin=2em,numbers=left,
  numberstyle=\tiny\ttfamily]
Inductive DState : Type := MkDState {
  sigstore  : IdMap value;
  compstore : IdMap DState;
  events    : IdSet;
}.
\end{lstlisting}

\subsection{Implementation of the elaboration phase}
\label{sec:impl-elaboration}

The design elaboration relation, as presented in
Section~\ref{subsubsec:design-elab}, is implemented in \coq{} by the
\texttt{edesign} relation. Listing~\ref{lst:design-elab-rel-impl}
presents the definition of the \texttt{edesign} relation as an
inductive type. As usual, a n-ary relation is implemented in \coq{} by
a type defined with $n$ parameters and projecting to the \texttt{Prop}
type. The \texttt{edesign} relation as five parameters. The first
parameter is the design store $\mathcal{D}$ of type \texttt{IdMap
  design}, i.e. a map from identifiers to \hvhdl{} designs as defined
by the abstract syntax. The second parameter is the dimensioning
function $\mathcal{M}$ of type \texttt{IdMap value}, i.e. a map from
identifiers to values. The third parameter is the design being
elaborated, of type \texttt{design}. The fifth and sixth parameters
are the elaborated design (of type \texttt{ElDesign} and the default
design state (of type \texttt{DState}) resulting from the elaboration.
In Listing~\ref{lst:design-elab-rel-impl}, the \texttt{EDesign}
constructor implements the \textsc{DesignElab} rule presented in
Section~\ref{subsubsec:design-elab}. From Line~7 to Line~10, the
constructor defines the premises of Rule~\textsc{DesignElab}.  The
empty elaborated design structure, denoted $\Delta_\emptyset$, is
implemented by the \texttt{EmptyElDesign} definition, and the empty
design state structure, denoted by $\sigma_\emptyset$, is implemented
by the \texttt{EmptyDState} definition. Line~13 implements the
conclusion of Rule~\textsc{DesignElab}.

\begin{lstlisting}[language=coq,label={lst:design-elab-rel-impl},
  caption={[\coq{} implementation of the design elaboration relation.]The implementation of the design elaboration relation with the \coq{} proof assistant.},framexleftmargin=1.5em,xleftmargin=2em,numbers=left,
  numberstyle=\tiny\ttfamily]
Inductive edesign ($\mathcal{D}$ : IdMap design) : IdMap value -> design -> ElDesign -> DState -> Prop :=
| EDesign :
    forall $\mathcal{M}$ $id_e$ $id_a$ gens ports sigs behavior
           $\Delta$ $\Delta'$ $\Delta''$ $\Delta'''$ $\sigma$ $\sigma'$ $\sigma''$,

      (* Premises *)
      egens EmptyElDesign $\mathcal{M}$ gens $\Delta$ ->
      eports $\Delta$ EmptyDState ports $\Delta'$ $\sigma$ ->
      edecls $\Delta'$ $\sigma$ sigs $\Delta''$ $\sigma'$ ->
      ebeh $\mathcal{D}$ $\Delta''$ $\sigma'$ behavior $\Delta'''$ $\sigma''$ ->
      
      (* Conclusion *)
      edesign $\mathcal{D}$ $\mathcal{M}$ (design_ $id_e$ $id_a$ gens ports sigs behavior) $\Delta'''$ $\sigma''$

with ebeh ($\mathcal{D}$ : IdMap design) : ElDesign -> DState -> cs -> ElDesign -> DState -> Prop :=
$\dots$
\end{lstlisting}

The \texttt{edesign} relation requires a mutually recursive definition
with the \texttt{ebeh} relation. The mutually recursive definition is
performed leveraging the \texttt{with} clause at the end of
Listing~\ref{lst:design-elab-rel-impl}. The \texttt{ebeh} relation
needs the \texttt{edesign} relation to elaborate the component
instances found in the behavior of a
design. Listing~\ref{lst:ebeh-rel-impl} gives the details of the
\texttt{with} clause defining the \texttt{ebeh} relation.

At Line~2, the \texttt{EBehPs} constructor implements the
Rule~\textsc{PsElab} defining the elaboration of a process statement
(cf. Section~\ref{subsubsec:ps-elab}). Lines~6 and 7 implement the
premises of the rule; the \texttt{evars} relation implements the
elaboration of the local variable declaration list of the process; the
\texttt{validss} relation implements the relation that type-checks the
statement body of the process. Lines~10 to 14 implement the side
conditions of the rule. The term \coqe|~NatMap.In| $id_p$ $\Delta$
implements the side condition $id_p\notin{}\Delta$. The
\coqe|NatMap.In id m| relation states that a given identifier
\texttt{id} is a key of the \texttt{m} map. At Line~13, the
\coqe|NatSet.In $id_s$ sl| term states that $id_s$ belongs to the
identifier set \texttt{sl}. At Line~14, the term \texttt{MapsTo $id_s$
  (Input t) $\Delta$} states that the identifier $id_s$ is mapped to
\texttt{Input t} in the elaborated design $\Delta$,
i.e. $Ins(\Delta)(id_s)=\mathtt{t}$. More generally, \texttt{MapsTo}
is a ternary relation stating that a given key \texttt{k} of type
\texttt{nat}, is mapped to a value \texttt{v} of a type \texttt{A}, in
a given map \texttt{m}, i.e. \coqe|Mapsto k v m|.  Line~17 implements
the conclusion of Rule~\textsc{PsElab}. The \texttt{NatMap.add}
function binds the process identifier $id_p$ to the term
\texttt{Process $\Lambda$} in the elaborated design $\Delta$,
i.e. $\Delta\cup(id_p,\Lambda)$.

At Line~19, the \texttt{EBehComp} constructor implements the
Rule~\textsc{CompElab}
(cf. Section~\ref{subsubsec:comp-inst-elab}). This rule describes the
elaboration of a component instantiation statement. Lines~24 to 27
implement the premises of the rule. Line~25 appeals to the
\texttt{edesign} relation to elaborate the \texttt{cdesign} design
associated with the component instance $id_c$; thence, the mutually
recursive definition with the \texttt{ebeh} relation. As it is stated
at Line~32, the \texttt{cdesign} design is associated to identifier
$id_e$, i.e. the entity identifier of component instance $id_c$, in
the design store $\mathcal{D}$. Lines~30 to 33 implement the side
conditions of the rule. Line~30 checks that the identifier $id_c$ is
not already bound to a semantic object in the elaborated design
$\Delta$. Line~31 checks that the identifier $id_c$ is not already
bound in the component store of $\sigma$. Line~33 checks that all
identifiers defined in the domain of map $\mathcal{M}$, i.e. the
dimensioning function, are bound to generic constants in the
elaborated design $\Delta_c$
(i.e. $\mathcal{M}\subseteq{}Gens(\Delta_c)$). Lines~36 to 38
implement the conclusion of Rule~\textsc{CompElab}. At Line~39, the
\texttt{cstore_add} function binds $id_c$ to design state $\sigma_c$
in the component store of state $\sigma$ and returns the resulting
state.

At Line~41, the \texttt{EBehNull} constructor implements
Rule~\textsc{CsNullElab}. At Line~43, the \texttt{EBehPar} constructor
implements Rule~\textsc{CsParElab}.

\begin{lstlisting}[language=coq,label={lst:ebeh-rel-impl},
  caption={[\coq{} implementation of the behavior elaboration relation.]The implementation of the \texttt{ebeh} behavior elaboration relation with the \coq{} proof assistant.},framexleftmargin=1.5em,xleftmargin=2em,numbers=left,
  numberstyle=\tiny\ttfamily]
with ebeh ($\mathcal{D}$ : IdMap design) : ElDesign -> DState -> cs -> ElDesign -> DState -> Prop :=
| EBehPs :
    forall $id_p$ sl vars stmt $\Lambda$ $\Delta$ $\sigma$,

      (* Premises *)
      evars $\Delta$ EmptyLEnv vars $\Lambda$ ->
      validss $\Delta$ $\sigma$ $\Lambda$ stmt ->

      (* Side conditions *)
      ~NatMap.In $id_p$ $\Delta$ ->

      (forall $id_s$,
          NatSet.In $id_s$ sl ->
          exists t, MapsTo $id_s$ (Declared t) $\Delta$ \/ MapsTo $id_s$ (Input t) $\Delta$) ->

      (* Conclusion *)
      ebeh $\mathcal{D}$ $\Delta$ $\sigma$ (cs_ps $id_p$ sl vars stmt) (NatMap.add $id_p$ (Process $\Lambda$) $\Delta$) $\sigma$

| EBehComp :
    forall $\Delta$ $\sigma$ $id_c$ $id_e$ gmap ipmap opmap
           $\mathcal{M}$ $\Delta_c$ $\sigma_c$ formals actuals cdesign,

      (* Premises *)
      emapg (NatMap.empty value) gmap $\mathcal{M}$ ->
      edesign $\mathcal{D}$ $\mathcal{M}$ cdesign $\Delta_c$ $\sigma_c$ ->
      validipm $\Delta$ $\Delta_c$ $\sigma$ ipmap formals ->
      validopm $\Delta$ $\Delta_c$ opmap formals actuals ->
      
      (* Side conditions *)
      ~NatMap.In $id_c$ $\Delta$ ->
      ~NatMap.In $id_c$ (compstore $\sigma$) ->
      MapsTo $id_e$ cdesign $\mathcal{D}$ ->
      (forall g, NatMap.In g $\mathcal{M}$ -> exists t v, MapsTo g (Generic t v) $\Delta_c$) ->
      
      (* Conclusion *)
      ebeh $\mathcal{D}$ $\Delta$ $\sigma$ (cs_comp $id_c$ $id_e$ gmap ipmap opmap)
                  (NatMap.add $id_c$ (Component $\Delta_c$) $\Delta$)
                  (cstore_add $id_c$ $\sigma_c$ $\sigma$)
           
| EBehNull: forall $\Delta$ $\sigma$, ebeh $\mathcal{D}$ $\Delta$ $\sigma$ cs_null $\Delta$ $\sigma$

| EBehPar:
    forall $\Delta$ $\Delta'$ $\Delta''$ $\sigma$ $\sigma'$ $\sigma''$ cstmt cstmt',
      ebeh $\mathcal{D}$ $\Delta$ $\sigma$ cstmt $\Delta'$ $\sigma'$ ->
      ebeh $\mathcal{D}$ $\Delta'$ $\sigma'$ cstmt' $\Delta''$ $\sigma''$ ->
      ebeh $\mathcal{D}$ $\Delta$ $\sigma$ (cs_par cstmt cstmt') $\Delta''$ $\sigma''$.

\end{lstlisting}

\subsection{Implementation of the simulation algorithm}
\label{sec:impl-simulation}

The full simulation relation (cf. Section~\ref{sec:full-sim})
formalizes the \hvhdl{} simulation algorithm. The \coq{}
implementation of the full simulation relation, presented in
Listing~\ref{lst:full-sim-impl}, is a strict translation of
Rule~\textsc{FullSim}. At Lines~14 and 15, the term \texttt{(behavior
  d)} represents the concurrent statements defining the behavior of
the \hvhdl{} design \texttt{d} (i.e. d.cs in the formal rule). Line~13
corresponds to the elaboration phase, Line~14 to the initialization
phase, and Line~15 to the main simulation loop.

\begin{lstlisting}[language=coq,label={lst:full-sim-impl},
  caption={[\coq{} implementation of the full simulation relation.]The implementation of the full simulation relation with the \coq{} proof assistant.},framexleftmargin=1.5em,xleftmargin=2em,numbers=left,
  numberstyle=\tiny\ttfamily]
Inductive fullsim
          ($\mathcal{D}$ : IdMap design)
          ($\mathcal{M}$ : IdMap value)
          ($E_p$ : nat -> Clk -> IdMap value)
          ($\tau$ : nat)
          ($\Delta$ : ElDesign) 
          (d : design) : list DState -> Prop :=
  
| FullSim :
    forall $\sigma_e$ $\sigma_0$ $\theta$,
      
      (* * Premises * *)
      edesign $\mathcal{D}$ $\mathcal{M}$ d $\Delta$ $\sigma_e$ ->
      init $\mathcal{D}$ $\Delta$ $\sigma_e$ (behavior d) $\sigma_0$ ->
      simloop $\mathcal{D}$ $E_p$ $\Delta$ $\sigma_0$ (behavior d) $\tau$ $\theta$ ->
                    
      (* * Conclusion * *)
      fullsim $\mathcal{D}$ $\mathcal{M}$ $E_p$ $\tau$ $\Delta$ d ($\sigma_0$ :: $\theta$).
\end{lstlisting}

The \texttt{simloop} relation appeals to the \texttt{simcycle} that
implements the simulation cycle relation defined in
Section~\ref{sec:sim-cycle}. Listing~\ref{lst:sim-cycle-impl} presents
the implementation of the \texttt{simcycle} relation. The
\texttt{simcycle} relation is a strict transcription of the
\textsc{SimCyc} rule. At Line~13, the \texttt{vrising} relation
implements the $\uparrow$ relation, i.e. the rising edge phase of the
cycle. At Line 15, the \texttt{vfalling} relation implements the
$\downarrow$ relation, i.e. the falling edge phase of the cycle. At
Lines~14 and 16, the \texttt{stabilize} relation implements the
$\rightsquigarrow$ relation, i.e. the stabilization phases of the
simulation cycle. At Lines~18 and 19, the \texttt{IsInjectedDState}
relation implements the \texttt{Inject} relation. Line~18 states that
the $\sigma_i$ state is the result of the injection of the map
\coqe|($E_p$ $\tau$)| in the signal store of state $\sigma$.

\begin{lstlisting}[language=coq,label={lst:sim-cycle-impl},
caption={[\coq{} implementation of the simulation cycle relation.]The
  implementation of the simulation cycle relation with the \coq{}
  proof
  assistant.},framexleftmargin=1.5em,xleftmargin=2em,numbers=left,
numberstyle=\tiny\ttfamily]
Inductive simcycle ($\mathcal{D}$ : IdMap design) ($E_p$ : nat -> IdMap value) 
    ($\Delta$ : ElDesign) ($\tau$ : nat) ($\sigma$ : DState) (behavior : cs) 
    ($\sigma'$ $\sigma''$ : DState) : Prop := 
| SimCycle : forall $\sigma_i$ $\sigma_\uparrow$ $\sigma_\downarrow$,
      
      (* * Premises * *)      
      vrising $\mathcal{D}$ $\Delta$ $\sigma_i$ behavior $\sigma_\uparrow$ ->
      stabilize $\mathcal{D}$ $\Delta$ $\sigma_\uparrow$ behavior $\sigma'$ ->
      vfalling $\mathcal{D}$ $\Delta$ $\sigma'$ behavior $\sigma_\downarrow$ ->
      stabilize $\mathcal{D}$ $\Delta$ $\sigma_\downarrow$ behavior $\sigma$'' ->

      (* * Side conditions * *)
      IsInjectedDState $\sigma$ ($E_p$ $\tau$) $\sigma_i$ ->
      
      (* * Conclusion * *)
      simcycle $\mathcal{D}$ $E_p$ $\Delta$ $\tau$ $\sigma$ behavior $\sigma'$ $\sigma''$.
\end{lstlisting}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../main"
%%% End:
