When considering the choice of a formal semantics for the language
VHDL, it is important to remember the first aim of our work. We want
to prove that the \hilecop{} transformation that generates VHDL code
from SITPNs preserves the behavior of the initial model (i.e, the
SITPN model) into the generated VHDL program.  A formal semantics for
the VHDL language is therefore a necessary element to be able to
reason about the generated VHDL programs, and moreover to be able to
compared their behaviors with the behaviors of the source SITPN
models. Keeping that in mind, which formal semantics should we
consider for VHDL?

The same holds for any research task: there is a tradeoff between
finding a tool designed by others that will fit our needs, and
creating our own tool that will mitigate the gaps between our needs
and what is available in the literature. In the present case, the tool
is a formal semantics for VHDL. Adopting a fully-set semantics found
in the literature as a baseground for the implementation of a formal
semantics for VHDL has multiple perks. First, it reduces the
formalization effort, which is not a lesser point considering that the
proof ahead might be long and must still be completed within the time
span of the thesis. Still, the semantics would need to be implemented
in \coq{}, if no implementation exists (or not written in
\coq{}). Second, the formal semantics of programming languages found
in the literature are often general in their approach, this to provide
a generic framework to reason about programs. However, we must not
loose sight of our goal which is to prove behavior preservation; a
generic formal semantics could turn out to be too complex, or
necesitate too much tweaking and thus hinder the fullfillment of our
task. On the other side, creating our own formal semantics for VHDL,
based on the work of others, is the best way to fit our needs in
compliance with our final aim. However, the pitfalls are that the
resulting semantics might prove to be very specific, therefore
preventing others from using it. Also, a work of formalization would
be necessary which, as we already stated, would be time consuming. In
order to determine whether we ought to use an existing semantics or
design a new one, we must first clearly specify our needs pertaining
to the VHDL language.

\subsection{Specifying our needs: \hilecop{} and VHDL}
\label{subsec:specifying-needs}

Two elements are of major influence to the specification of our needs
for a formal semantics: first, the context of \hilecop{} and the
specificities of the VHDL programs that are generated; second, the
context of theorem proving. These two aspects entail the following
considerations.

\paragraph{The need for coverage} The \hilecop{} methodology generates
particular VHDL programs.  Even if some transformations can be
operated on the generated programs to simplify them, the looked-for
formal semantics must be able to deal with a certain subset of the
VHDL language. Especially, this subset must include:

\begin{itemize}
\item 0-delay (or $\delta$-delay) signal assignments (equivalent to
  transport-delay signal assignment with a ``0 ns'' after clause).
\item component instantiation statements with generic constant and port
  mapping.
\item entity's generic constant clauses (declaration of generic
  constants in a design entity).
\end{itemize}

\hilecop{}'s VHDL programs only deal with 0-delay signal assignments
because they are the only kind of signal assignments that can be
synthesized. As a matter of fact, the industrial compiler/synthetizer
used in the \hilecop{} methodology only accepts VHDL programs with no
timing constructs (i.e, no wait statements or delayed signal
assignments) as input. % However, 0-delay signal assignments do not
% specify a delay after which the assignment of a value to a signal must
% be performed. The time taken by a signal assignment to be performed
% (the time of propagation) is only relevant in relation to the clock
% period that regulates the modeled circuit. It is sufficient if the
% semantics handles only this dimension of time, even if the VHDL
% language gathers both the ``dimension of delta time and the dimension
% of real time'' \cite{Reetz95}.

Concerning component instantiation statement, the VHDL LRM describes a
way to transform these statements into equivalent process statements
and block constructs \cite[p.~141]{VHDL2000} which are a part of the
elaboration of the design. However, we want to preserve the
hierarchical structure provided by the component instance statements
arguing that it will be easier to compare the state of a given SITPN
model with a VHDL design state with an explicit hierarchical
structure. Indeed, there exists a mapping between places and
transitions of an SITPN and their mirror (generated by the
transformation) place and transition component instances. This
one-to-one correspondence might turn out to be handy to perform the
proof of behavior preservation. Obviously, the semantics must cover
the evaluation of process statements which are the core concurrent
statements of VHDL programs.

The types of signals and variables used in \hilecop{} VHDL designs
must have finite ranges of values. For instance, a VHDL signal that
ranges over $\mathbb{N}$ cannot be synthetized on a physical circuit.
Indeed, $\mathbb{N}$ has an infinite number of values, and would
therefore require an infinite number of latches to be physically
implemented. Moreover, as the number of latches used to implement a
digital circuit greatly impacts the power consumption of the circuit,
the types of signals and variables must be as constrained as possible
to optimize the dimensioning of the circuit. The generic constant
clauses of the \hilecop{} place and transition designs (see Section
Presentation of the VHDL language) help limiting the type ranges. The
generic constants define the bound of the array and natural range
types for the different signals and variables declared in the place
and transition designs' architecture. When a place or a transition
component is instantiated, that is during the transformation of the
SITPN model into VHDL code, its generic constants receive values via a
generic map; we call it the dimensioning of the component
instance. Therefore, generic constant clauses must belong to the
subset of the VHDL language covered by the semantics (even though it
seems a trivial formalization task compared to the core of the VHDL
semantics).

\paragraph{The need for synchronous execution} The second property of
\hilecop{}'s generated VHDL programs is their synchronous
execution. Indeed, the digital circuits designed with the \hilecop{}
methodology are all synchronously executed on physical target. The
generated VHDL designs declare a clock signal as an input port of
their entity port interface. Thus, the behavioral part of the designs
contains two kinds of processes: \emph{synchronous} processes, i.e
processes that are sensitive to the clock signal, and
\emph{combinational} processes, i.e processes that are not sensitive
to the clock signal, and that are permanently running until the
stabilization of the signal values. Synchronous processes react to the
events of the clock signal, i.e the rising and the falling edge, and
possess blocks of sequential statements that are only executed at the
precise moment of the clock event\footnote{These blocks are guarded by
  the expressions \texttt{rising\_edge(clk)} and
  \texttt{falling\_edge(clk)}.}. Therefore, we are in a strong need of
a semantics that deal with synchronism, and that explicitly integrates
the synchronization with a clock signal into the expression of the
simulation cycle. Thus, the two dimensions of time, respectively delta
time and ``real'' time \cite{Reetz1995}, that are part of the VHDL
language, must be handled by our semantics. Delta time pertains to
delta-cycles, which are triggered by the execution of delta-delay
signal assignments, that is, the only kind of signal assignments found
in \hilecop{} VHDL programs. Real time pertains to time-steps. When
all signal values are stable (when there are no more delta-cycles),
the simulation advances the current time value to the next time point
where a relevant event happens. A relevant event could be the
execution of the next pending signal assignment that was associated
with a delay, or the end of a \texttt{wait for x} statement (where
\texttt{x} specifies a time delay). In our case, neither delayed
signal assignments nor wait statements are part the covered VHDL
language subset. The only two relevant events to which the simulation
advances during a time-step are the rising edge and the falling edge
of the clock signal.

\paragraph{Other considerations} Considering the kind of proof that
needs to be established, we would rather consider an operational
semantics for VHDL than a denotational one. The reason is that, in the
\ccert{} project \cite{Leroy2009}, which is one of our major
inpsiration source, the whole C compiler toolchain is verified by
reasoning over the operational semantics of the source and target
languages. A last consideration pertains to whether or not the VHDL
semantics must explicitly handle errors. As the SITPN semantics does
not include the production of error values, the handling of errors by
the VHDL semantics is not a mandatory aspect.

\paragraph{Qualifying criterions}
\label{sec:qualifying-criterions}

We here give the list of the qualifying criterions that will help to
analyze the different VHDL semantics encountered in the literature and
presented in the next section. The three most relevant criterions are:

\begin{itemize}
\item \emph{Synchronism}. We distinguish three levels for this
  criterion:
  \begin{itemize}
  \item Synchronism is not expressible in the considered VHDL semantics.
  \item Synchronism is expressible in the considered VHDL
    semantics. Synchronism is expressible if time-steps are handle in
    the semantics, at least to be able to represent clock events.
  \item Synchronism is explicit, i.e. the simulation loop is built
    around the occurrences of clock events.
  \end{itemize}
  We will promote the semantics that explicitly formalize a
  synchronized execution of a VHDL design.
\item \emph{Component instantiation}. Either the semantics handle the
  component instantiation statement in its simulation rules, or
  component instantiation statements must be transformed in order to
  be executed. We will promote the semantics that handle component
  instantiation statements without transformation.
\item \emph{Elaboration}. This criterion expresses the ability of the
  semantics to handle constrained types, i.e. arrays and natural
  ranges, and generic constant clauses that are both dealt with during
  \emph{elaboration} phase. Either the semantics handle these
  constructs or it does not. Of course, we will promote the first kind
  of semantics.
\end{itemize}

\subsection{Looking for an existing formal semantics}
\label{subsec:looking-for-sem}

Here, we give a summary of the work found in the literature pertaining
to the formalization of the VHDL language semantics. Articles are
gathered and presented depending on the type of semantics that is used
in the formalization (operational, denotational, axiomatic\dots). Each
semantics is analyzed regarding the needs that were previously
expressed.

\paragraph{Denotational semantics}
Some authors have been interested in giving a formal denotational
semantics to VHDL. In a general manner, these authors want to reason
about VHDL programs: prove properties over a VHDL program, prove that
two programs are equivalent\dots Such tasks that are more fit for a
denotational semantics.

In \cite{Fuchs1995}, the authors give a denotational semantics to the
VHDL language, this leveraging the \textsf{Focus} \cite{Dederichs1993}
method for the development of distributed systems. Signal values and
their evolution through time are represented as streams of
values. Statements are denoted as stream-processing
functions. Processes are stream-processing functions that takes input
signal streams (signals of the sensitivity list) and yields
transaction traces (i.e, waveforms) over output signals (i.e, signal
that are written by the process). Transaction traces are merged
together as the result of the concurrent execution of
processes. Resolution functions are used in case of multiply-driven
signals (i.e, signals that receive a value from multiple processes).
The authors only consider 0-delay signal assignment in their
semantics, stating that it is sufficient to ``consider time at a
logical level to model both synchronous and asynchronous designs''.
However, it necesitates some transformations on a design that has a
synchronous execution to express it only with 0-delay signal
assignments. Therefore, this semantics does not express synchronism of
execution in an explicit manner. Moreover, the component instantiation
statement is not treated by the semantics.

In \cite{Breuer1995a}, the authors give a denotational, yet
relational, semantics for VHDL. A state of a VHDL design is
represented by a function binding signals to values; a worldline is a
time-ordered list of states. Statements (including processes) are
denoted in the semantics by a relation that binds an input couple,
composed of a time point and a worldline, to an output couple of the
same type. Multiple input and output couples possibly satisfy the
relation denoting a particular statement; thus, the semantics is
undeterministic.  The semantics tries to abstract from the
formalization of the simulation cycle as it is done in the LRM. The
authors want to establish a semantics that is abstract enough to be
able to compare all other works of formalization with the authors
semantics. The authors also give an axiomatic semantics (i.e, in the
Hoare logic style) which is proved to be sound and complete with the
first denotational semantics. A \textsf{Prolog} \cite{Colmerauer1990}
implementation of the axiomatic semantics is given. Regarding our
needs, the semantics only deals with unit-delay signal assignments (no
0-delay), and therefore does not cover the VHDL subset that we are
interested in. The hierarchical structure of designs is also not
preserved, and, although expressible, the semantics does explicitly
express a synchronous simulation cycle.

The denotational semantics expressed in \cite{Pandey1999} uses
interval temporal logic as an underlying model. Leveraging this
underlying model, the authors are interested in proving some
properties over VHDL designs to help compilers to optimize the code,
for instance, by using rewrite rules proved to be valid against the
model. Some of the proofs laid out by the authors are embedded in PVS
\cite{Owre1994}. The expression of the dynamic model uses many
concepts described in the LRM, like drivers, port association, driving
and effective values for signals. The semantics deals with both
unit-delay and $\delta$-delay. The semantics works on fully-elaborated
designs, therefore, it does not deal with component instance
statements. Moreover, interval temporal logic is useful to reason on
the VHDL designs in the presence of delays, however, it looses its
interest for designs presenting only 0-delay assignments.

Joining the common opinion, in \cite{Borrione1995}, the author states
that ``denotational semantics is more adequate for mathematical
reasoning''. The author formalizes the VHDL semantics to prove the
equivalence between VHDL programs (for instance, a specification and
an implementation). What is of major interest regarding our needs is
that the author is interested in expressing a simulation cycle for
synchronous designs. Therefore, a distinction is made between
combinational and synchronous processes in the abstract
syntax. Moreover, this work formalizes the elaboration part of a VHDL
design former to the simulation; also, the elaboration keeps the
hierarchical setting of the VHDL design, that is component
instantiation statements are not replaced by processes.  Due to the
time abstraction, the semantics only deals with 0-delay. It is
explained by the fact that the reference time-unit is the clock period
(i.e, the only known time-step), and the advancing of time, happening
during the simulation cycle as described in the LRM, is captured
within the setting of the simulation cycle. Also, the semantics takes
primary inputs into account (i.e, input ports of the top-level
design); to preserve a synchronous behavior for the simulated design,
the hypothesis is made that the values of the primary inputs are
stable between two clock events. The only critic that can be made to
this semantics regarding our needs is that it is expressed in
denotational style.

\paragraph{Operational semantics}

Multiple works formalize an operational semantics for VHDL. Naturally,
these works are interested in the formal description of the VHDL
simulator, more or less closely to the description of the LRM.

In \cite{Breuer1995}, a formal description of a \emph{functional}
semantics for VHDL is laid out based on stream-processing
functions. The semantics is expressed with the functional programming
language \textsf{Gofer} \cite{Jones1994}, thus enabling the computation
of execution traces, that is, the computation of the streams
representing the values taken by signals over time.  As in the former
work of the same author \cite{Breuer1995a}, only unit-delay
signal assignments are dealt with, however, this time the author
describes a deterministic operational semantics. Regarding our needs,
this work is neither interested in preserving the hierarchical
structure of VHDL designs, and no mention is made regarding how a
design is elaborated, nor in expressing an explicit synchronous
simulation cycle.

In \cite{Borger1995}, the authors formalize the simulation loop of the
LRM using Evolving Algebra machines (EA-machines). All important
constructs of the VHDL language are represented as records; processes
are represented as concurrent agents running pseudo-codes, and the
simulation control flow is passed to and fro between the kernel
process (i.e, the simulation orchestrator) and the rest of the
processes that execute the design behavior. This semantics implements
closely the simulation loop as described in the LRM. Therefore, it is
very rich and deals with most of the VHDL constructs, including the
two time paradigms of the language. Moreover, the semantics works on
fully-elaborated designs, therefore, component instantiation
statements are omitted. However, a synchronous execution is fully
expressible even if not explicitly embedded in the expression of the
simulation loop.

In \cite{VanTassel1995}, the author presents a natural semantics for
VHDL. The simulation loop is expressed by inference rules, and the
execution of processes is based on the events over signals of their
corresponding sensitivity lists. The execution of statements computes
transaction traces, that is, the projected waveforms for signals over
the future of the simulation. The semantics deals both with unit and
delta delays. Regarding our needs, this semantics covers the subset of
the VHDL language that we are interested in, even if, it also covers
some constructs pertaining to unit delays that are irrelevant to us
(like wait and unit-delay signal assignment statements). A synchronous
execution is expressible within the semantics, although it would be
hidden in the inference rule formalizing the generic simulation loop.
Also, the semantics does not provided its simulation loop with a
simulation horizon (a maximum number of simulation cycle to be
computed). The simulation ends when signal values evolve no more.  The
question of the influence of the environment, measured through the
values of the primary inputs of a design, is not discussed.

In \cite{Goossens1995}, the author presents an operational semantics
for VHDL in the small-step style. The semantics follows closely the
simulation cycle described in the LRM; however it is very concise and
clear. The covered VHDL subset comprises arbitrary wait statements,
and both unit and delta-delay signal assignments. There is a
interested discussion about the non-determinism of VHDL, since it is a
concurrent programming language: it entails that non-determinism is
only existent at the processes level, that is, internal sequential
statement of processes can be executed in an undeterministic manner
(refered to by the author as A actions, that is, \emph{internal}
actions).  But at every delta or time step (refered to as $\delta$ and
T actions) of the execution, the design state can be computed in a
deterministic manner, since all process have reached a wait statement
that stalled the execution of their inner body. The author is
interested in the comparison of the behavior, and therefore, the
equivalence between to VHDL programs. He describes two strategies to
compare VHDL programs. The first one is bisimulation; it is based on
the comparison of the sequence of actions (either A, $\delta$ or T
actions) performed by the two programs. The second one is
oberservational equivalence; it is based on the observation of the
value of the output signals of two VHDL programs (the observees), that
receive values in their input signals from another VHDL program (the
observer). The observer stimulates the entries of the observees and
reaches a success state based on its observations of the value of the
outputs. Regarding our needs, this semantics permits the description
of our synchronous simulation cycle. However, like most of the
semantics presented here, the component instantiation statement is not
supported as it stands, but it is rather transformed into the
equivalent processes statements. Small-step semantics is not needed in
our case because we are only interested in the values of signals at
the delta and time steps (for us, time steps correspond to clock
events). We are not interested to capture the design states in the
middle of the execution of a process body. We are more interested in
"weak bisimulation", therefore forsaking the internal actions (i.e, A
actions, execution of a process body that does not end in a wait
statement) performed by a VHDL program. Indeed, a natural operational
semantics in the style of Van Tassel's \cite{VanTassel1995} is
sufficient in our case. In \cite{Thirunarayan2001}, the authors extend
the work of \cite{Goossens1995}, especially by handling shared
variables, in the presence of which a VHDL program can have a concrete
underterministic behavior. The authors are also interested in the
equivalence between two VHDL programs, and they are interested in
determining a unique meaning property for VHDL programs. The unique
meaning property states that the execution of a VHDL design in the
presence of shared variables is unique. This work is interesting as it
points out the fact that VHDL is not only subject to benign
undeterminism. However, we are not interested in dealing with
constructs so advanced as shared variables or postponed processes,
therefore, this work is not really relevant to us.

\paragraph{Translational semantics}
Another kind of semantics, called ``translational'', is interested in
establishing a formal semantics for VHDL by translating a VHDL design
into another formal model. Thus, the semantics of VHDL is modeled by
the translation and the formal semantics of the target model. The
target model has the ability to model concurrency, which is one of the
specificity of VHDL. Moreover, target models are chosen because of the
tools that they provide for analysis, and thus, a translational
semantics for VHDL is often related to model checking considerations.

In \cite{Reetz1995}, the author expresses the formal semantics of VHDL
by translating a VHDL design into a corresponding flowgraph. All VHDL
constructs, ranging from sequential statements to concurrent
processes, are expressed with individual flowgraphs that are then
composed together through their interfaces. The simulation cycle of
VHDL is also encoded by means of connected flow graphs: one for the
``execution part'' of the semantics, that is, all processes run until
blocked in a wait configuration, and one for the update part (i.e, the
kernel process in the semantics of \cite{Borger1995}). Flowgraphs come
with a large amount of tools for analysis, and this translational
semantics is involved in the setting of a framework to reason about
VHDL programs using multiple technics (automatic theorem proving,
model checking\dots). All these technics lean on the flowgraph
formalism.

In \cite{Dohmen1995}, the author introduces a translational semantics
for VHDL based on deterministic finite-state automatons. Again, the
reason for using such automatons lies in the existence of many
analysis tools. Moreover, forcing the generation of deterministic
automatons improves the time execution of model-checking technics.
The translation is performed on an elaborated VHDL design; a data
space stores the values of signals and variables, and automatons
represent the control-flow of VHDL statements. Each VHDL statement is
associated to a specific automaton; sequence of statements are
achieved by automaton composition. The simulation kernel is also
represented by a specific automaton. Processes are composed together
with respect to synchronization states, i.e. states that permit to pass the
control from one process to another (for instance, after a wait
statement), therefore achieving determinism in the control flow of the
overall automaton.

In \cite{Olcoz1995}, the author presents a translation from VHDL to
Coloured Petri Nets (CPNs) thus giving a formal semantics to VHDL
constructs. The author approach to VHDL semantics is a strict
translation of the ``event-based'' VHDL simulator by means of Petri
nets.  The author translates VHDL execution models (sea of processes)
into CPNs, and also translates the kernel process into a CPN. The
kernel process has previously been expressed as a VHDL process so that
the translation into CPN is similar to the translation of other
processes.  Signals are not represented in the subnets, instead, three
shared variables depict the signal states: one variable for the
driving, one for the effective and one for the current value of a
given signal.  Colour domains of places in the subnets represent the
different types of VHDL domains.  Variables are represented by tokens.
Values in drivers are represented by sequences of transactions
(equivalent to waveforms); the author defines a set of functions that
are convenient to handle sequences of transactions.  Sequential
statements are partitioned into two kinds: control flow (if, loop,
case\dots) and notation (operations on signals and variables) nets.
Processes subnets are made by the fusing of each sequential statements
in the process body. There is a special \emph{Resume} place that can
be set by the kernel process to resume the activity of a process.
Concurrency is not discussed here, as the Petri net models are
inherently concurrent models.  The kernel process is a broad CPN
having some of its places interfaced with the process subnets.  The
decoloration of the Petri net enables the analysis of the model and
the detection of dead-locks. 

In \cite{Deharbe1995}, the author gives a formal smeantics to VHDL by
transforming a VHDL design into an abstract machine, i.e defined by a
set of inputs, outputs, states and transition function over states and
outputs. The author is interested in the verification of properties
over VHDL designs (temporal properties) or to prove equivalence
between designs (bisimulation).  To operate this transformation, only
a subset of VHDL is considered, otherwise a finite-state
representation is not reachable.  The covered VHDL subset consists of
objects with finite types, and no quantitative timing constructs (no
after clause in signal assignments or \emph{for} clause in wait
statements).  The author claims that a VHDL design is implemented by
an abstract machine if they have the same observational behavior, i.e,
for the same value in their inputs they yield the same values in their
outputs.  Each process statement part is transformed into a decision
diagram (control flow graph); then, the decision diagram encodes the
transition functions over states and outputs in the abstract machine
implementing the corresponding process.  Process statements are
composed in relation to some composition operator. Moreover, the
article lays out a method to transform a block statement into an
abstract machine. The initiative is to be noticed as there are few
papers of the VHDL semantics that are interested in such hierarchical
constructs as block or component instantiation statements. The article
concludes with an expression of the space of complexity entailed by
the transformation of a VHDL design into an abstract machine.

Although the translational semantics described above meet most of the
qualifying criterions in relation to our needs, we are not especially
interested in implementing one of these. The main reason being that it
would necesitate the implementation of the tranformation from the
abstract VHDL syntax to the target model in addition to the
implementation of the semantics of the target model.

Table~\ref{tab:sum-vhdl-sem} summarizes the analysis of the VHDL
semantics encountered during our literature
review. Table~\ref{tab:sum-vhdl-sem} compares the different VHDL
semantics in relation to the qualifying criterions (see
Section~\ref{sec:qualifying-criterions}).

\newcommand{\YO}{\cellcolor{YellowOrange}}
\newcommand{\Gre}{\cellcolor{Green}}
\newcommand{\LGr}{\cellcolor{lightgray}}
\newcommand{\R}{\cellcolor{Red}}

\begin{table}[H]
  \resizebox{\textwidth}{!}{%
    \renewcommand{\arraystretch}{1.5}
    \begin{tabular}{ll|c|c|c|c|c|c|c|c|c|c|c|c|c|}

      % TABLE HEADER
      \cline{3-14}
      & &  &  &  &  &  &  &  &  &  &  &  &  \\
      &
      & \begin{tabular}[t]{@{}c@{}}\rotatebox[origin=r]{270}{Fuchs and Mendler} \\ \cite{Fuchs1995} \end{tabular}  
      & \begin{tabular}[t]{@{}c@{}}\rotatebox[origin=r]{270}{Breuer et al.} \\ \cite{Breuer1995a} \end{tabular}
      & \begin{tabular}[t]{@{}c@{}}\rotatebox[origin=r]{270}{Pandey et al.} \\ \cite{Pandey1999} \\ \end{tabular}
      & \begin{tabular}[t]{@{}c@{}}\rotatebox[origin=r]{270}{Borrione and Salem } \\ \cite{Borrione1995} \\\end{tabular}
      & \begin{tabular}[t]{@{}c@{}}\rotatebox[origin=r]{270}{Breuer et al. } \\ \cite{Breuer1995} \\ \end{tabular}
      & \begin{tabular}[t]{@{}c@{}}\rotatebox[origin=r]{270}{Börger et al. } \\ \cite{Borger1995} \\ \end{tabular}
      & \begin{tabular}[t]{@{}c@{}}\rotatebox[origin=r]{270}{Van Tassel} \\ \cite{VanTassel1995} \\ \end{tabular}
      & \begin{tabular}[t]{@{}c@{}}\rotatebox[origin=r]{270}{Goossens} \\ \cite{Goossens1995} \\ \end{tabular}
      & \begin{tabular}[t]{@{}c@{}}\rotatebox[origin=r]{270}{Reetz and Kropf} \\ \cite{Reetz1995} \\ \end{tabular}
      & \begin{tabular}[t]{@{}c@{}}\rotatebox[origin=r]{270}{Döhmen and Herrmann} \\ \cite{Dohmen1995} \\ \end{tabular}
      & \begin{tabular}[t]{@{}c@{}}\rotatebox[origin=r]{270}{Olcoz} \\ \cite{Olcoz1995} \\ \end{tabular}
      & \begin{tabular}[t]{@{}c@{}}\rotatebox[origin=r]{270}{Déharbe and Borrione} \\ \cite{Deharbe1995} \\ \end{tabular}
      \\

      % SEMANTICS DESCRIPTION

      
      % kind of semantics (D, O, T).
      \hline
      \multicolumn{1}{|c|}{}
      & Kind & \YO D & \YO D, A & \YO D & \YO D & \Gre O & \Gre O & \Gre O & \Gre O & \YO T & \YO T & \YO T & \YO T \\
      
      % purpose of the formalization.
      \cline{2-14}
      \multicolumn{1}{|c|}{\multirow{-2}{*}{\begin{tabular}[c]{@{}c@{}}Semantics\\ Description\end{tabular}}}
      & Purpose & \LGr AR, ATP & \LGr AR & \LGr AR & \LGr AR & \Gre SS & \Gre SS & \Gre SS, ITP & \Gre SS, MC & \Gre ATP, MC, ITP
                                   & \Gre MC, ITP & \LGr MC & \LGr MC \\

      % QUALIFYING CRITERIONS
      
      \hline
      
      % component instantiation covered?
      \multicolumn{1}{|l|}{\multirow{3}{*}{\begin{tabular}[c]{@{}l@{}}Qualifying\\ Criterions\end{tabular}}}
      & \begin{tabular}[c]{@{}l@{}}Component\\ Instantiation\end{tabular}
      & \YO T & \YO T & \YO T & \Gre N & \YO T & \YO T & \YO T & \YO T & \YO T & \YO T & \YO T & \Gre N \\

      % Synchronism expressibility status
      \cline{2-14} 
      \multicolumn{1}{|l|}{} & Synchronism & \R NE & \R NE & \R NE & \Gre Ex & \YO E & \YO E & \YO E & \YO E & \YO E & \YO E & \YO E & \R NE \\

      % Elaboration is formalized?
      \cline{2-14} 
      \multicolumn{1}{|l|}{}
      & Elaboration &\YO $\times$ &\YO $\times$ &\YO $\times$ & \Gre \checkmark &\YO $\times$ &\YO $\times$ & \Gre \checkmark &\YO $\times$ &\YO $\times$ &\YO $\times$ &\YO $\times$ & \Gre \checkmark \\ 
      
      % EXTRA. INFORMATION.

      \hline

      \multicolumn{1}{|c|}{\multirow{2}{*}{\begin{tabular}{@{}l@{}}Extra.\\ Informations.\end{tabular}}}
      
      % implementation technology
      & \begin{tabular}[c]{@{}l@{}} Impl.\\ Technology\end{tabular}
      & \LGr Focus \cite{Dederichs1993} & \LGr Prolog \cite{Colmerauer1990} & \LGr PVS \cite{Owre1994} & \LGr ? & \LGr Gofer \cite{Jones1994}
                    & \LGr ? & \LGr HOL \cite{Hutton1994} & \LGr ? & \LGr HOL \cite{Hutton1994} & \LGr ? & \LGr ? & \LGr ? \\
      
      % particular models or data types 
      \cline{2-14} 
      \multicolumn{1}{|c|}{}
      & \begin{tabular}[!htbp]{@{}l@{}}Particular\\ Model or\\ Data Types\end{tabular}
      & \LGr \begin{tabular}[c]{@{}c@{}}Stream \\ Processing \end{tabular}
      & \LGr No & \LGr \begin{tabular}[c]{@{}c@{}}Interval\\ Temporal \\ Logic \end{tabular}
      & \LGr No & \LGr \begin{tabular}[c]{@{}c@{}}Stream \\ Processing \end{tabular}
      & \LGr \begin{tabular}[c]{@{}c@{}}Evolving \\ Algebra \\ Machines \end{tabular}
      & \LGr \begin{tabular}[c]{@{}c@{}}Natural \\ Semantics \\ (big-step) \end{tabular}
      & \LGr \begin{tabular}[c]{@{}c@{}}Structural \\ Semantics \\ (small-step) \end{tabular}
      & \LGr \begin{tabular}[c]{@{}l@{}}Flow \\ Graphs \end{tabular}
      & \LGr \begin{tabular}[c]{@{}c@{}}Finite-State \\ Automatons \end{tabular}
      & \LGr \begin{tabular}[c]{@{}c@{}}Colored \\ Petri \\ Nets \end{tabular}
      & \LGr \begin{tabular}[c]{@{}c@{}}Abstract \\ Machines \\ and \\ Decision \\ Diagrams \end{tabular} \\
      \hline
    \end{tabular}%
  }
  \caption{A comparative summary on VHDL formal semantics.}
  \label{tab:sum-vhdl-sem}

  \begin{itemize}[label=-]
    \fontsize{8}{10}\selectfont
  \item Kind : D (Denotational) - A (Axiomatic) - O (Operational) - T (Translational).
  \item Purpose : AR (Abstract Reasoning) - ATP (Automatic Theorem
    Proving) - SS (Simulator Specification) - ITP (Interactive Theorem
    Proving) - MC (Model Checking).
  \item Component Instantiation : T (statement is \emph{Transformed}
    into equivalent processes) - N (statement is \emph{Natively} taken into account in the semantics).
  \item Synchronism : E (Expressible within the semantics) - NE (Not
    Expressible within the semantics) - Ex (Explicitly built in the
    semantics).
  \end{itemize}
\end{table}

To summarize, we are interesting in a semantics with an operational
setting, built for the purpose of interactive theorem proving
(ideally, with an existing implementation in the \coq{} proof
assistant). Most important, the formal semantics must be able to deal
with the expression of synchronous designs, that is, designs
synchronized with a clock signal. Therefore, a synchronous simulation
cycle must be at least expressible within the semantics. Moreover, the
semantics must handle component instantiation statements as they are,
that is, without transforming them into equivalent processes. As a
bonus, the semantics should formalize the elaboration part of VHDL
semantics.

In Table~\ref{tab:sum-vhdl-sem}, cells are colored in green when the
cell's content foster the adoption of the semantics, in yellow when
the content does not go towards the adoption of the semantics but is
not disqualifying, and red when the content is a disqualifying
criterion. Cell are labelled in light grey when their content is
neutral in relation to the semantics adoption. Now comparing the
entries of Table~\ref{tab:sum-vhdl-sem} with the expression of our
needs, we can discard the semantics with a cell labelled in red, that
is most of the denotational semantics; moreover, all translational
semantics are let aside for the reasons cited before. The candidate
semantics are the operational semantics, plus the denotational
semantics by Borrione and Salem \cite{Borrione1995}, the only
semantics that formalizes an explicitly synchronous simulation
cycle. The semantics that is the most likely to be adopted is the
Borrione and Salem's semantics. However, we prefer an operational
setting for our semantics because it is more fit to our task. To lower
down the complexity of proofs, we really need a semantics that builds
the synchronism into its simulation cycle, therefore putting aside all
the intricacies of the full-blown VHDL simulation cycle. Moreover, the
big-step style for an operational semantics is more relevant to us; as
stated before, we are not interested in the intermediary states of
computation that a small-step style semantics considers.  Based on the
observations, we have decided to formalize our own VHDL semantics
inspired from the semantics of Borrione and Salem's
\cite{Borrione1995} and Van Tassel's \cite{VanTassel1995}. The
following sections are dedicated to the presentation of the syntax and
semantics of a subset of VHDL called \hvhdl{}. \hvhdl{} embeds the
subset of VHDL that we are interested in when considering the VHDL
designs generated by the \hilecop{} transformation.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../main"
%%% End:
