\subsection{Semantic domains}

Let $id$ denote the set of identifiers in the semantic domain. We
write $prefix\mhyphen{}id$ to denote arbitrary subsets of the $id$
set. The $type$ and $value$ semantic types are defined as follows:

\begin{table}[H]
  \caption{The $type$ and $value$ semantic types.}
  \label{tab:type-value}

  \begin{tabular}{lcl}
    $type$ & ::= & $bool$ | $nat(n$, $n)$ | $array(type$, $n$, $n)$ \\
           & & \\a
    $value$ & ::= & $b$ | $n$ | $arr$ \\
    $b$ & ::= & '$\mathbf{\top}$' | '$\mathbf{\bot}$' \\
    $n$ & ::= & \texttt{0} | \texttt{1} | \dots | \texttt{NATMAX} \\
    $arr$ & ::= & \texttt{(}$value^{+}$\texttt{)}\\

  \end{tabular}
\end{table}

In Table~\ref{tab:type-value}, the $type$ type is in any way similar
to the $\tau$ entry of the \hvhdl{} abstract syntax. However, all
constraint bounds, that were taking the form of expressions in the
constrained natural and the array type indications, have been
evaluated to natural numbers. $\mathtt{NATMAX}$ denotes the maximum
value for a natural number.  The $\mathtt{NATMAX}$ value depends on
the implementation of the VHDL language; $\mathtt{NATMAX}$ must at
least be equal to $2^{31}-1$. Note that the $array$ value contains at
least one value as an array's index range contains at least one index.

% \begin{notation}[Partial functions]
%   In the following sections, when the context is free from any
%   ambiguity, we adopt the following notations:
%   \begin{itemize}[label=-]
%   % \item The $\nrightarrow$ arrow denotes a partial function.
%   % \item The $\rightarrow$ denotes an application (i.e, a total
%   %   function).
%   \item For all $f\in{}A\nrightarrow{}B$, $x\in{}f$ states that x is in
%     the domain of function $f$.
%   \item For all $f\in{}A\nrightarrow{}B$ and $g\in{}A\nrightarrow{}C$,
%     $f\subseteq{}g$ states that the domain of $f$ is a subset of the
%     domain of $g$.
%   \item For all $X\subset{}A$ and $f\in{}A\nrightarrow{}B$,
%     $X\subseteq{}f$ states that $X$ is a subset of the domain of $f$.
%   \end{itemize}
% \end{notation}

\subsection{Elaborated design and design state}
\label{sec:elab-design-and-state}

Now, let us define the structure of \textit{elaborated design}. An
elaborated design is built during the elaboration of an \hvhdl{}
design (see Section~\ref{sec:elab-rules}). Then, the elaborated design
will act as a runtime environment in the expression of the simulation
rules. Let $ElDesign$ be the set of the elaborated designs. An
elaborated design is a composite environment built out of multiple
sub-environments.  Each sub-environment is a table, represented as a
function, mapping identifiers of a certain category of constructs
(e.g, input port identifiers) to their declaration information (e.g,
type indication for input ports). We represent an elaborated design as
a record where the fields are the sub-environments. An elaborated
design is defined as follows:

\begin{definition}[Elaborated Design]
  \label{def:elab-design}
  An elaborated design $\Delta\in{}ElDesign$ is a record\\
  ${<}Gens, Ins, Outs, Sigs, Ps, Comps{>}$ where:
  \begin{itemize}[label=$-$]
  \item $Gens\in{}generic\mhyphen{}id\rightarrow{}(type\times{}value)$
    is the function yielding the type and the value of generic
    constants.
  \item $Ins\in{}input\mhyphen{}id\rightarrow{}type$ is the function
    yielding the type of input ports.
  \item $Outs\in{}output\mhyphen{}id\rightarrow{}type$ is the function
    yielding the type of output ports.
  \item
    $Sigs\in{}declared\mhyphen{}signal\mhyphen{}id\rightarrow{}type$
    is the function yelding the type of declared signals.
  \item
    $Ps\in{}process\mhyphen{}id\rightarrow(variable\mhyphen{}id\rightarrow{}(type\times{}value))$
    is the function associating process identifiers to their local
    environment.
  \item $Comps\in{}component\mhyphen{}id{}\rightarrow{}ElDesign$ is
    the function mapping component instance identifiers to their own
    elaborated design version
  \end{itemize}
\end{definition}

We assume that there are no overlapping between the identifiers of the
sub-environments (i.e, an identifier belongs to at most one
sub-environment), and also between the identifiers of the
sub-environments and the identifiers of local environments. When there
is no ambiguity, we write $\Delta(x)$ to denote the value returned for
identifier $x$, where $x$ is looked up in the appropriate field of
$\Delta$. We write $x\in\Delta$ to state that identifier $x$ is
defined in one of $\Delta$'s fields. We note $\Delta(x)\leftarrow{}v$
the overriding of the value associated to identifier $x$ with value
$v$ in the appropriate field of $\Delta$, $\Delta\cup{}(x,v)$ to note
the addition of the mapping from identifier $x$ to value $v$ in the
appropriate field of $\Delta$, that assuming $x\notin\Delta$. We write
$x\in\mathcal{F}(\Delta)$, where $\mathcal{F}$ is a field of $\Delta$,
when more precision is needed regarding the lookup of identifier $x$
in the record $\Delta$.

Let $\Sigma$ be the set of design states.  A design state of
$\sigma\in{}\Sigma$ is defined as follows:

\begin{definition}[Design state]
  \label{def:design-state}
  A design state $\sigma\in\Sigma$ is a record
  ${<}\mathcal{S},\mathcal{C},\mathcal{E}{>}$ where:
  \begin{itemize}[label=$-$]
  \item $\mathcal{S}\in{}signal\mhyphen{}id\rightarrow{}value$, is the
    function yielding the current values of the design's signals
    (ports and declared signals).
  \item $\mathcal{C}\in{}component\mhyphen{}id\rightarrow{}\Sigma$, is
    the function yielding the current state of component instances.
  \item
    $\mathcal{E}\subseteq{}signal\mhyphen{}id\sqcup{}component\mhyphen{}id$,
    is the set of signal and component instance identifiers that
    generated an event at the current design state.
  \end{itemize}
\end{definition}

The $signal\mhyphen{}id$ subset is the disjoint union of
$input\mhyphen{}id$, $output\mhyphen{}id$ and
$declared\mhyphen{}signal\mhyphen{}id$. We use $\sigma(id)$ to denote
the value associated to an identifier in the signal store
$\mathcal{S}$ or in the component store $\mathcal{C}$ fields. When
there is no ambiguity, we write $id\in\sigma$ to state that an
identifier is defined in either the signal store $\mathcal{S}$ or the
component store $\mathcal{C}$ fields. Also, when there is no
ambiguity, we rely on indices or exponents to qualify the signal
store, the component instance store and the set of events of a given
design state. For instance, $\mathcal{C}_0$ denotes the component
instance store of design state $\sigma_0$, and $\mathcal{E}'$ denotes
the set of events of design state $\sigma'$, etc.

\begin{notation}[No events design state]
  \label{notation:noev}
  The function $NoEv\in\Sigma\rightarrow\Sigma$ returns a design state
  similar to the one passed in parameter but with an empty set of
  events. I.e, for all design state $\sigma\in\Sigma$
  s.t. $\sigma={<}\mathcal{S},\mathcal{C},\mathcal{E}{>}$,
  $NoEv(\sigma)={<}\mathcal{S},\mathcal{C},\emptyset{>}$.
\end{notation}

% \subsection{Design evaluation workflow.}
% \label{subsec:elab-sim-wflow}

% The workflow to evaluate a top-level VHDL design comprises two phases
% with some pre-requisites.

% \begin{figure}[H]
%   \centering
%   \begin{tikzpicture}

%     \node(elab) {\textcircled{1} Elaboration phase};
%     \node(sim) at ($(elab.east)+(2.5,0)$) {\textcircled{2} Simulation phase};

%     \draw (elab.east) edge[->] ($(sim.west)-(.1,0)$);
%   \end{tikzpicture}
%   \caption{Workflow for \emph{top-level} design evaluation.}
%   \label{fig:toplevel-eval}
% \end{figure}

% \begin{itemize}[label=-]
% \item Pre-requisites to the top-level design evaluation are as
%   follows:

%   \begin{enumerate}
%   \item All types and subtypes defined in VHDL standard library packages
%     are present in the environment, under the $\Gamma$ parameter.
%   \item All types and subtypes defined in user-defined packages are
%     present in the environment, under the $\Gamma$ parameter.
%   \item All globally defined constants will be considered as known
%     values in the elaboration/simulation rules.
%   \item No shared variables or signals are globally declared.
%   \end{enumerate}
  
% \item The \emph{elaboration} phase:

%   \begin{enumerate}
%   \item Builds a functor for each design of the project, including for
%     the top-level design.
%   \item Type-check designs' declarative parts.
%   \item Type-checks designs' behavioral parts.
%   \end{enumerate}

% \item The \emph{simulation} phase:
%   \begin{enumerate}
%   \item Instantiates the top-level design thanks to the $I_p$ function
%     yelding the primary input values.
%   \item Simulates the top-level design until $T_c$, the count of
%     simulation cycles, equals $0$.
%   \end{enumerate}
% \end{itemize}

% \subsection{Notation of rules.}
% \todo[inline]{Add examples of type-checking rules.}

% Semantics rules are expressed by judgments that take the following form: 

% \begin{figure}[H]

  
%   \centering
%   \begin{prooftree}
%     \hypo{env &\vdash \mathtt{a}\xrightarrow{rel}i}
%   \end{prooftree}
% \end{figure}

% Here is how to interpret the above judgment: some syntactic element
% \texttt{a} of the VHDL language is interpreted as \textit{i}
% with respect to the relation \textit{rel}, in the environment
% \textit{env}.

% Moreover, semantics rules can be with or without premises.

% \begin{figure}[H]
%   {\fontsize{8}{11}\selectfont \textsc{Axiom}}
  
%   \begin{prooftree}
%     \infer0{
%       env \vdash \mathtt{a}{}\xrightarrow{rel}i
%     }
%   \end{prooftree}
% \end{figure}

% Semantics rules without premises, as the one shown above, are called
% axioms.

% \begin{figure}[H]
%   {\fontsize{8}{11}\selectfont \textsc{WithPremises}}
  
%   \begin{prooftree}
%     \hypo{env &\vdash \mathtt{a}\xrightarrow{rel}i}
%     \hypo{env &\vdash \mathtt{b}\xrightarrow{rel}j}
%     \infer2{
%       env \vdash S\mathtt{(a,b)}\xrightarrow{rel}I(i,j)
%     }
%   \end{prooftree}
% \end{figure}

% The above example depicts a rule with premises. The premises are
% placed above the judgment bar, and the conclusion appears below.  The
% above rule expresses that if the syntactic element \texttt{a} is
% interpreted as \textit{i} and the syntactic element \texttt{b} is
% interpreted as \textit{j} both with respect to relation \textit{rel},
% then the syntactic element $S\mathtt{(a,b)}$ is interpreted as
% $I\mathtt{(i,j)}$ with respect to relation \textit{rel}. Here, $S$ is
% a relation appearing in the syntax of the VHDL language and bounding
% syntactic elements \texttt{a} and \texttt{b}, whereas $I$ is a
% relation belonging to the interpretation world, bounding elements $i$
% and $j$ which are both interpretation results.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../main"
%%% End:
