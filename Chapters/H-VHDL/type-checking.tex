\subsection{Typing relation}
\label{subsec:constr-satif-rel}

The typing relation $\in_c$ checks that a given value conforms to a
given type.

\begin{table}[H]
  \centering
  \begin{tabular}{@{}l}
    {\fontsize{8}{11}\selectfont\textsc{IsBool}} \\
    {\begin{prooftree}

        % Conclusion.
        \infer0[$b\in{}\mathbb{B}$]{b\in_c{}bool}
      \end{prooftree}} \\
  \end{tabular}
  \begin{tabular}{@{}l}
    {\fontsize{8}{11}\selectfont\textsc{IsCNat}} \\
    {\begin{prooftree}

        % Conclusion.
        \infer0[$n\in{}[l,u]$]{n\in_c{}nat(l,u)}
      \end{prooftree}} \\
  \end{tabular}
  \begin{tabular}{@{}l}
    {\fontsize{8}{11}\selectfont\textsc{Array}} \\
    {\begin{prooftree}
        
        % Subelements satisfy subtype indication's constraint.
        \hypo{v_i\in_c{}T}
        
        % Conclusion.
        \infer1
        [{
          \begin{tabular}{@{}l}
            $i=1,\dots,n$ \\
            $n=(u-l)+1$ \\
          \end{tabular}
        }]
        {
          \Delta\vdash
          \mathtt{(}v_1,\dots,v_n\mathtt{)}
          \in_c
          array(T,l,u)}
      \end{prooftree}} \\
  \end{tabular}
\end{table}

\subsection{Static expressions}
\label{subsubsec:wfe}

Static expressions are either locally static or globally static; the
LRM defines locally static and globally static expressions as follows.

\subsubsection{Locally static expressions}
\label{subsubsec:loc-static}

An expression is \emph{locally} static if:

\begin{itemize}[label=-]
\item It is composed of operators and operands of a \emph{scalar} type
  (i.e, \texttt{natural} or \texttt{boolean}).
\item It is a \emph{literal} of a scalar type.
\end{itemize}

The $SE_l$ relation, defined by the following rules, states that an
expression is locally static.

\begin{table}[H]
  \begin{tabular}{@{}l}
    {\fontsize{8}{11}\selectfont\textsc{LSENat}} \\
    {\begin{prooftree}
        
        % Conclusion
        \infer[template={\inserttext}]0
        [$\mathrm{n}\in\mathbb{N}$]
        {$SE_l(\mathrm{n})$}
      \end{prooftree}} \\
  \end{tabular}
  \begin{tabular}{@{}l}
    {\fontsize{8}{11}\selectfont\textsc{LSEBool}} \\
    {\begin{prooftree}
        
        % Conclusion
        \infer[template={\inserttext}]0
        [$\mathrm{b}\in\mathbb{B}$]
        {$SE_l(\mathrm{b})$}
      \end{prooftree}} \\
  \end{tabular}
  \begin{tabular}{@{}l}
    {\fontsize{8}{11}\selectfont\textsc{LSENot}} \\
    {\begin{prooftree}

        % Locally static e.
        \hypo{SE_l(\mathrm{e})}
        
        % Conclusion
        \infer[template={\inserttext}]1
        {
          $SE_l(\mathtt{not}~\mathrm{e})$
        }
      \end{prooftree}} \\
  \end{tabular}
  \begin{tabular}{@{}l}
    {\fontsize{8}{11}\selectfont\textsc{LSEBinOp}}\\    
    {\begin{prooftree}

        % Locally static e.
        \hypo{SE_l(\mathrm{e})}

        % Locally static e'.
        \hypo{SE_l(\mathrm{e'})}
        
        % Conclusion
        \infer[template={\inserttext}]2
        [$\mathtt{op}\in\{~+,-,=,\neq,<,\le,>,\ge,\mathtt{and},\mathtt{or}~\}$]
        {
          $SE_l(\mathrm{e}~\mathtt{op}~\mathrm{e'})$
        }
      \end{prooftree}}\\
  \end{tabular}
\end{table}

\subsubsection{Globally static expressions}
\label{subsubsec:glob-static}

An expression is \emph{globally} static in the context $\Delta$ if:

\begin{itemize}[label=-]
\item It is a generic constant.
\item It is an array aggregate composed of globally static
  expressions.
\item It is a locally static expression.
\end{itemize}

The $SE_g$ relation, defined by the following rules, checks that an
expression is globally static is a given context $\Delta$.

\begin{table}[H]
  \centering
  \begin{tabular}{@{}l}
    {\fontsize{8}{11}\selectfont\textsc{GSELocal}} \\
    {\begin{prooftree}

      % Locally static e.
      \hypo{SE_l(\mathrm{e})}
      
      % Conclusion
      \infer[template={\inserttext}]1
      {
        $\Delta\vdash{}SE_g(\mathrm{e})$
      }
    \end{prooftree}} \\
  \end{tabular}
  \begin{tabular}{@{}l}
    {\fontsize{8}{11}\selectfont\textsc{GSEGen}} \\
    {\begin{prooftree}
      
      % Conclusion
      \infer[template={\inserttext}]0
      [{\renewcommand{\arraystretch}{1.5}
        \begin{tabular}{@{}l}
          $\mathrm{id}_g\in{}Gens(\Delta)$ \\
        \end{tabular}
      }]
      {
        $\Delta\vdash{}SE_g(\mathrm{id}_g)$
      }
    \end{prooftree}} \\
  \end{tabular}
  \begin{tabular}{@{}l}
    {\fontsize{8}{11}\selectfont\textsc{GSEAggregate}} \\
    {\begin{prooftree}

        % Locally static e.
        \hypo{\Delta\vdash{}SE_g(\mathrm{e}_i)}
        
        % Conclusion
        \infer[template={\inserttext}]1
        [$i=1,\dots,n$]
        {
          $\Delta\vdash{}SE_g($\texttt{(}$\mathrm{e}_1,\dots,\mathrm{e}_n$\texttt{)}$)$
        }
      \end{prooftree}} \\
  \end{tabular}
\end{table}

\subsection{Valid port map}
\label{subsec:valid-pm}

\paragraph{Valid input port map}

The $\mathtt{valid}_{ipm}$ predicate states that an \emph{input} port
map is valid in the context $\Delta,\Delta_c$, where $\Delta$ is the
embedding design structure and $\Delta_c$ denotes the component
instance owner of the input port map, if:

\begin{itemize}[label=-]
\item All ports defined in $\Delta_c$ are exactly mapped once in the
  input port map.
\item For each input port map entry, the formal and actual part are of
  the same type.
\end{itemize}

\begin{premises}
  \begin{itemize}[label=-]
  \item $list_{ipm}$ builds a set
    $\mathcal{L}\subset{}id\sqcup{}(id\times\mathbb{N})$ out of the
    input port map.
  \item $\mathtt{check}_{pm}$ checks the validity of a port map based
    on the corresponding port list (here, the input ports of
    $\Delta_c$) and the set built by the $list_{ipm}$ relation.
  \end{itemize}
\end{premises}

\begin{table}[H]
  \centering
  \begin{tabular}{l}
    {\fontsize{8}{11}\selectfont\textsc{ValidIPM}} \\
    {\begin{prooftree}

        % Lists formal parts.
        \hypo{\Delta,\Delta_c,\sigma,\mathcal{L}_\emptyset\vdash\mathrm{ipmap}\xrightarrow{list_{ipm}}\mathcal{L}}

        % Well-formed port map.
        \hypo{\mathtt{check}_{pm}(Ins(\Delta_c),\mathcal{L})}
        
        % Conclusion
        \infer[template={\inserttext}]2
        {
          $\Delta,\Delta_c,\sigma\vdash\mathtt{valid}_{ipm}(\mathrm{ipmap})$
        }
      \end{prooftree}} \\
  \end{tabular}
\end{table}

The $list_{ipm}$ relation builds a set of identifiers and couples
(identifier, natural number) collected from the identifiers and
indexed identifiers in the formal part (i.e. at the left of the
association arrow) of an input port map. It also checks, for each
association of the input port map, that the expression of the actual
part are is of the same type than the identifier or indexed identifier
of the formal part.

\begin{sideconds}
  \begin{itemize}
  \item $\mathrm{id}_f\in{}Ins(\Delta_c)$ checks that the identifier
    $\mathrm{id}_f$ is an input port identifier of $\Delta_c$.
  \item $\mathrm{id}_f\notin\mathcal{L}$ checks that the port
    identifier $id_f$ is not already mapped, i.e. it is not already
    referenced in the $\mathcal{L}$ set.
  \end{itemize}
\end{sideconds}

\begin{table}[H]
  \begin{tabular}{@{}l}
    {\fontsize{8}{11}\selectfont\textsc{ListIPMSimple}} \\
    {\begin{prooftree}

        % Evaluates actual.
        \hypo{\Delta,\sigma\vdash\mathrm{e}~\xrightarrow{e}v}

        % Well-typed actual.
        \hypo{v\in_c{}T}
        
        % Conclusion
        \infer[template={\inserttext}]
        2
        [{\renewcommand{\arraystretch}{1.5}
          \begin{tabular}{l}
            $\mathrm{id}_f\notin\mathcal{L}$, $\mathrm{id}_f\in{}Ins(\Delta_c)$\\
            $\Delta_c(\mathrm{id}_f)=T$ \\
          \end{tabular}
        }]
        {
          $\Delta,\Delta_c,\sigma,\mathcal{L}\vdash
          ~\mathrm{id}_f\Rightarrow\mathrm{e}~$
          $\xrightarrow{list_{ipm}}\mathcal{L}\cup{}\{id_f\}$
        }
      \end{prooftree}} \\
  \end{tabular}
\end{table}

\begin{premises}
  $v_i\in_c{}nat(n,m)$ checks that the index value stays in the
  array bounds.
\end{premises}

\begin{sideconds}
  $\mathrm{id}_f\notin\mathcal{L}$ and
  $(\mathrm{id}_f, v_i)\notin\mathcal{L}$ checks that neither the port
  identifier $id_f$ nor the couple port identifier $id_f$ and index
  $v_i$ are already mapped.
\end{sideconds}

\begin{figure}[H]
  {\fontsize{8}{11}\selectfont\textsc{ListIPMPartial}}
  \vspace{1em}

  \begin{prooftree}

    % Static expr e_i.
    \hypo{SE_l(\mathrm{e}_i)}

    % Evaluates e_i and e.
    \hypo{&\vdash\mathrm{e}_i\xrightarrow{e}v_i}
    \infer[no rule]1{\Delta,\sigma&\vdash\mathrm{e}\xrightarrow{e}v}
    
    % Evaluates e.
    \hypo{v_i&\in_c{}nat(n,m)}
    \infer[no rule]1{v&\in_c{}T}
    
    
    % Conclusion
    \infer[template={\inserttext}]
    3
    [{\renewcommand{\arraystretch}{1.5}
      \begin{tabular}{l}
        $\mathrm{id}_f\notin\mathcal{L}$, $(\mathrm{id}_f, v_i)\notin\mathcal{L}$ \\
        $\mathrm{id}_f\in{}Ins(\Delta_c)$ \\
        $\Delta_c(\mathrm{id}_f)=array(T,n,m)$ \\
      \end{tabular}
    }]
    {
      $\Delta,\Delta_c,\sigma,\mathcal{L}\vdash
      ~\mathrm{id}_f(\mathrm{e}_i)\Rightarrow\mathrm{e}~$
      $\xrightarrow{list_{ipm}}
      \mathcal{L}\cup\{~(id_f,v_i)~\}$
    }
  \end{prooftree}
\end{figure}

\begin{figure}[H]
  {\fontsize{8}{11}\selectfont\textsc{ListIPMCons}}
  \vspace{1em}

  \begin{prooftree}

    % Lists assoc.
    \hypo{\Delta,\Delta_c,\sigma,\mathcal{L}\vdash\mathrm{assoc}_{ip}\xrightarrow{list_{ipm}}\mathcal{L}'}

    % Lists lassoc.
    \hypo{\Delta,\Delta_c,\sigma,\mathcal{L}'\vdash\mathrm{ipmap}\xrightarrow{list_{ipm}}\mathcal{L}''}
    
    % Conclusion
    \infer[template={\inserttext}]
    2
    {
      $\Delta,\Delta_c,\sigma,\mathcal{L}\vdash
      ~\mathrm{assoc}_{ip}\mathtt{,}~\mathrm{ipmap}~$
      $\xrightarrow{list_{ipm}}\mathcal{L}''$
    }
  \end{prooftree}
\end{figure}

The $\mathtt{check}_{pm}(Ports,\mathcal{L})$ predicate states that all
port identifiers referenced in the domain of
$Ports\in{}id\nrightarrow{}type$ appear in $\mathcal{L}$ as a
simple identifier, or if the port identifier is of type array, then
all couples ($id$,$i$) must belong to $\mathcal{L}$, where $i$ denotes
all indexes of the array range and $id$, the port id.

\begin{equation*}
  \begin{split}
    \mathtt{check}_{pm}(Ports,\mathcal{L})\equiv
    \forall{}\mathrm{id}_f\in\mathtt{dom}(Ports),~\mathrm{id}_f\in\mathcal{L}~\lor~&
    (Ports(\mathrm{id}_f)=\mathtt{array}(T,n,m)\land\\
    & \forall{}i\in[n,m],~(\mathrm{id}_f,i)\in\mathcal{L}) \\
  \end{split}
\end{equation*}

\paragraph{Example of input port map validity checking}

We use the component instantiation statement of
Listing~\ref{lst:t-design-ci-abss} to illustrate the use of the
$valid_{ipm}$ predicate. The following rule demonstrates the validity
checking on the input port map of component instance $id_t$.

\begin{figure}[H]
  \centering
  {\begin{prooftree}

      % Lists formal parts.
      \hypo{\Delta,\Delta_c,\sigma,\mathcal{L}_\emptyset\vdash{\fontsize{9}{11}\selectfont
        \begin{tabular}{@{}l@{}}          
          (\texttt{time_A_value} $\Rightarrow{}0$, \\
          \texttt{time_B_value} $\Rightarrow{}0$, \\
          \texttt{input_conditions(0)} $\Rightarrow{}id_0$, \\
          \texttt{input_arcs_valid(0)} $\Rightarrow{}id_1$, \\
          \texttt{priority_authorizations(0)} $\Rightarrow\top$, \\
          \texttt{reinit_time(0)} $\Rightarrow{}id_2$) \\
        \end{tabular}}\xrightarrow{list_{ipm}}\mathcal{L}}

      % Well-formed port map.
      \hypo{\mathtt{check}_{pm}(Ins(\Delta_c),\mathcal{L})}
      
      % Conclusion
      \infer[template={\inserttext}]2
      {
        $\Delta,\Delta_c,\sigma\vdash\mathtt{valid}_{ipm}\Bigg($
        {\fontsize{9}{11}\selectfont
        \begin{tabular}{@{}l@{}}          
          (\texttt{time_A_value} $\Rightarrow{}0$, \\
          \texttt{time_B_value} $\Rightarrow{}0$, \\
          \texttt{input_conditions(0)} $\Rightarrow{}id_0$, \\
          \texttt{input_arcs_valid(0)} $\Rightarrow{}id_1$, \\
          \texttt{priority_authorizations(0)} $\Rightarrow\top$, \\
          \texttt{reinit_time(0)} $\Rightarrow{}id_2$) \\
        \end{tabular}}
        $\Bigg)$
      }
    \end{prooftree}}
\end{figure}

\noindent{}where:

\begin{itemize}
\item $Ins(\Delta_c):=$
\begin{tabular}{@{}l@{}}
$\{("time\_A\_value", nat(0,1)),$ \\
$("time\_B\_value", nat(0,1)),$ \\
$("input\_conditions", array(bool,0,0)),$ \\
$("input\_arcs\_valid", array(bool,0,0)),$ \\
$("priority\_authorizations", array(bool,0,0)),$ \\
$("reinit\_time", array(bool,0,0))\}$ \\
\end{tabular}

In $Ins(\Delta_c)$, the types of input ports are deduced from the
generic map of the transition component instance $id_t$.
\item $\mathcal{L}:=$
  \begin{tabular}{@{}l@{}}
  $\{"time\_A\_value",$ $"time\_B\_value",$ \\
  $("input\_conditions", 0),$ $("input\_arcs\_valid", 0),$ \\
  $("priority\_authorizations", 0),$ $("reinit\_time", 0)\}$ \\
  \end{tabular}
\end{itemize}

We add that the identifiers $id_0$, $id_1$ and $id_2$ are referenced
as internal signals of the Boolean type in the embedding elaborated
design $\Delta$, i.e:

\begin{itemize}
\item $Sigs(\Delta):=\{(id_0, bool),$ $(id_1,bool),$ $(id_2,bool)\}$
\end{itemize}

\paragraph{Valid output port map}

The $\mathtt{valid}_{opm}$ predicate states that an \emph{output} port
map is valid in the context $\Delta,\Delta_c$, where $\Delta$ is the
embedding design structure and $\Delta_c$ denotes the component
instance owner of the port map, if:

\begin{itemize}[label=-]
\item An output port identifier appears at most once in the output
  port map.
\item Two different output port identifiers cannot be connected to the
  same signal.
\item For each output port map entry, the formal and the actual part
  are of the exact same type (i.e, in the sense of the Leibniz
  equality).
\end{itemize}

We allow partially connected output port map; i.e, an output port map
where all output ports might not be present in the mapping. Such
output ports are \texttt{open} by default.

\begin{premises}
  $list_{opm}$ builds two sets
  $\mathcal{L},\mathcal{L}_{ids}\subseteq{}id\sqcup{}(id\times\mathbb{N})$
  out of the port map $\textrm{opmap}$. $\mathcal{L}_{ids}$ is
  built incrementally to check that there are no multiply-driven
  signals resulting of the port map connection.
\end{premises}

\begin{table}[H]
  \centering
  \begin{tabular}{l}
    {\fontsize{8}{11}\selectfont\textsc{ValidOPM}} \\
    {\begin{prooftree}

        % Lists formal parts.
        \hypo{
          \Delta,\Delta_c,\mathcal{L}_\emptyset,\mathcal{L}_{ids\emptyset}\vdash
          \mathrm{opmap}
          \xrightarrow{list_{opm}}
          \mathcal{L},\mathcal{L}_{ids}
        }
        
        % Conclusion
        \infer[template={\inserttext}]
        1
        {
          $\Delta,\Delta_c\vdash\mathtt{valid}_{opm}(\mathrm{opmap})$
        }
      \end{prooftree}} \\
  \end{tabular}
\end{table}

\begin{sideconds}
  \begin{itemize}[label=-]
  \item $\mathrm{id}_f\notin\mathcal{L}$ checks that the port
    identifier $\mathrm{id}_f$ is not already mapped (i.e, is not
    already used in the formal part of a port map entry).
  \item $\mathrm{id}_a\notin\mathcal{L}_{ids}$ checks that the signal
    identifier $\mathrm{id}_a$ is not already mapped (i.e, is not
    already used in the actual part of a port map entry).
  \item $\mathrm{id}_f\in{}Outs(\Delta_c)$ checks that $id_f$ is an
    output port identifier of $\Delta_c$.
  \item $\mathrm{id}_a\in{}Sigs(\Delta)\cup{}Outs(\Delta)$ checks that
    $\mathrm{id}_a$ is either an output port or an internal signal
    identifier of $\Delta$.
  \item $\Delta_c(\mathrm{id}_f)=\Delta(\mathrm{id}_a)=T$ checks that
    $\mathrm{id}_f$ and $\mathrm{id}_a$ are exactly of the same type.
  \end{itemize}
\end{sideconds}

\begin{table}[H]
  \begin{tabular}{@{}l}
    {\fontsize{8}{11}\selectfont\textsc{ListOPMSimpleToSimple}} \\
    {\begin{prooftree}
        
        % Conclusion
        \infer[template={\inserttext}]
        0
        [{\renewcommand{\arraystretch}{1.5}
          \begin{tabular}{@{}l}
            $\mathrm{id}_f\notin\mathcal{L}$, $\mathrm{id}_a\notin\mathcal{L}_{ids}$ \\
            $\mathrm{id}_f\in{}Outs(\Delta_c)$\\
            $\mathrm{id}_a\in{}Sigs(\Delta)\cup{}Outs(\Delta)$ \\
            $\Delta_c(\mathrm{id}_f)=\Delta(\mathrm{id}_a)=T$ \\
          \end{tabular}
        }] {
          $\Delta,\Delta_c,\mathcal{L},\mathcal{L}_{ids}\vdash$
          $\mathrm{id}_f\Rightarrow\mathrm{id}_a$
          $\xrightarrow{list_{opm}}$
          $\mathcal{L}\cup{}\{id_f\},\mathcal{L}_{ids}\cup{}\{id_a\}$ }
      \end{prooftree}} \\
  \end{tabular}
\end{table}

\begin{sideconds}
  $Outs_c(\mathrm{id}_f)=T$ and
  $Sigs(\mathrm{id}_a)=\mathtt{array(}T,n,m\mathtt{)}$ checks that the
  type of $\mathrm{id}_f$ and the type of the elements of
  $\mathrm{id}_a$ are the same. Note that $\mathrm{id_a}$ must denote
  an array as $\mathrm{id}_f$ is mapped to one subelement of
  $\mathrm{id}_a$.
\end{sideconds}

\begin{table}[H]
  \begin{tabular}{@{}l}
    {\fontsize{8}{11}\selectfont\textsc{ListOPMSimpleToPartial}} \\
    {\begin{prooftree}

        % Static expr e_i and natural.
        \hypo{SE_l(\mathrm{e}_i)}

        % Evaluates e_i.
        \hypo{\vdash\mathrm{e}_i\xrightarrow{e}v_i}

        % Well-typed v_i (in array bounds).
        \hypo{v_i\in_c{}nat(n,m)}
        
        % Conclusion
        \infer[template={\inserttext}]    
        3
        [{\renewcommand{\arraystretch}{1.5}
          \begin{tabular}{@{}l}
            $\mathrm{id}_f\notin\mathcal{L}$, $\mathrm{id}_a$, $(\mathrm{id}_a, v_i)\notin\mathcal{L}_{ids}$ \\
            $\mathrm{id}_f\in{}Outs(\Delta_c)$ \\
            $\mathrm{id}_a\in{}Sigs(\Delta)\cup{}Outs(\Delta)$ \\
            $\Delta_c(\mathrm{id}_f)=T$ \\
            $\Delta(\mathrm{id}_a)=array(T,n,m)$ \\
          \end{tabular}
        }]
        {
          $\Delta,\Delta_c,\mathcal{L},\mathcal{L}_{ids}\vdash
          ~\mathrm{id}_f\Rightarrow\mathrm{id}_a(\mathrm{e}_i)~$
          $\xrightarrow{list_{opm}}
          \mathcal{L}\cup{}\{id_f\},\mathcal{L}_{ids}\cup{}\{(id_a,v_i)\}$
        }
      \end{prooftree}} \\
  \end{tabular}
\end{table}

\begin{table}[H]
  \begin{tabular}{@{}l}
    {\fontsize{8}{11}\selectfont\textsc{ListOPMSimpleToOpen}} \\
    {\begin{prooftree}

        % Conclusion
        \infer[template={\inserttext}]
        0
        [{
          \begin{tabular}{l}
            $\mathrm{id}_f\notin\mathcal{L}$ \\
            $\mathrm{id}_f\in{}Outs(\Delta_c)$ \\
          \end{tabular}
        }]
        {
          $\Delta,\Delta_c,\mathcal{L},\mathcal{L}_{ids}\vdash
          ~\mathrm{id}_f\Rightarrow\mathtt{open}~$
          $\xrightarrow{list_{opm}}\mathcal{L}\cup{}\{id_f\},\mathcal{L}_{ids}$
        }
      \end{prooftree}} \\
  \end{tabular}
\end{table}


% \begin{table}[H]
%   \begin{tabular}{@{}l}
%     {\fontsize{8}{11}\selectfont\textsc{ListOPMPartialToOpen}} \\
%     {\begin{prooftree}

%         % Static expr e_i and natural.
%         \hypo{SE_l(\mathrm{e}_i)}

%         % Evaluates e_i.
%         \hypo{\vdash\mathrm{e}_i\xrightarrow{expr}v_i}

%         % Well-typed v_i (in array bounds).
%         \hypo{v_i\in_c{}nat(n,m)}
        
%         % Conclusion
%         \infer[template={\inserttext}]
%         3
%         [{
%           \begin{tabular}{l}
%             $\mathrm{id}_f,(\mathrm{id}_f,v_i)\notin\mathcal{L}$ \\
%             $\mathrm{id}_f\in{}Outs(\Delta_c)$ \\
%             $\Delta_c(\mathrm{id}_f)=\mathtt{array(}T,n,m\mathtt{)}$ \\
%           \end{tabular}
%         }]
%         {
%           $\Delta,\Delta_c,\mathcal{L},\mathcal{L}_{ids}\vdash$
%           $\mathrm{id}_f(e_i)\Rightarrow\mathtt{open}$
%           $\xrightarrow{list_{opm}}$
%           $\mathcal{L}\cup{}\{id_f\},\mathcal{L}_{ids}$
%         }
%       \end{prooftree}} \\
%   \end{tabular}
% \end{table}

\begin{remark}[Unconnected output port.]
  We forbid the case where an indexed formal part corresponding to the
  subelement of a composite output port is unconnected, i.e
  $\mathrm{id}_f(e_i)\Rightarrow\mathtt{open}$, as it could lead to
  the case where some subelements of a composite output port are
  connected while others are not (error case in \cite[p.7]{VHDL2000}).
\end{remark}

\begin{table}[H]
  \begin{tabular}{@{}l}
    {\fontsize{8}{11}\selectfont\textsc{ListOPMPartialToSimple}} \\
    {\begin{prooftree}

        % Static expr e_i and natural.
        \hypo{SE_l(\mathrm{e}_i)}

        % Evaluates e_i.
        \hypo{\vdash\mathrm{e}_i\xrightarrow{e}v_i}

        % Well-typed v_i (in array bounds).
        \hypo{v_i\in_c{}nat(n,m)}
        
        % Conclusion
        \infer[template={\inserttext}]
        3
        [{\renewcommand{\arraystretch}{1.5}
          \begin{tabular}{l}
            $\mathrm{id}_f,(\mathrm{id}_f,v_i)\notin\mathcal{L}$, $\mathrm{id}_a\notin\mathcal{L}_{ids}$ \\
            $\mathrm{id}_f\in{}Outs(\Delta_c)$ \\
            $\mathrm{id}_a\in{}Sigs(\Delta)\cup{}Outs(\Delta)$ \\
            $\Delta_c(\mathrm{id}_f)=array(T,n,m)$ \\
            $\Delta(\mathrm{id}_a)=T$ \\
          \end{tabular}
        }]
        {
          $\Delta,\Delta_c,\mathcal{L},\mathcal{L}_{ids}\vdash$
          $\mathrm{id}_f(\mathrm{e}_i)\Rightarrow\mathrm{id}_a$
          $\xrightarrow{list_{opm}}$
          $\mathcal{L}\cup\{(id_f,v_i)\},\mathcal{L}_{ids}\cup\{id_a\}$
        }
      \end{prooftree}} \\
  \end{tabular}
\end{table}

\begin{table}[H]
  \begin{tabular}{@{}l}
    {\fontsize{8}{11}\selectfont\textsc{ListOPMPartialToPartial}} \\
    {\begin{prooftree}

        % Static expr. ei e'i.
        
        \hypo{&SE_l(\mathrm{e'}_i)}
        \infer[no rule]1{&SE_l(\mathrm{e}_i)}

        % Evaluates e_i.
        \hypo{&\vdash\mathrm{e'}_i\xrightarrow{e}v'_i}
        \infer[no rule]1{&\vdash\mathrm{e}_i\xrightarrow{e}v_i}

        % Well-typed v'_i and v_i.
        \hypo{v'_i&\in_c{}nat(n',m')}
        \infer[no rule]1{v_i&\in_c{}nat(n,m)}
        
        % Conclusion
        \infer[template={\inserttext}]
        3
        [{\renewcommand{\arraystretch}{1.5}
          \begin{tabular}{l}
            $\mathrm{id}_f,(\mathrm{id}_f,v_i)\notin\mathcal{L}$, $\mathrm{id}_a,(\mathrm{id}_a,v'_i)\notin\mathcal{L}_{ids}$ \\
            $\mathrm{id}_f\in{}Outs(\Delta_c)$ \\
            $\mathrm{id}_a\in{}Sigs(\Delta)\cup{}Outs(\Delta)$ \\
            $\Delta_c(\mathrm{id}_f)=array(T,n,m)$ \\
            $\Delta(\mathrm{id}_a)=array(T,n',m')$ \\ 
          \end{tabular}
        }]
        {
          $\Delta,\Delta_c,\mathcal{L},\mathcal{L}_{ids}\vdash$
          $\mathrm{id}_f(\mathrm{e}_i)\Rightarrow\mathrm{id}_a(\mathrm{e'}_i)$
          $\xrightarrow{list_{opm}}$
          \begin{tabular}{@{}l@{}}
            $\mathcal{L}\cup\{(id_f,v_i)\},$ \\
            $\mathcal{L}_{ids}\cup\{(id_a,v'_i)\}$\\
          \end{tabular}
        }
      \end{prooftree}} \\
  \end{tabular}
\end{table}

\begin{table}[H]
  \begin{tabular}{@{}l}
    {\fontsize{8}{11}\selectfont\textsc{ListOPMCons}} \\
    {\begin{prooftree}

        % Lists assoc.
        \hypo{
          \Delta,\Delta_c,\mathcal{L},\mathcal{L}_{ids}\vdash
          \mathrm{assoc}_{po}
          \xrightarrow{list_{opm}}
          \mathcal{L}',\mathcal{L}'_{ids}
        }

        % Lists lassoc.
        \hypo{
          \Delta,\Delta_c,\mathcal{L}',\mathcal{L}'_{ids}\vdash
          \mathrm{opmap}
          \xrightarrow{list_{opm}}
          \mathcal{L}'',\mathcal{L}''_{ids}
        }
        
        % Conclusion
        \infer[template={\inserttext}]
        2
        {
          $\Delta,\Delta_c,\mathcal{L},\mathcal{L}_{ids}\vdash
          ~\mathrm{assoc}_{po}\mathtt{,}~\mathrm{opmap}~$
          $\xrightarrow{list_{opm}}$
          $\mathcal{L}'',\mathcal{L}''_{ids}$
        }
      \end{prooftree}} \\
  \end{tabular}
\end{table}

\paragraph{Example of output port map validity checking}

To illustrate the validity checking of an output port map as performed
by the $valid_{opm}$ predicate, we introduce in
Listing~\ref{lst:p-design-ci-abss} the instantiation in \hvhdl{}
abstract syntax of a place component $id_p$ in the behavior of an
embedding design.

\begin{lstlisting}[language=VHDL,label={lst:p-design-ci-abss},
caption={[A component instantiation statement in \hvhdl{} abstract syntax (place component instance).] An example of instantiation of the place design in \hvhdl{} abstract syntax. The place component instance is named $id_p$.},framexleftmargin=1.5em,xleftmargin=2em,numbers=left,
numberstyle=\tiny\ttfamily]
  comp ($id_p$, "place", 
    -- Generic map
    (input_arcs_number => 1,
     output_arcs_number => 1,
     maximal_marking => 1),
    -- Input port map
    (initial_marking => 1,
     input_arcs_weights(0) => 1,
     output_arcs_types(0) => 0,
     output_arcs_weights(1) => 1,
     input_transitions_fired(0) => $id_0$, 
     output_transitions_fired(0) => $id_1$),
    -- Output port map
    (output_arcs_valid(0) => $id_2$,
     priority_authorizations(0) => $id_3$,
     reinit_transitions_time(0) => $id_4$,
     marked => $id_5$);
\end{lstlisting}

The following rule describes the validity checking of the output port
map of component $id_p$.

\begin{figure}[H]
  \centering
  {\begin{prooftree}

      % Lists formal parts.
      \hypo{
        \Delta,\Delta_c,\emptyset,\emptyset\vdash
        {\fontsize{9}{11}\selectfont
          \begin{tabular}{@{}l@{}}
            \texttt{output_arcs_valid(0)} $\Rightarrow{}id_2$, \\
            \texttt{priority_authorizations(0)} $\Rightarrow{}id_3$, \\
            \texttt{reinit_transitions_time(0)} $\Rightarrow{}id_4$, \\
            \texttt{marked} $\Rightarrow{}id_5$ \\
          \end{tabular}}
        \xrightarrow{list_{opm}}
        {\fontsize{9}{11}\selectfont
          \begin{tabular}{@{}l}
            $\{("output\_arcs\_valid", 0),$ \\
            $("priority\_authorizations", 0)$ \\
            $("reinit\_transitions\_time", 0),$ \\
            $"marked"\}$ \\
          \end{tabular}},
        \{id_2,id_3,id_4,id_5\}
      }
      
      % Conclusion
      \infer[template={\inserttext}]
      1
      {
        $\Delta,\Delta_c\vdash\mathtt{valid}_{opm}\Bigg(${\fontsize{9}{11}\selectfont
          \begin{tabular}{@{}l@{}}
            \texttt{output_arcs_valid(0)} $\Rightarrow{}id_2$, \\
            \texttt{priority_authorizations(0)} $\Rightarrow{}id_3$, \\
            \texttt{reinit_transitions_time(0)} $\Rightarrow{}id_4$, \\
            \texttt{marked} $\Rightarrow{}id_5$ \\
          \end{tabular}}$\Bigg)$
      }
    \end{prooftree}}
\end{figure}

\subsection{Valid sequential statements}
\label{subsubsec:valid-ss}

The $\mathtt{valid}_{ss}$ predicate states that a sequential statement
is well-typed in the context $\Delta,\sigma,\Lambda$.

\subsubsection{Well-typed signal assignment}

% Well-typed signal assignment.

\begin{premises}
  \begin{itemize}
  \item $\Delta,\sigma,\Lambda\vdash{}e\xrightarrow{e}v$ evaluates the
    expression assigned to signal $\mathrm{id}_s$ in the context
    $\Delta,\sigma,\Lambda$. During the elaboration, $\sigma$
    corresponds to the default design state, i.e. where each signal is
    associated to its type default value.
  \item $v\in_c{}T$ checks that the value of expression $e$ conforms
    to the type of signal $\mathrm{id}_s$.
  \end{itemize}
\end{premises}

\begin{table}[H]
  \begin{tabular}{@{}l}
    {\fontsize{8}{11}\selectfont\textsc{WellTypedSigAssign}} \\
    {\begin{prooftree}

        % Evaluates e.
        \hypo{\Delta,\sigma,\Lambda\vdash{}e\xrightarrow{e}v}
        
        % Well-typed v.
        \hypo{v\in_c{}T}
        
        % Conclusion
        \infer[template={\inserttext}]2
        [{
          \renewcommand{\arraystretch}{1.5}
          \begin{tabular}{@{}l}
            $\mathrm{id}_s\in{}Sigs(\Delta)\cup{}Outs(\Delta)$\\
            $\Delta(\mathrm{id}_s)=T$\\
          \end{tabular}
        }]
        {
          $\Delta,\sigma,\Lambda\vdash\mathtt{valid}_{ss}(\mathrm{id}_s\Leftarrow\mathrm{e})$
        }
      \end{prooftree}} \\
  \end{tabular}
\end{table}

% Well-typed indexed signal assignment.
\begin{table}[H]
  \begin{tabular}{l}
    {\fontsize{8}{11}\selectfont\textsc{WellTypedIdxSigAssign}} \\
    {\begin{prooftree}

        % Evaluates e and e_i.
        \hypo{\Delta,\sigma,\Lambda&\vdash{}e\xrightarrow{e}v}
        \infer[no rule]1{\Delta,\sigma,\Lambda&\vdash{}e_i\xrightarrow{e}v_i}
        
        % Well-typed v and v_i.
        \hypo{v&\in_c{}T}
        \infer[no rule]1{v_i&\in_c{}nat(n,m)}
        
        % Conclusion
        \infer[template={\inserttext}]2
        [{
          \renewcommand{\arraystretch}{1.5}
          \begin{tabular}{@{}l}
            $\mathrm{id}_s\in{}Sigs(\Delta)\cup{}Outs(\Delta)$ \\
            $\Delta(\mathrm{id}_s)=array(T,n,m)$ \\
          \end{tabular}
        }]
        {
          $\Delta,\sigma,\Lambda\vdash\mathtt{valid}_{ss}(\mathrm{id}_s(\mathrm{e}_i)\Leftarrow\mathrm{e})$
        }
      \end{prooftree}} \\
  \end{tabular}
\end{table}

\subsubsection{Well-typed variable assignment}

\begin{table}[H]
  \begin{tabular}{@{}l}
    {\fontsize{8}{11}\selectfont\textsc{WellTypedVarAssign}} \\
    {\begin{prooftree}
        
        % Evaluates e.
        \hypo{\Delta,\sigma,\Lambda\vdash\mathrm{e}\xrightarrow{e}v}

        % Well-typed v.
        \hypo{v\in_c{}T}
        
        % Conclusion
        \infer[template={\inserttext}]2
        [{
          \renewcommand{\arraystretch}{1.5}
          \begin{tabular}{@{}l}
            $\mathrm{id}_v\in\Lambda$\\
            $\Lambda(\mathrm{id}_v)=(T,val)$\\
          \end{tabular}
        }]
        {
          $\Delta,\sigma,\Lambda\vdash\mathtt{valid}_{ss}(\mathrm{id}_v := \mathrm{e})$
        }
      \end{prooftree}} \\
  \end{tabular}
\end{table}

\begin{table}[H]    
  \begin{tabular}{@{}l}
    {\fontsize{8}{11}\selectfont\textsc{WellTypedIdxVarAssign}} \\
    {\begin{prooftree}

        % Evaluates e and e_i.
        \hypo{\Delta,\sigma,\Lambda&\vdash{}e\xrightarrow{e}v}
        \infer[no rule]1{\Delta,\sigma,\Lambda&\vdash{}e_i\xrightarrow{e}v_i}
        
        % Well-typed v and v_i.
        \hypo{v&\in_c{}T}
        \infer[no rule]1{v_i&\in_c{}nat(n,m)}
        
        % Conclusion
        \infer[template={\inserttext}]2
        [{
          \renewcommand{\arraystretch}{1.5}
          \begin{tabular}{@{}l}
            $\mathrm{id}_v\in{}\Lambda$ \\
            $\Lambda(\mathrm{id}_v)=(array(T,n,m),val)$ \\
          \end{tabular}
        }]
        {
          $\Delta,\Lambda\vdash\mathtt{valid}_{ss}(\mathrm{id}_v(\mathrm{e}_i) := \mathrm{e})$
        }
      \end{prooftree}} \\
  \end{tabular}
\end{table}%

\subsubsection{Well-typed if statements}

\begin{table}[H]
  \begin{tabular}{@{}l}
    {\fontsize{8}{11}\selectfont\textsc{WellTypedIf}} \\
    {\begin{prooftree}

        % Eval e.
        \hypo{\Delta,\sigma,\Lambda\vdash\mathrm{e}\xrightarrow{e}v}
        
        % Well-typed v.
        \hypo{v\in_c\mathtt{bool}}

        % Validss ss.
        \hypo{\Delta,\sigma,\Lambda\vdash\mathtt{valid}_{ss}(\mathrm{ss})}
        
        % Conclusion
        \infer[template={\inserttext}]3
        {
          $\Delta,\sigma,\Lambda\vdash\mathtt{valid}_{ss}($\vhdle|if| \texttt{(}e\texttt{)} ss$)$
        }
      \end{prooftree}} \\
  \end{tabular}
\end{table}%

\begin{table}[H]
  \begin{tabular}{@{}l}
    {\fontsize{8}{11}\selectfont\textsc{WellTypedIfElse}} \\
    {\begin{prooftree}

        % Eval e.
        \hypo{\Delta,\sigma,\Lambda\vdash\mathrm{e}\xrightarrow{e}v}
        
        % Well-typed v.
        \hypo{v\in_c\mathtt{bool}}

        % Validss ss and ss'.
        \hypo{\Delta,\sigma,\Lambda\vdash\mathtt{valid}_{ss}(\mathrm{ss})}
        \infer[no rule]1{\Delta,\sigma,\Lambda\vdash\mathtt{valid}_{ss}(\mathrm{ss}')}
        
        % Conclusion
        \infer[template={\inserttext}]3
        {
          $\Delta,\sigma,\Lambda\vdash\mathtt{valid}_{ss}($\vhdle|if| \texttt{(}e\texttt{)} ss ss'$)$
        }
      \end{prooftree}} \\
  \end{tabular}
\end{table}%

\subsubsection{Well-typed loop statement}

\begin{table}[H]
  \begin{tabular}{@{}l}
    {\fontsize{8}{11}\selectfont\textsc{WellTypedLoop}} \\
    {\begin{prooftree}

        % Eval e and e'.
        \hypo{\Delta,\sigma,\Lambda&\vdash\mathrm{e}\xrightarrow{e}v}
        \infer[no rule]1{\Delta,\sigma,\Lambda&\vdash\mathrm{e'}\xrightarrow{e}v'}

        % Well-typed v and v'.
        \hypo{v&\in_c{}{}nat(0,\mathtt{NATMAX})}
        \infer[no rule]1{v'&\in_c{}{}nat(0,\mathtt{NATMAX})}
        
        % Well-typed ss.
        \hypo{\Delta,\sigma,\Lambda'\vdash\mathtt{valid}_{ss}(\mathrm{ss})}
        
        % Conclusion
        \infer[template={\inserttext}]3
        [$\Lambda'=\Lambda\cup(\mathrm{id}_v,({}nat(v,v'), v))$]
        {
          $\Delta,\sigma,\Lambda\vdash\mathtt{valid}_{ss}($\vhdle|for| (id$_v$, e, e') ss$)$
        }
      \end{prooftree}} \\
  \end{tabular}
\end{table}%

\subsubsection{Well-typed rising and falling edge blocks}

\begin{table}[H]
  \begin{tabular}{@{}l}
    {\fontsize{8}{11}\selectfont\textsc{WellTypedRising}} \\
    {\begin{prooftree}
        
        % Well-typed ss.
        \hypo{\Delta,\sigma,\Lambda\vdash\mathtt{valid}_{ss}(\mathrm{ss})}
        
        % Conclusion
        \infer[template={\inserttext}]1
        {
          $\Delta,\sigma,\Lambda\vdash\mathtt{valid}_{ss}($\vhdle|rising| ss$)$
        }
      \end{prooftree}} \\
  \end{tabular}
  \begin{tabular}{@{}l}
    {\fontsize{8}{11}\selectfont\textsc{WellTypedFalling}} \\
    {\begin{prooftree}
        
        % Well-typed ss.
        \hypo{\Delta,\sigma,\Lambda\vdash\mathtt{valid}_{ss}(\mathrm{ss})}
        
        % Conclusion
        \infer[template={\inserttext}]1
        {
          $\Delta,\sigma,\Lambda\vdash\mathtt{valid}_{ss}($\vhdle|falling| ss$)$
        }
      \end{prooftree}} \\
  \end{tabular}
\end{table}%

\subsubsection{Well-typed rst blocks}

\begin{table}[H]
  \begin{tabular}{@{}l}
    {\fontsize{8}{11}\selectfont\textsc{WellTypedRst}} \\
    {\begin{prooftree}
        
        % Well-typed ss.
        \hypo{\Delta,\sigma,\Lambda\vdash\mathtt{valid}_{ss}(\mathrm{ss})}

        % Well-typed ss'.
        \hypo{\Delta,\sigma,\Lambda\vdash\mathtt{valid}_{ss}(\mathrm{ss'})}
        
        % Conclusion
        \infer[template={\inserttext}]2
        {
          $\Delta,\sigma,\Lambda\vdash\mathtt{valid}_{ss}($\vhdle|rst| ss ss'$)$
        }
      \end{prooftree}} \\
  \end{tabular}
\end{table}%

\subsubsection{Well-typed null statement}
\label{sec:wt-null}

\begin{table}[H]
  \begin{tabular}{@{}l}
    {\fontsize{8}{11}\selectfont\textsc{WellTypedNull}} \\
    {\begin{prooftree}
                
        % Conclusion
        \infer[template={\inserttext}]0
        {
          $\Delta,\sigma,\Lambda\vdash\mathtt{valid}_{ss}($\vhdle|null|$)$
        }
      \end{prooftree}} \\
  \end{tabular}
\end{table}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../main"
%%% End:
