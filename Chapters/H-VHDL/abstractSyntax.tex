In this section, we describe the abstract syntax of \hvhdl{}, a subset
of VHDL covering all the constructs present in the programs generated
by the \hilecop{} transformation. Terminals of the language are
written in \texttt{typewriter} font, or are enclosed in simple quotes
for symbols with no typewriter representation. The $a^{*}$ denotes a
possibly empty repetition of the element $a$; the $a^{+}$ denotes a
non-empty repetition of $a$.

\subsection{Design declaration}
\label{subsec:design-decl}

Similarly to \cite{VanTassel1995}, we define the \emph{design}
construct in the $\mathcal{H}$-VHDL's abstract syntax which has no
equivalent in the concrete syntax of VHDL.

\begin{table*}[!h]
  \begin{tabular}{lcl}
    design & ::= & \texttt{design} id$_e$ id$_a$ gens ports sigs cs \\
    gens & ::= & gdecl* \\
    ports & ::= & pdecl* \\
    sigs & ::= & sdecl* \\
  \end{tabular}
\end{table*}

% \subsection{Generic constant, port and internal signal declaration.}
% \label{subsec:ent-decl}
\begin{table*}[!h]
\begin{tabular}{lcl}
  gdecl & ::= & \texttt{(}id\texttt{,} $\tau$\texttt{,} e\texttt{)} \\
  pdecl & ::= & \texttt{(}(\vhdle|in||\vhdle|out|)\texttt{,} id\texttt{,} $\tau$\texttt{)}\\
  sdecl & ::= & \texttt{(}id, $\tau$\texttt{)} \\
\end{tabular}
\end{table*}

In the above entry, $\mathrm{id}_e$ indicates the entity identifier
and $\mathrm{id}_a$ the architecture identifier of the declared
design. The $\mathrm{gens}$ entry corresponds to the generic clause,
i.e. the declaration list for the generic constants of the design. A
generic constant is declared via the \textrm{gdecl} entry; a generic
constant declaration is a triplet composed of an identifier, a type
indication and an expression denoting the generic constant's default
value. The ports entry holds the declaration of the input and output
ports of the design. A port declaration (i.e. the pdecl entry) is a
triplet composed of a port type, i.e. \texttt{in} or \texttt{out}, an
identifier, and a type indication. The sigs entry is the list
declaring the internal signals of the design. An internal signal
declaration entry (i.e. sdecl) is a couple composed of an identifier
and a type indication. The cs entry represents the concurrent
statements composing the behavior of the design.

\subsection{Concurrent statements}
\label{subsec:conc-stmt}

\begin{table*}[!h]
\begin{tabular}{lcl}
  cs & ::= & psstmt | cistmt | cs \texttt{||} cs | \texttt{null} \\
\end{tabular}
\end{table*}
In \hvhdl{}, two kinds of concurrent statements are available to
describe the behavior of a design: process statements, represented by
the psstmt entry, and component instantiation statements, represented
by the cistmt entry. Concurrent statements are composable through the
\texttt{||} operator. We add the \texttt{null} statement to the
\hvhdl{} abstract syntax to help represent empty behaviors.

\subsubsection{Process statement}

\begin{table*}[!h]
\begin{tabular}{lcl}
  psstmt & ::= & \vhdle|process| \texttt{(}id$_p$\texttt{,} sl\texttt{,} vars\texttt{,}  ss\texttt{)} \\
  sl & ::= & id$^{*}$ \\
  vars & ::= & vdecl* \\
  vdecl & ::= & \texttt{(}id\texttt{,} $\tau$\texttt{)} \\
\end{tabular}
\end{table*}

A process statement declares a sensitivity list, i.e. the sl entry,
which is a possibly empty set of signal identifiers. In order to be
well-formed, the signals of a sensitivity list must be either internal
signals or input ports of the design, i.e. . The process possibly declares a
set internal variables, i.e. the vars entry. A variable declaration
entry is a couple composed of a variable identifier and a type
indication. The ss entry represents the sequence of statements
composing the body of the process, i.e. the part that will be executed
during the simulation.

\subsubsection{Component instantiation statement}

The VHDL LRM defines two kinds of component instantiation statement:
the instantiation of a component instance \cite[p.139]{VHDL2000} and
the instantiation of a design entity \cite[p.141]{VHDL2000}. The
component instantiation statement used in the \hvhdl{} abstract syntax
corresponds to the instantiation of a design entity.

\begin{table*}[!h]
\begin{tabular}{lcl}
  cistmt & ::= & \vhdle|comp| \texttt{(}id$_c$\texttt{,} id$_e$\texttt{,} gmap\texttt{,} ipmap\texttt{,} opmap\texttt{)} \\
  gmap & ::= & assoc$_g^{*}$ \\
  ipmap & ::= & assoc$_{ip}^{*}$ \\
  opmap & ::= & assoc$_{op}^{*}$\\
  assoc$_g$ & ::= & \texttt{(}id\texttt{,}e\texttt{)} \\
  assoc$_{ip}$ & ::= & \texttt{(}name\texttt{,}e\texttt{)} \\
  assoc$_{op}$ & ::= & \texttt{(}id\texttt{,}(name|\vhdle|open|)\texttt{)}|\texttt{(}id\texttt{(}e\texttt{)}\texttt{,}name\texttt{)}\\
\end{tabular}
\end{table*}

In the cistmt entry, the identifier $\mathrm{id}_c$ represents the
name of component instance. Identifier $\mathrm{id}_e$ points out the
name of the design, i.e. the entity identifier, being instantiated
here. The gmap entry describes the list of associations between
generic constant identifiers and expressions. The ipmap entry is the
list of associations between input port identifiers (or indexed
identifiers) and expressions. The opmap entry is the list of
associations between output port identifiers (or indexed identifiers)
and signal names, or the \texttt{open} keyword. Associating the
\texttt{open} keyword with an output port identifier indicates that
the port is not connected. The left element of an association is
called the \emph{formal} part, and the right element of an association
is called the \emph{actual} part.

\subsection{Sequential statements}

\begin{table*}[!h]
\begin{tabular}{lcl}
  ss & ::= & name $\mathtt{\Leftarrow}$ e | name \texttt{:=} e | \texttt{if} \texttt{(}e\texttt{)} ss [ss] | \texttt{for (}id\texttt{,}e\texttt{,}e\texttt{)} ss \\
     & &  | \texttt{falling} ss | \texttt{rising} ss | \texttt{rst} ss ss' | ss\texttt{;} ss | \texttt{null} \\
\end{tabular}
\end{table*}

The ss entry defines the sequential statements that compose the body
of processes. The signal assignment statement is represented with the
$\Leftarrow$ operator; the variable assignment statement with the
$\mathtt{:=}$ operator. Also, we devise three control flow statements
that have no equivalent in the VHDL syntax: the \texttt{falling} block
statement, the \texttt{rising} block statement and the \texttt{rst}
block (or reset) block statement.  The \texttt{falling} statement
(resp. \texttt{rising} ss) declares a block of sequential statements
to be executed only at the falling edge (resp. rising edge) of the
clock signal (see Section~\ref{sec:clk-phases-rules}). Also, the
\texttt{rst} statement declares two blocks, the first one must be
executed during the initialization phase of the simulation; otherwise,
the second one is executed (see Section~\ref{sec:init-rules}).  These
invented constructs are equivalent to specific if-else statements that
are commonly used in the body of a synchronous process (see
Section~\ref{sec:abs-syntax-examples} for an example of transcription
of a specific if-else statement into one of these constructs).

\subsection{Expressions, names and types}
\label{sec:expr-names}

\begin{table}[H]
  \begin{tabular}{lcl}

    e & ::= & e \texttt{and} e | e \texttt{or} e | \texttt{not} e | e \texttt{=} e | e $\neq$ e \\
      & & | e \texttt{<} e | e \texttt{<=} e | e \texttt{>} e | e \texttt{>=} e | e \texttt{+} e | e \texttt{-} e \\
      & & | name | natural | boolean | \texttt{(}e$^{+}$\texttt{)} \\
      & & \\
    name & ::= & id | id\texttt{(} e \texttt{)} \\
    boolean & ::= & \texttt{true} | \texttt{false} \\
    $\tau$ & ::= & \texttt{boolean} | \texttt{natural} \texttt{(}e\texttt{,} e\texttt{)} |
                   \texttt{array} \texttt{(}$\tau$\texttt{,} e\texttt{,} e\texttt{)} \\
  \end{tabular}
\end{table}

The expression entry, i.e. e, declares a set of operators over Boolean
expressions, and natural numbers expressions.  The natural
non-terminal represents the set of natural numbers ($\mathbb{N}$). The
id non-terminal represents the set of identifiers, comparable to the
set of strings, or any infinitly enumerable set. In the following
sections, concrete identifiers will be written in \texttt{typewriter}
font, e.g. the \texttt{place} and \texttt{transition} design
identifiers.

The $\tau$ entry corresponds to the type indication associated with
the declaration of a generic constant, a port or an internal
signal. The considered types are the \emph{Boolean} type, the
constrained natural type, and the array type. The constrained natural
type, i.e. \texttt{natural}(e,e), defines a finite interval of natural
numbers; the left-most expression of the range constraint denotes the
lower bound of the interval, and the second one denotes the upper
bound of the interval. The array type indication,
i.e. \texttt{array}($\tau$, e, e), denotes a non-empty set of elements
of type $\tau$. The elements are indexed with respect to the specified
\emph{index} constraint. The left-most expression of the index
constraint denotes the starting index (possibly different from 0) and
the right-most expression denotes the final index.

% \subsection{Examples of \hvhdl{} abstract syntax}
% \label{sec:abs-syntax-examples}

% Listing~\ref{lst:t-design-decl-part-abss} gives the translation in
% abstract \hvhdl{} syntax of the declarative part of the transition
% design presented in Listings~\ref{lst:trans-design-entity} and
% \ref{lst:trans-design-arch} in concrete VHDL syntax.

% \begin{lstlisting}[language=VHDL,label={lst:t-design-decl-part-abss},
% caption={[The transition design's declarative parts in abstract
%   \hvhdl{} syntax.]The transition design's declarative parts in
%   abstract \hvhdl{}
%   syntax.},framexleftmargin=1.5em,xleftmargin=2em,numbers=left,
% numberstyle=\tiny\ttfamily]
% design "transition" "transition_architecture"
%   -- Generic clause
%   (("transition_type", natural(0, 2), 0), 
%    ("input_arcs_number", natural(0, NATMAX), 1), 
%    ("conditions_number", natural(0, NATMAX), 1),
%    ("maximal_time_counter", natural(0, NATMAX), 1))

%   -- Port clause
%   ((in, "input_conditions", array(boolean, 0, conditions_number$-$1)),
%    (in, "time_A_value", natural(0, maximal_time_counter)),
%    (in, "time_B_value", natural(0, maximal_time_counter)),
%    (in, "input_arcs_valid", array(boolean, 0, input_arcs_number$-$1)),
%    (in, "reinit_time", array(boolean, 0, input_arcs_number$-$1)),
%    (in, "priority_authorizations", array(boolean, 0, input_arcs_number$-$1)),
%    (out, "fired", boolean))

%   -- Internal signals
%   (("s_condition_combination", boolean),
%    ("s_enabled", boolean),
%    #\dots#
%    ("s_time_counter", natural(0, maximal_time_counter)))

%   -- Concurrent statements
%   cs
% \end{lstlisting}

% In Listing~\ref{lst:t-design-decl-part-abss}, the type indication of
% the ``\texttt{transition\_type}'' generic constant has been
% transformed from the \texttt{temporal_t} enumeration type to the
% \texttt{natural(0,2)} type. The \texttt{temporal_t} enumeration type,
% defined through the three values \texttt{\{NOT\_TEMPORAL,
%   TEMPORAL\_A\_A, TEMPORAL\_A\_B\}}, is naturally transformed into a
% natural range. This transformation is only valid because the
% \texttt{temporal_t} type is only defined and used in the transition
% design which has a static behavior. Also, the \texttt{std_logic} type
% defined in the VHDL Std Logic 1164 library \cite{STDLOGIC} is
% transformed into the Boolean type, and the \texttt{std_logic_vector}
% is transformed into the array of Booleans type. This transformation is
% valid because, in the transition and place designs and also in the
% generated designs, we are only referring to the values '0' and '1'
% among all the values enumerated by the \texttt{std_logic} type (see
% \cite[p. 2]{STDLOGIC}). Also, note that the \texttt{clock} and
% \texttt{reset_n} input ports declared in the port clause of the
% transition design are removed in the hvhdl{} version. In the \hvhdl{}
% abstract syntax, the if statements that were testing the value of the
% \texttt{clock} and the \texttt{reset_n} signals have been turned into
% specific sequential statements (i.e \texttt{rst}, \texttt{falling} and
% \texttt{rising} blocks). Thus, we don't need the \texttt{clock} and
% \texttt{reset_n} signals in the port declaration list anymore.

% Listing~\ref{lst:t-design-pss-abss} presents the translation in
% \hvhdl{} abstract syntax of the two of the processes presented in
% Listing~\ref{lst:trans-design-arch}.

% \begin{lstlisting}[language=VHDL,label={lst:t-design-pss-abss},
% caption={[Two processes in \hvhdl{} abstract syntax.]The \texttt{condition_evaluation} and \texttt{firable} processes in \hvhdl{} abstract syntax. The two processes are defined in the behavior of the transition design.},framexleftmargin=1.5em,xleftmargin=2em,numbers=left,
% numberstyle=\tiny\ttfamily]
%   process ("condition_evaluation", ("input_conditions"), 
%           (("v_internal_condition", boolean)),
%     v_internal_condition := true;
%     (for ("i", 0, conditions_number $-$ 1) 
%       (v_internal_condition := v_internal_conditions and input_conditions(i)));
%     s_condition_combination <= v_internal_condition
%   ) ||
%   process ("firable", ("clk"), $\emptyset$,
%     rst (s_firable <= false)
%         (falling (s_firable <= s_firing_condition))
%   )
% \end{lstlisting}

% In Listing~\ref{lst:t-design-pss-abss}, inner blocks of sequential
% statements are enclosed between parentheses to ease the reading,
% albeit parentheses are not part of the \hvhdl{} syntax. The body of
% the \texttt{firable} process gives an example of the use of a
% \texttt{rst} block and a \texttt{falling} block. One can see, from the
% comparison of Listing~\ref{lst:trans-design-arch} and
% \ref{lst:t-design-pss-abss}, that a \texttt{rst} ss ss' statement is
% the translation of the concrete VHDL statement \texttt{if reset_n =
%   '0' then ss else ss' endif;}. Comparing the same listings, a
% \texttt{falling} ss statement is the translation of the concrete VHDL
% statement \texttt{if falling_edge(clock) then ss end if;}.

% Listing~\ref{lst:t-design-ci-abss} shows the translation in \hvhdl{}
% abstract syntax of the component instantiation statement laid out in
% Listing~\ref{lst:trans-design-instantiation}.

% \begin{lstlisting}[language=VHDL,label={lst:t-design-ci-abss},
% caption={[A component instantiation statement in \hvhdl{} abstract
%   syntax (transition component instance).] An example of instantiation
%   of the transition design in \hvhdl{} abstract syntax. The transition
%   component instance is named
%   $id_t$.},framexleftmargin=1.5em,xleftmargin=2em,numbers=left,
% numberstyle=\tiny\ttfamily]
%   comp ($id_t$, "transition", 
%     -- Generic map
%     (transition_type => 0,
%      input_arcs_number => 1,
%      conditions_number => 1,
%      maximal_time_counter => 1),
%     -- Input port map
%     (time_A_value => 0,
%      time_B_value => 0,
%      input_conditions(0) => $id_0$,
%      input_arcs_valid(0) => $id_1$,
%      priority_authorizations(0) => true,
%      reinit_time(0) => $id_2$),
%     -- Output port map
%     (fired => $id_3$)
% \end{lstlisting}

% The statement of Listing~\ref{lst:t-design-ci-abss} is almost similar
% to the one of Listing~\ref{lst:trans-design-instantiation}. The
% \texttt{NOT_TEMPORAL} value associated to the \texttt{transition_type}
% constant is turned into 0 (remember the \texttt{temporal_t}
% enumeration type is transformed into a natural range type).

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../main"
%%% End:
