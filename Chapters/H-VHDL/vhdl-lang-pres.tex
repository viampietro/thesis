The intent here is to give an overview of the VHDL language, its
purpose, its main syntactal constructs, and an informal description of
its semantics as presented in the Language Reference Manual (LRM)
\cite{VHDL2000}. The VHDL language offers a lot of possibility in
terms of hardware (and even software) description. Here, we are not
trying to be exhaustive in our presentation of the language. We will
only maintain our description of the VHDL concepts in the scope that
is of interest to us. The readers that are interested in learning more
about the VHDL language can refer to \cite{VHDL2000},
\cite{Ashenden2010} and \cite{Pedroni2020}.

\subsection{Main concepts}
\label{sec:vhdl-main-concepts}

The VHDL acronym stands for Very high speed integrated circuit
Hardware Description Language. As its name indicates, the main purpose
of the VHDL language is to describe hardware circuits. There are two
approaches to the description of circuits. The first aims at the
simulation of the described circuits, and the second aims at the
synthesis of described circuits on physical supports. Thus, the
constructs of the VHDL language must be interpreted depending on the
purpose of the designer.  For instance, the language gives the
possibility to describe the connection of wires inside a circuit. A
wire is represented by the concept of \textit{signal}.  In the context
of circuit simulation, a \textit{signal} can be compared to a
variable; it has a given type and holds a value that fluctuates in the
course of the simulation. In the context of synthesis, a signal really
describes a physical wire and must be considered as so. From these two
approaches to circuit description arise two ways of considering the
semantics of the language (see Section~\ref{sec:choosing-vhdl}).

In VHDL, a top-level program is called a \emph{design}. A design
describes a hardware circuit. As explained in
Chapter~\ref{chap:hilecop}, the hilecop{} transformation generates a
VHDL design implementing the input SITPN model. To do so, the
transformation generates and connects the component instances of two
previously defined VHDL designs: the \emph{place} design that
implements the concept of a SITPN place, and the \emph{transition}
design that implements a SITPN transition. These designs were defined
by the INRIA CAMIN team at the creation of the \hilecop{}
methodology. In the following sections, we will be using excerpts of
the definition of the place and transition designs to illustrate the
content of VHDL programs and the rules of the VHDL language
semantics. The reader will find the source code of the place and
transition designs in concrete and abstract syntax in
Appendices~\ref{app:place-design} and \ref{app:trans-design}.

A VHDL design is composed of two descriptive parts. The first part is
called the entity and describes the interfaces of a circuit, namely:
the input and output ports, and the generic
constants. Listing~\ref{lst:trans-design-entity} is an excerpt of the
transition design's entity that defines the generic constants, the
input and output port interfaces of the
design. Figure~\ref{fig:trans-design-entity} is a visual
representation of the interfaces of the transition design.

\begin{lstlisting}[language=VHDL,label={lst:trans-design-entity},
caption={The entity part of the transition design in concrete VHDL
  syntax.},framexleftmargin=1.5em,xleftmargin=2em,numbers=left,
numberstyle=\tiny\ttfamily]
entity transition is
  generic(
    transition_type      : transition_t := NOT_TEMPORAL;
    input_arcs_number    : natural := 1; 
    conditions_number    : natural := 1;
    maximal_time_counter : natural := 1
    );        
  port(
    clock                   : in std_logic;
    reset_n                 : in std_logic;
    input_conditions        : in std_logic_vector(conditions_number-1 downto 0);
    time_A_value            : in natural range 0 to maximal_time_counter;
    time_B_value            : in natural range 0 to maximal_time_counter;
    input_arcs_valid        : in std_logic_vector(input_arcs_number-1 downto 0);
    reinit_time             : in std_logic_vector(input_arcs_number-1 downto 0);
    priority_authorizations : in std_logic_vector(input_arcs_number-1 downto 0);
    fired                   : out std_logic 
    );
end transition;
\end{lstlisting}

The generic clause of the entity holds the declaration of the generic
constants.  The purpose of generic constants is either to represent
some dimensions of the design (e.g. the size of ports, internal
signals\dots) or to represent constant values used throughout the
design. In Listing~\ref{lst:trans-design-entity}, one can see that the
\texttt{conditions_number} generic constant gives a dimension to the
type of the \texttt{input_conditions} input port, which is an array of
Boolean values with indexes ranging from 0 to
\texttt{conditions_number-1} (that is the meaning of
\texttt{std_logic_vector (conditions_number-1 downto 0)}.  The port
clause holds the declaration of input and output ports of the
design. The \texttt{in} keyword indicates the declaration of an input
port and the \texttt{out} indicates the declaration of an output port.

\begin{figure}[H]
  \centering
  \includegraphics[keepaspectratio=true, width=.6\textwidth]{Figures/H-VHDL/trans-design-entity}
  \caption[A representation of the transition design entity.]{A
    representation of the transition design entity. On the left side,
    the input port interface of the transition design; \textit{cn}
    stands for \textit{conditions\_number} and \textit{ian} stands for
    \textit{input\_arcs\_number}, i.e. two of the generic constants
    declared in the generic clause of the transition design entity;
    the numbers at the right of the input pins represent the pin
    indexes. On the right side, the output port interface of the
    transition design.}
  \label{fig:trans-design-entity}
\end{figure}

The second part of a VHDL design is called the architecture. The
architecture describes the internal behavior of the design. It
declares all the internal signals involved in the description of the
design behavior. Then, there are three ways to describe the behavior
itself: by using processes, by instantiating other designs (also
called, component instantiations), or by combining both technics (the
latter option is chosen in the VHDL designs generated by the
\hilecop{} transformation).

\paragraph{Behavior specification with processes}

The first way is to specify one or multiple processes. Processes are
concurrent statements that describes the wiring or the operations
performed on the signals of a given design.  A process declares a
sensitivy list that corresponds to the signals read in the process
statement body; also, it possibly declares internal variables. The
sensitivity list is only useful for the purpose of simulation. It
permits to resume the execution of a process when the value of one of
the signals of its sensitivity list
changes. Listing~\ref{lst:trans-design-arch} gives an excerpt of the
transition design architecture containing the declarative part of the
architecture (i.e. internal signals) and three of the processes
describing the transition design behavior, namely: the
\texttt{condition_evaluation} process, the \texttt{firable} process
and the \texttt{fired_evaluation} process.

\begin{lstlisting}[language=VHDL,label={lst:trans-design-arch},
caption={An excerpt of the architecture part of the transition design in concrete VHDL
  syntax.},framexleftmargin=1.5em,xleftmargin=2em,numbers=left,
numberstyle=\tiny\ttfamily]
architecture transition_architecture of transition is
  signal s_condition_combination : std_logic; #\label{line:scc}#
  signal s_enabled               : std_logic;
  signal s_firable               : std_logic;   
  signal s_firing_condition      : std_logic;
  signal s_priority_combination  : std_logic;
  signal s_reinit_time_counter   : std_logic; 
  signal s_time_counter          : natural range 0 to maximal_time_counter; #\label{line:stc}#
begin
  
  condition_evaluation : process(input_conditions) #\label{line:condev-ps}#
    variable v_internal_condition : std_logic;
  begin
    v_internal_condition := '1';
    
    for i in 0 to conditions_number - 1 loop #\label{line:for-begin}#
      v_internal_condition := v_internal_condition and input_conditions(i);
    end loop; #\label{line:for-end}#
    
    s_condition_combination <= v_internal_condition; #\label{line:assign-scc}#
  end process condition_evaluation;
    
  $\dots$

  firable : process(reset_n, clock)
  begin
    if (reset_n = '0') then
      s_firable <= '0';
    elsif falling_edge(clock) then
      s_firable <= s_firing_condition;
    end if;
  end process firable;

  fired_evaluation : process (s_firable, s_priority_combination)
  begin
    fired <= s_firable and s_priority_combination;
  end process fired_evaluation;      
  
end transition_architecture;
\end{lstlisting}

In Listing~\ref{lst:trans-design-arch}, from Line~\ref{line:scc} to
Line~\ref{line:stc}, the architecture declares the internal signals of
the transition design. Then, Line~\ref{line:condev-ps} begins the
declaration of the \texttt{condition_evaluation} process. The
sensitivity list of the \texttt{condition_evaluation} process holds
one signal, the \texttt{input_conditions} input port, and declares a
local variable \texttt{v_internal_condition}.

In the statement body of a process, the designer can use control flow
statements common to most of the generic programming languages (if
statement, for loops\dots), and also statements that are specific to
the VHDL language. The most representative statement, and the one of
interest to us, is the \emph{signal assignment} statement. The signal
assignment statement relate a given signal identifier to a source
expression. For instance, at Line~\ref{line:assign-scc} of
Listing~\ref{lst:trans-design-arch}, the signal assignment statement,
represented with the $\Leftarrow$ operator, assigns the value of the
internal variable \texttt{v_internal_condition} to signal
\texttt{s_condition_evaluation}; the \texttt{v_internal_variable} that
itself holds the Boolean product between the members of the
\texttt{input_conditions} input port performed in the \texttt{for}
loop of Lines~\ref{line:for-begin} to \ref{line:for-end}.

When considering a VHDL design in the point of view of hardware
synthesis, a signal assignment statement specifies a wiring between a
target signal identifier and other source
signals. Figure~\ref{fig:trans-design-arch-excerpt-1} gives a
synthesis-oriented view of the processes described in
Listing~\ref{lst:trans-design-arch}.

\begin{figure}[H]
  \centering
  \includegraphics[keepaspectratio=true, width=.8\textwidth]{Figures/H-VHDL/trans-design-arch-excerpt-1}
  \caption[Representation of a part of the transition design
  architecture.]{A representation of a part of the transition design
    architecture comprising three processes. On the left side, the
    \texttt{condition_evaluation} process connecting the
    \texttt{input_conditions} input port to the
    \texttt{s_condition_combination} internal signal; the
    \texttt{firable} process in the middle; on the right side, the
    \texttt{fired_evaluation} process connecting the
    \texttt{s_firable} and the \texttt{s_priority_combination} signals
    to the \texttt{fired} output port.}
  \label{fig:trans-design-arch-excerpt-1}
\end{figure}

In Figure~\ref{fig:trans-design-arch-excerpt-1}, the
\texttt{condition_evaluation} process is represented as an
\texttt{and} port performing the product over the elements of the
\texttt{input_conditions} input port. The \texttt{fired_evaluation}
process is a simple \texttt{and} gate connecting the \texttt{fired}
output port to the \texttt{s_firable} and
\texttt{s_priority_combination} internal signals. The \texttt{firable}
process is a \textit{synchronous} process. It responds to the event of
the \texttt{clock} signal. In its statement body, the \texttt{firable}
process assigns the value of the internal signal
\texttt{s_firing_condition} to the signal \texttt{s_firable} only at
the occurrence of the falling edge of the \texttt{clock} signal
(captured by the expression \texttt{falling_edge(clock)} where
\texttt{falling_edge} is a primitive function of the VHDL
language). In the point of view of simulation, there are no
distinction between synchronous processes and \emph{combinational}
processes, i.e. processes that are executed independently of the
occurrence of a clock signal. However, in the point of view of
synthesis, processes responding to a \texttt{clock} signal follow the
rules of the synchronous logic, whereas, combinational processes
follow the rules of combinational logic.

To complete the presentation of the statements to be found in the body
of processes, the VHDL language is also equipped with \texttt{timing}
constructs, i.e. statements that explicitly specify an amount of time
in a given time unit. The signal assignement statement possibly
specifies a time clause indicating when the assignment must be
performed. For instance, the signal assignment statement specifying
that the value of signal \texttt{b} must be assigned to signal
\texttt{a} in 3 milliseconds takes the form: \texttt{$a\Leftarrow{}b$
  in 3 ms}. When no time clause is specified for a signal assignment
statement, we talk about a $\delta$-delay signal assignment, i.e. the
application of the signal assignment is related to some $\delta$
interval corresponding the propagation time through a wire. When a
time clause is specified, we talk about an unit-delay signal
assignment. $\delta$-delay signal assignments are synthetizable,
meaning they have an equivalent implementation on a physical device,
whereas, unit-delay signal assignments can not be
synthetized. Unit-delay signal assignments do not appear neither in
the VHDL designs generated by \hilecop{} transformation nor in the
declaration of the place and transition designs. We are only
mentioning their existence here because they are the witnesses of the
two time paradigms that inhabit the simulation algorithm describe the
semantics of the VHDL language: $\delta$ time and real time.

\paragraph{Behavior specification with design instances}

The second way to specify the behavior of a design is to use other
designs, or rather instances of other designs, as components of the
circuits. In that case, the design is said to be composite as it
embeds instances of other designs in its own behavior. Also, a design
at the highest level of embedding, i.e. that is not instantiated as a
part of another design's behavior, is called a \emph{top-level}
design. The design instantiation, or component instantiation,
statement permits to instantiate a design in an embedding
architecture. When instantiating a design with a design instantiation
statement, the designer provides the component instance with an
identifier. Then, the design instance must be dimensioned; this is
performed through a generic map that associates the generic constants
of the design being instantiated to a static value. Finally, the
designer specifies how the component instance is connected to the
other elements of the architecture. A port map associates the input
ports and output ports of the component instance to expressions or to
the signals of the embedding
architecture. Listing~\ref{lst:trans-design-instantiation} shows an
example of instantiation of the \hilecop{}'s transition design. This
instance is involved in the definition of the behavior of an embedding
design called \texttt{toplevel}.

\begin{lstlisting}[language=VHDL,label={lst:trans-design-instantiation},
caption={An example of design instantiation statement in the architecture of the \texttt{toplevel} design. Here, the design being instantiated is the transition design.},framexleftmargin=1.5em,xleftmargin=2em,numbers=left,
numberstyle=\tiny\ttfamily]
architecture toplevel_architecture of toplevel is
begin
  #\dots#
  $id_t$ : entity transition 
  generic map (
    transition_type => NOT_TEMPORAL,
    input_arcs_number => 1,
    conditions_number => 1,
    maximal_time_counter => 1
  )
  port map (
    clock => clock,
    reset_n => reset_n,
    time_A_value => 0,
    time_B_value => 0,
    input_conditions(0) => $id_0$,
    input_arcs_valid(0) => $id_1$,
    priority_authorizations(0) => '1',
    reinit_time(0) => $id_2$,
    fired => $id_3$
  );
  #\dots#
end toplevel_architecture;
\end{lstlisting}

In Listing~\ref{lst:trans-design-instantiation}, the transition
component instance has the identifier $id_t$. Following the
\texttt{entity} keyword is the name of the design being instantiated;
here, the transition design. Then, the generic map associates the
generic constants of the transition design (i.e. the left side of the
arrow, also called the \emph{formal} part) to static values (i.e. the
right side of the arrow called the \emph{actual} part). This permits
the dimensiniong the component instance. For example, remember that
the \texttt{input_arcs_number} generic constant value determines the
number of elements in the composite input ports
\texttt{input_arcs_valid}, \texttt{priority_authorizations} and
\texttt{reinit_time}. The port map associates the input ports of the
transition design to expressions. For instance, the
\texttt{time_A_value} input port is connected to the constant value
$0$, and the \texttt{input_conditions} input port is connected to the
internal signal $id_0$ at index $0$. The port map also associates the
output ports with signal identifiers. Contrary to the association of
input ports, output ports can not be associated to expressions as
output port association describes a direct wiring. In the port map
described in Listing~\ref{lst:trans-design-instantiation}, the
association $\mathtt{fired}\Rightarrow{}id_3$ expresses that the
\texttt{fired} output port is connected to the signal $id_3$, where
signal $id_3$ is defined in the embedding
design. Figure~\ref{fig:trans-design-instance} illustrates the
transition design instance $id_t$ and the wiring of its input and
output port interfaces inside the toplevel design.

\begin{figure}[H]
  \centering
  \includegraphics[keepaspectratio=true, width=.8\textwidth]{Figures/H-VHDL/trans-design-instance}
  \caption[Visual representation of a design instantiation
  statement.]{Visual representation of a design instantiation
    statement. Here, the figure represents the transition design
    instance described in
    Listing~\ref{lst:trans-design-instantiation}.}
  \label{fig:trans-design-instance}
\end{figure}

% The wait statement stalls the execution of a process
% during a certain amount of time, or until some event arises on a given
% signal. An event arises on a signal when its value changes. Every
% process declared in an architecture possess a implicit wait statement
% at the end of its statement body. This statement waits on an event on
% one of the signals of the sensitivity list. This implicit wait
% statement is only useful for the purpose of simulation. Indeed, the
% wait statement is no synthetizable. 

\subsection{Informal semantics of the VHDL language}
\label{sec:vhdl-informal-sem}

Even though, in practice, there are two ways to consider a VHDL
design, i.e. a synthesis-oriented way and a simulation-oriented way,
the LRM does not define a synthesis-oriented semantics for the VHDL
language.  A synthesis-oriented semantics gives an interpretation to a
design by describing an equivalent in a lower level formalism, closer
to the physical circuit. For instance, the Verilog language gives a
synthesis-oriented semantics to its programs by defining an equivalent
RTL level description \cite{Verilog2005}.  The LRM gives an informal
semantics to VHDL designs through the definition of a simulation
algorithm. The purpose of simulation is to compute the evolution of
the values of signals during a certain time interval. Through the
simulation process, the designer is able to control the behavior of
the modeled circuits and to detect flaws in the evolution of the
signal values.

Former to the simulation, the LRM defines an elaboration phase that
permits to transform a design into a simulation-ready execution
model. The elaboration phase has several goals. First, it builds the
simulation environment and a starting design simulation state. The
simulation environment is built based on the declarative parts of the
top-level design; it maps the signals to their types. In the design
simulation state, each signal is associated with a current value and
with a driver. A driver maps time points to values and the association
between a given time point and a signal value is called a
transaction. The necessity of drivers is explained by the presence of
unit-delay signal assignments. A unit-delay signal assignment specify
a time clause indicating when a giving assignment must be performed,
e.g. \texttt{$a\Leftarrow{}b$ in 3ms} (signal \texttt{a} takes the
value of signal \texttt{b} in 3 milliseconds). Thus, when a unit-delay
signal assignment is executed in the course of a simulation, its
effect is to change the driver of the target signal by posting a new
transaction. For instance, let $T_c$ by the current simulation time,
the execution of statement \texttt{$a\Leftarrow$ true in 2ns} sets a
new transaction in the driver of signal $a$. The new transaction
associates the value \texttt{true} to the time point
$T_c+\mathtt{2ns}$. Note that without unit-delay signal assignments,
drivers are not needed as all assignments take their effects at the
current simulation time.
% Also, each signal is associated with a
% graph representing the relation to its source, i.e. the signals
% involved in the computation of the target signal value. For instance,
% the source signals of the \texttt{fired} output port represented in
% Figure~\ref{fig:trans-design-arch-excerpt-1} are the
% \texttt{s_firable} and the \texttt{s_priority_combination}
% signals. 
Second, the elaboration checks the well-formedness of the design by
performing static type-checking on the behavioral part of the
design. It also checks that the connection between signals respect
certain rules, for instance, that there are no multiply-driven
signals, i.e. signals that are written to by multiple
processes. Finally, the elaboration operates some transformations over
the VHDL code, and thus builds the \emph{execution} model. To
summarize, all concurrent statements of the behavioral part are
transformed until the top-level design behavior is only composed of
processes.

After the elaboration, the top-level design, or rather its
corresponding execution model, is ready to be simulated. Two entities
are involved in the simulation: the \emph{sea} of processes obtained
after the elaboration of the top-level design, and a \emph{kernel}
process. The kernel process orchestrates the simulation; it handles
the time of the simulation, i.e. it holds a variable describing the
current time of the simulation, and resumes the execution of
processes. Figure~\ref{fig:vhdl-sim-alg}, which is an excerpt from
\cite{Borger1995}, describes the structure of the VHDL simulation
algorithm.

\begin{figure}[H]
  \centering
  \includegraphics[keepaspectratio=true, width=.7\textwidth]{Figures/H-VHDL/vhdl-sim-alg}
  \caption[The VHDL simulation loop.]{The VHDL simulation loop. Excerpt from \cite{Borger1995}.}
  \label{fig:vhdl-sim-alg}
\end{figure}


The simulation starts with the initialization phase. During the
initialization phase all processes are run exactly once. Then, the
simulation cycles are structured as follows.  All processes execute
their statement body concurrently. New transactions are posted in the
drivers of signals for every interpreted signal assignment
statement. The execution goes on until all processes have executed
their statement body and then have reached a suspension state. When,
all processes are suspended, the kernel process takes
over. Figure~\ref{fig:kernel-ps} shows the activity diagram associated
with the kernel process.

\begin{figure}[H]
  \centering
  \includegraphics[keepaspectratio=true, width=.35\textwidth]{Figures/H-VHDL/kernel-ps}
  \caption[The activity diagram of the kernel process.]{The activity
    diagram of the kernel process. Square boxes represent activities,
    diamond nodes are decision nodes. The black circle at the top
    represents the starting point of the activities; the other black
    circle in the middle of the diagram represents the end of all
    activities.}
  \label{fig:kernel-ps}
\end{figure}

As shown in Figure~\ref{fig:kernel-ps}, the kernel process will then
determine the kind of simulation cycle that will be performed next.
There are two kinds of cycles: delta cycle or time cycle. If the value
of a signal changes at the current time point, i.e. its driver holds a
transaction at the current time point with a new value, then a delta
cycle must be performed.  Then, the simulation time does not change.
The kernel process updates the current value of signals and their
drivers, and wakes up the processes sensitive to the signals that
obtained new values. The repetition of multiple delta cycles
corresponds to the stabilization of signal values, i.e. the
propagation of values through the wires, that takes effect in a
negligeable $\delta$ time. If all signal values are stable at the
current time point, then a time cycle must be performed.  The kernel
process looks up the drivers for the next time point where the value
of a given signal will change. Then, the kernel process advances the
simulation time to this next time point before updating the signal
values and resuming the execution of processes.  The simulation goes
on like this, alternating between delta and time cycles, until the
current time value reaches the time specified for the end of the
simulation.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../main"
%%% End:
