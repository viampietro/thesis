The intent here is to give an overview of the VHDL language, its
purpose, its main syntactal constructs, and an informal description of
its semantics as presented in the Language Reference Manual (LRM)
\cite{VHDL2000}. The VHDL language offers a lot of possibility in
terms of hardware (and even software) description. Here, we are not
trying to be exhaustive in our presentation of the language. We will
only maintain our description of the VHDL concepts in the scope that
is of interest to us. The readers that are interested in learning more
about the VHDL language can refer to \cite{VHDL2000},
\cite{Ashenden2010} and \cite{Pedroni2020}.

\subsection{Main concepts}
\label{sec:vhdl-main-concepts}

The VHDL acronym stands for Very high speed integrated circuit
Hardware Description Language. As its name indicates, the main purpose
of the VHDL language is to describe hardware circuits. There are two
approaches to the description of circuits. The first aims at the
simulation of the described circuits, and the second aims at the
synthesis of described circuits on physical supports. Thus, the
constructs of the VHDL language must be interpreted depending on the
purpose of the designer.  For instance, the language gives the
possibility to describe the connection of wires inside a circuit. A
wire is represented by the concept of \textit{signal}.  In the context
of circuit simulation, a \textit{signal} can be compared to a
variable; it has a given type and holds a value that fluctuates in the
course of the simulation. In the context of synthesis, a signal really
describes a physical wire and must be considered as so. From these two
approaches to circuit description arise two ways of considering the
semantics of the language (see Section~\ref{sec:choosing-vhdl}).

In VHDL, a top-level program is called a \emph{design}. A design
describes a hardware circuit. As explained in
Chapter~\ref{chap:hilecop}, the hilecop{} transformation generates a
VHDL design implementing the input SITPN model. To do so, the
transformation generates and connects the component instances of two
previously defined VHDL designs: the \emph{place} design that
implements the concept of a SITPN place, and the \emph{transition}
design that implements a SITPN transition. These designs were defined
by the INRIA CAMIN team at the creation of the \hilecop{}
methodology. In the following sections, we will be using excerpts of
the definition of the place and transition designs to illustrate the
content of VHDL programs and the rules of the VHDL language
semantics. The reader will find the source code of the place and
transition designs in concrete and abstract syntax in
Appendices~\ref{app:place-design} and \ref{app:trans-design}.

A VHDL design is composed of two descriptive parts. The first part is
called the entity and describes the interfaces of a circuit, namely:
the input and output ports, and the generic
constants. Listing~\ref{lst:trans-design-entity} is an excerpt of the
transition design's entity that defines the generic constants, the
input and output port interfaces of the
design. Figure~\ref{fig:trans-design-entity} is a visual
representation of the interfaces of the transition design.

\begin{lstlisting}[language=VHDL,label={lst:trans-design-entity},
caption={The entity part of the transition design in concrete VHDL
  syntax.},framexleftmargin=1.5em,xleftmargin=2em,numbers=left,
numberstyle=\tiny\ttfamily]
entity transition is
  generic(
    transition_type      : transition_t := NOT_TEMPORAL;
    input_arcs_number    : natural := 1; 
    conditions_number    : natural := 1;
    maximal_time_counter : natural := 1
    );        
  port(
    clock                   : in std_logic;
    reset_n                 : in std_logic;
    input_conditions        : in std_logic_vector(conditions_number-1 downto 0);
    time_A_value            : in natural range 0 to maximal_time_counter;
    time_B_value            : in natural range 0 to maximal_time_counter;
    input_arcs_valid        : in std_logic_vector(input_arcs_number-1 downto 0);
    reinit_time             : in std_logic_vector(input_arcs_number-1 downto 0);
    priority_authorizations : in std_logic_vector(input_arcs_number-1 downto 0);
    fired                   : out std_logic 
    );
end transition;
\end{lstlisting}

The generic clause of the entity holds the declaration of the generic
constants.  The purpose of generic constants is either to represent
some dimensions of the design (e.g. the size of ports, internal
signals\dots) or to represent constant values used througout the
design. In Listing~\ref{lst:trans-design-entity}, one can see that the
\texttt{conditions_number} generic constant gives a dimension to the
type of the \texttt{input_conditions} input port, which is an array of
Boolean values with indexes ranging from 0 to
\texttt{conditions_number-1} (that is the meaning of
\texttt{std_logic_vector (conditions_number-1 downto 0)}.  The port
clause holds the declaration of input and output ports of the
design. The \texttt{in} keyword indicates the declaration of an input
port and the \texttt{out} indicates the declaration of an output port.

\begin{figure}[H]
  \centering
  \includegraphics[keepaspectratio=true, width=.6\textwidth]{Figures/H-VHDL/trans-design-entity}
  \caption[A representation of the transition design entity.]{A
    representation of the transition design entity. On the left side,
    the input port interface of the transition design; \textit{cn}
    stands for \textit{conditions\_number} and \textit{ian} stands for
    \textit{input\_arcs\_number}, i.e. two of the generic constants
    declared in the generic clause of the transition design entity;
    the numbers at the right of the input pins represent the pin
    indexes. On the right side, the output port interface of the
    transition design.}
  \label{fig:trans-design-entity}
\end{figure}

The second part of a VHDL design is called the architecture. The
architecture describes the internal behavior of the design. It
declares all the internal signals involved in the description of the
design behavior. Then, there are two ways to describe the behavior
itself: by using processes or by instantiating other designs (also
called, component instantiations).

\paragraph{Behavior specification with processes}

The first way is to specify one or multiple processes. Processes are
concurrent statements that describes the wiring or the operations
performed on the signals of a given design.  A process declares a
sensitivy list that corresponds to the signals read in the process
statement body; also, it possibly declares internal
variables. Listing~\ref{lst:trans-design-arch} gives an excerpt of the
transition design architecture containing the declarative part of the
architecture (i.e. internal signals) and three of the processes
describing the transition design behavior, namely: the
\texttt{condition_evaluation} process, the \texttt{firable} process
and the \texttt{fired_evaluation} process.

\begin{lstlisting}[language=VHDL,label={lst:trans-design-arch},
caption={An excerpt of the architecture part of the transition design in concrete VHDL
  syntax.},framexleftmargin=1.5em,xleftmargin=2em,numbers=left,
numberstyle=\tiny\ttfamily]
architecture transition_architecture of transition is
  signal s_condition_combination : std_logic; #\label{line:scc}#
  signal s_enabled               : std_logic;
  signal s_firable               : std_logic;   
  signal s_firing_condition      : std_logic;
  signal s_priority_combination  : std_logic;
  signal s_reinit_time_counter   : std_logic; 
  signal s_time_counter          : natural range 0 to maximal_time_counter; #\label{line:stc}#
begin
  
  condition_evaluation : process(input_conditions) #\label{line:condev-ps}#
    variable v_internal_condition : std_logic;
  begin
    v_internal_condition := '1';
    
    for i in 0 to conditions_number - 1 loop #\label{line:for-begin}#
      v_internal_condition := v_internal_condition and input_conditions(i);
    end loop; #\label{line:for-end}#
    
    s_condition_combination <= v_internal_condition; #\label{line:assign-scc}#
  end process condition_evaluation;
    
  $\dots$

  firable : process(reset_n, clock)
  begin
    if (reset_n = '0') then
      s_firable <= '0';
    elsif falling_edge(clock) then
      s_firable <= s_firing_condition;
    end if;
  end process firable;

  fired_evaluation : process (s_firable, s_priority_combination)
  begin
    fired <= s_firable and s_priority_combination;
  end process fired_evaluation;      
  
end transition_architecture;
\end{lstlisting}

In Listing~\ref{lst:trans-design-arch}, from Line~\ref{line:scc} to
Line~\ref{line:stc}, the architecture declares the internal signals of
the transition design. Then, Line~\ref{line:condev-ps} begins the
declaration of the \texttt{condition_evaluation} process. The
sensitivity list of the \texttt{condition_evaluation} process holds
one signal, the \texttt{input_conditions} input port, and declares a
local variable \texttt{v_internal_condition}.

In the statement body of a process, the designer can use control flow
statements common to most of the generic programming languages (if
statement, for loops\dots), and also statements that are specific to
the VHDL language. The most representative statement, and the one of
interest to us, is the \emph{signal assignment} statement. The signal
assignment statement relate a given signal identifier to a source
expression. For instance, at Line~\ref{line:assign-scc} of
Listing~\ref{lst:trans-design-arch}, the signal assignment statement,
represented with the $\Leftarrow$ operator, assigns the value of the
internal variable \texttt{v_internal_condition} to signal
\texttt{s_condition_evaluation}; the \texttt{v_internal_variable} that
itself holds the Boolean product between the members of the
\texttt{input_conditions} input port performed in the \texttt{for}
loop of Lines~\ref{line:for-begin} to \ref{line:for-end}.

When considering a VHDL design in the point of view of hardware
synthesis, a signal assignment statement specifies a wiring between a
target signal identifier and other source
signals. Figure~\ref{fig:trans-design-arch-excerpt-1} gives a
synthesis-oriented view of the processes described in
Listing~\ref{lst:trans-design-arch}.

\begin{figure}[H]
  \centering
  \includegraphics[keepaspectratio=true, width=.8\textwidth]{Figures/H-VHDL/trans-design-arch-excerpt-1}
  \caption[Representation of a part of the transition design
  architecture.]{A representation of a part of the transition design
    architecture comprising three processes. On the left side, the
    \texttt{condition_evaluation} process connecting the
    \texttt{input_conditions} input port to the
    \texttt{s_condition_combination} internal signal; the
    \texttt{firable} process in the middle; on the right side, the
    \texttt{fired_evaluation} process connecting the
    \texttt{s_firable} and the \texttt{s_priority_combination} signals
    to the \texttt{fired} output port.}
  \label{fig:trans-design-arch-excerpt-1}
\end{figure}

In Figure~\ref{fig:trans-design-arch-excerpt-1}, the
\texttt{condition_evaluation} process is represented as an
\texttt{and} port performing the product over the elements of the
\texttt{input_conditions} input port. The \texttt{fired_evaluation}
process is a simple \texttt{and} gate connecting the \texttt{fired}
output port to the \texttt{s_firable} and
\texttt{s_priority_combination} internal signals. The \texttt{firable}
process is a \textit{synchronous} process. It responds to the event of
the \texttt{clock} signal. In its statement body, the \texttt{firable}
process assigns the value of the internal signal
\texttt{s_firing_condition} to the signal \texttt{s_firable} only at
the occurrence of the falling edge of the \texttt{clock} signal
(captured by the expression \texttt{falling_edge(clock)} where
\texttt{falling_edge} is a primitive function of the VHDL
language). In the point of view of simulation, there are no
distinction between synchronous processes and \emph{combinational}
processes, i.e. processes that are executed independently of the
occurrence of a clock signal. However, in the point of view of
synthesis, processes responding to a \texttt{clock} signal follow the
rules of the synchronous logic, whereas, combinational processes
follow the rules of combinational logic.

To complete the presentation of the statements to be found in the body
of processes, the VHDL language is also equipped with \texttt{timing}
constructs, i.e. statements that explicitly specify an amount of time
in a given time unit. The signal assignement statement possibly
specifies a time clause indicating when the assignment must be
performed. For instance, the signal assignment statement specifying
that the value of signal \texttt{b} must be assigned to signal
\texttt{a} in 3 milliseconds takes the form: \texttt{$a\Leftarrow{}b$
  in 3 ms}. When no time clause is specified for a signal assignment
statement, we talk about a $\delta$-delay signal assignment, i.e. the
application of the signal assignment is related to some $\delta$
interval corresponding the propagation time through a wire. When a
time clause is specified, we talk about an unit-delay signal
assignment. $\delta$-delay signal assignments are synthetizable,
meaning they have an equivalent implementation on a physical device,
whereas, unit-delay signal assignments can not be
synthetized. Unit-delay signal assignments do not appear neither in
the VHDL designs generated by \hilecop{} transformation nor in the
declaration of the place and transition designs. We are only
mentioning their existence here because they are the witnesses of the
two time paradigms that inhabit the simulation algorithm describe the
semantics of the VHDL language: $\delta$ time and real time.



% The wait statement stalls the execution of a process
% during a certain amount of time, or until some event arises on a given
% signal. An event arises on a signal when its value changes. Every
% process declared in an architecture possess a implicit wait statement
% at the end of its statement body. This statement waits on an event on
% one of the signals of the sensitivity list. This implicit wait
% statement is only useful for the purpose of simulation. Indeed, the
% wait statement is no synthetizable. 


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../main"
%%% End:
