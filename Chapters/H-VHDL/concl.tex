In this chapter, we gave an overview of the \vhdl{} language and its
informal simulation semantics.  Then, considering our needs, that is
considering the content of the \vhdl{} programs generated by the
\hilecop{} model-to-text transformation, we defined a synthesizable
and synchronous subset of the \vhdl{} language called \hvhdl{}. We
gave a small-step semantics to \hvhdl{} by formalizing a simplified
simulation algorithm. The simulation algorithm yields a simulation
trace, i.e. time-ordered list of states, corresponding to the
execution of the behavior of a \hvhdl{} design over multiple clock
cycles. The formalization of the \hvhdl{} semantics also includes the
formalization of the design elaboration. The elaboration, prior to the
simulation, ensures the well-formedness and the well-typedness of a
\hvhdl{} design. Moreover, we have implemented the \hvhdl{} syntax and
semantics with the \coq{} proof assistant.

Ever since the mechanization of the proof of behavior preservation has
begun, the semantics of \hvhdl{} has been
evolving. Section~\ref{sec:abstractSyntax}, \ref{sec:sem-rules},
\ref{sec:elab-rules} and \ref{sec:sim-rules} present the most recent
version of the semantics.  We realized that keeping an operational
semantics as close as possible to the \vhdl{} simulation algorithm
added complexity to the proof process. For instance, in the \vhdl{}
simulation algorithm, the body of a process is executed during the
stabilization phase only if one signal of its sensitivity list is part
of the current state's event set. However, it is through the execution
of the body of a process with the rules of the \hvhdl{} semantics that
we can determine the \emph{combinational} equation associated with the
value of a signal. In the proceeding of the proof of semantic
preservation, we must often describe the value of a signal based on
the value of its input, or \emph{source}, signals
(cf. Section~\ref{sec:detailled-proof}).  Due to the event-based
system of resuming a process activity, a combinational process can
sometimes never be executed during a stabilization phase. Say that
process $p$ assigns signal $s$ with the expression $a~\mathtt{and}~b$,
where $a$ and $b$ are two signals. If the process $p$ is not executed,
then we will not be able to state that $s=a~\mathtt{and}~b$, even
though this equation always holds.  We had to carry extra hypotheses
in the definition of our lemmas to deal with this problem. Finally,
our current semantics always executes the body of combinational
processes during a stabilization phase, thus permitting us to easily
determine the combinational equation tied to a signal. By doing this
kind of simplification, we realized that we were heading toward a
semantics that was closer to the ``synthesis'' semantics we talked
about at the beginning of the chapter. This semantics tends to get
closer to the rules of the combinational logic and the synchronous
logic. These rules that a hardware system designer has in mind when
devising a model with a hardware description language.

% In the future, we contrive to improve the implementation of the
% \hvhdl{} semantics with more dependent types. Especially, the
% elaborated design and the design state structure are formally defined
% with intentional subsets. These subsets could be easily implemented
% with the \texttt{sig} type of the \coq{} proof assistant. Also, we
% plan to improve the formalization of the elaboration phase with a
% global lookup of multiply-driven signals.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../main"
%%% End:
