The goal of the elaboration phase is to build an elaborated design
$\Delta$ along with a \emph{default} state $\sigma_e$, out of a
\hvhdl{} design $d$. The elaboration relation also covers
type-checking operations for the declarative and behavioral parts of
design $d$. Even though the elaboration of a design is described in
the LRM, the formalization of this phase has been performed in few
works only \cite{Borrione1995,Deharbe1995,VanTassel1995}, and never in
a setting that covers both syntactical well-formedness and
type-checking of the designs.  We are interested in the formalization
of the elaboration phase because we are interested in the
\textit{well-formedness} of the programs generated by the \hilecop{}
transformation. Here, the term well-formedness refers to a
syntactically valid design, w.r.t. the syntactic rules of the VHDL
language, and to a well-typed design, w.r.t. the typing rules defined
in the LRM. Formalizing the elaboration phase is also a way to define
how the runtime environment and the runtime state of the simulation
are built. For now, we haven't tackle down the proof that the \hvhdl{}
designs generated by \hilecop{} are elaborable, i.e. syntactically
well-formed and well-typed. As explained in Chapter~\ref{chap:proof},
this task is foreseen in our work perspectives. Contrary to what is
prescribed by the LRM \cite[p. 166]{VHDL2000}, we are not dealing with
the transformation of the component instantiation statements into
block statements in our formalization of the elaboration phase. We
prefer to preserve the hierarchical structure of the design (i.e. its
composite structure) during its elaboration. We argue that dealing
with component instantiation statements instead of block statements
does not complexify the semantics of the \hvhdl{} simulation rules.

In the following sections describing the elaboration and the
simulation rules of the \hvhdl{} semantics, the green frames give
additional explanations about the premises of the rules and the red
frames bring additional explanations about the side conditions of the
rules.

\subsection{Design elaboration}
\label{subsubsec:design-elab}

Component instances possibly define the behavior of a design. Each
component instance declares the entity identifier that points out to
the specific design being instantiated. Therefore, for each
instantiation, the associated design must be known through the
definition of a global design declaration environment called a
\emph{design store}. A design store is defined as follows:

\begin{definition}[Design store]
  \label{def:design-store}
  A design store
  $\mathcal{D}\in{}entity\mhyphen{}id\nrightarrow{}\mathrm{design}$ is
  the partial function mapping design identifiers (i.e. the entity
  identifier of designs) to their corresponding representation in
  abstract syntax. As a prerequisite to the elaboration of
  \hilecop{}-generated designs (i.e, resulting from the transformation
  of a SITPN into an \hvhdl{} design), a particular design store
  $\mathcal{D}_\mathcal{H}$ is defined.  Design store
  $\mathcal{D}_\mathcal{H}$ binds the \texttt{transition} and
  \texttt{place} identifiers to the
  definition of the place and transition designs in \hvhdl{} abstract syntax:\\
  
  \begin{tabular}{@{}ll@{}}
    \centering
    $\mathcal{D}_\mathcal{H}:=$ & $\{("transition", \mathtt{design}~"transition"~"transition\_architecture"~gens_t~ports_t~sigs_t~cs_t),$ \\
                                & $("place", \mathtt{design}~"place"~"place\_architecture"~gens_p~ports_p~sigs_p~cs_p)\}$ \\
  \end{tabular}\\

  The full definition of the place and transition designs in abstract
  syntax are given in Appendices~\ref{app:place-design} and
  \ref{app:trans-design}.
\end{definition}

At the beginning of the elaboration phase, a function
$\mathcal{M}_g\in{}generic\mhyphen{}id\nrightarrow{}value$ mapping the
top-level design's generic constants to values is passed as an element
of the environment. The $\mathcal{M}_g$ function is refered to as the
\emph{dimensioning} function.

\begin{table}[H]
  \centering
  \begin{tabular}{@{}l}
    {\fontsize{8}{11}\selectfont\textsc{DesignElab}} \\    
    {\begin{prooftree}

        % Elaborates gens, ports, sigs and cs.

        \hypo{\Delta_{\emptyset},\mathcal{M}_g&\vdash{}\mathrm{gens}\xrightarrow{egens}\Delta}
        \infer[no rule]1{\Delta,\sigma_\emptyset&\vdash{}
          \mathrm{ports}\xrightarrow{eports}\Delta',\sigma}
        \infer[no rule]1{\Delta',\sigma&\vdash{}\mathrm{sigs}\xrightarrow{esigs}\Delta'',\sigma'}
        \infer[no rule]1{\mathcal{D},\Delta'',\sigma'&\vdash
          \mathrm{cs}\xrightarrow{ebeh}\Delta''',\sigma''}
        
        % Conclusion
        
        \infer[template={\inserttext}]1
        {
          $\mathcal{D},\mathcal{M}_g\vdash$
          \vhdle|design| id$_e$ id$_a$ gens ports sigs cs
          $\xrightarrow{elab}$
          $\Delta''',\sigma''$
        }
      \end{prooftree}} \\
  \end{tabular}
\end{table}

where $\Delta_\emptyset$ denotes an empty elaborated design, that is
an elaborated design initialized with empty fields (empty tables). In
the same manner, $\sigma_\emptyset$ denotes an empty design state.
The effect of the $egens$, $eports$, $esigs$ and $ebeh$ that
respectively deal with the elaboration of the generic constants, the
ports, the architecture declarative part and the behavioral part of
the design, are explicited in the following sections.

\paragraph{Example of a design elaboration}

The elaborated design and the default design state resulting of the
elaboration of the transition design for a given dimensioning function
$\mathcal{M}$ are the presented through the $\Delta$ and $\sigma_e$
structures in Figures~\ref{fig:elab-version-of-t} and
\ref{fig:default-state-of-t}.  The value of the dimensioning function
$\mathcal{M}$ is the set of couples $\{("transition\_type", 2),$
$("conditions\_number",2),$ $("input\_arcs\_number", 4)\}$.

\begin{figure}[H]
  \centering
\begin{tabular}{@{}rl@{}}
  $\Delta:=\{$ & \\
               & \begin{tabular}{@{}ll@{}}
                   $Gens := $ & $\{("transition\_type", (nat(0,2), 2)),$ \\
                              & $("conditions\_numbers", (nat(0,\mathtt{NATMAX}), 2))$ \\
                              & $("input\_arcs\_number", (nat(0,\mathtt{NATMAX}), 4))$ \\
                              & $("maximal\_time\_counter", (nat(0,\mathtt{NATMAX}), 1))\},$ \\
                 \end{tabular} \\
               & \\
               & \begin{tabular}{@{}ll@{}}
                   $Ins :=$ & $\{("input\_conditions", array(bool,0,1)),$ \\
                            & $("time\_A\_value", nat(0,1)),$ \\
                            & $("time\_B\_value", nat(0,1)),$ \\
                            & $("input\_arcs\_valid", array(bool,0,3)),$ \\
                            & $("reinit\_time", array(bool,0,3)),$ \\
                            & $("priority\_authorizations", array(bool,0,3))\},$ \\
                 \end{tabular} \\
               & \\
               & \begin{tabular}{@{}ll@{}}
                   $Outs :=$ & $\{("fired", bool)\}$ \\
                 \end{tabular} \\
               & \begin{tabular}{@{}ll@{}}
                   $Sigs :=$ & $\{("s\_condition\_combination", bool),$ \\
                             & $("s\_enabled", bool),$ \\
                             & $("s\_time\_counter", nat(0,1))\},$ \\
                 \end{tabular} \\
               & \\
               & \begin{tabular}{@{}ll@{}}
                   $Ps :=$ & $\{("condition\_evaluation", \{("v\_internal\_condition", (bool, \bot))\}),$ \\
                           & $("firable", \emptyset)\}$ \\
                 \end{tabular} \\
               & \\
               & $Comps := \emptyset$ \\
  $\}$ &  \\
\end{tabular}

\caption[An elaborated version of the transition design.]{An
  elaborated version of the transition design; the sub-environments of
  the elaborated design structure (i.e. functions) are represented by
  sets of couples.}
\label{fig:elab-version-of-t}
\end{figure}

For the sake on conciseness, Figure~\ref{fig:elab-version-of-t} gives
only a part of the $Sigs$ and $Ps$ sub-environments resulting from the
elaboration of the transition design.  In
Figure~\ref{fig:elab-version-of-t}, the generic constants of the
transition design received their values from the dimensioning function
$\mathcal{M}$. As it is not defined in the domain of $\mathcal{M}$,
the \texttt{maximal_time_counter} generic constant is associated with
its default value. Also, all the types associated with ports and
internal signals have been \emph{resolved}; i.e. the expressions
qualifying the upper and lower bound of ranges, in the definition of
natural range types or array types, have been evaluated. Due to the
presence of generic constant identifiers in the expression of type
ranges, we had to wait for the generic constants to receive a
value. For example, \texttt{array(boolean, 0, conditions_number-1)} is
the type indication associated with the \texttt{input_conditions}
input port. The dimensioning function sets the value of the
\texttt{conditions_number} generic constant to 2. After elaboration,
the type indication \texttt{array(boolean, 0, conditions_number-1)} is
transformed into the type $array(bool, 0, 1)$. The $Ps$
sub-environment associates each process identifier to a local
environment, i.e. a mapping between local variables declared in the
process and a couple $(type, value)$. In a local environment, each
local variable has an initial value corresponding to the implicit
default value of its type (see
Section~\ref{subsec:implicit-default-v}). The behavior of the
transition design is set with processes only. Thus, the $Comps$
sub-environment, that maps each component instance identifier to an
elaborated design structure, is empty.

Figure~\ref{fig:default-state-of-t} shows the default design state
$\sigma_e$ of $\Delta$. In the default design state of an elaborated
design, the value of all signals corresponds to the implicit default
value of signals (i.e. deduced from the type of signals, see
Section~\ref{subsec:implicit-default-v}).

\begin{figure}[H]
  \centering
\begin{tabular}{@{}rl@{}}
  $\sigma_e:=\{$ & \\
                 & \begin{tabular}{@{}ll@{}}
                     $\mathcal{S} :=$ & $\{("input\_conditions", (\bot,\bot)),$ \\
                                      & $("time\_A\_value", 0),$ \\
                                      & $("time\_B\_value", 0),$ \\
                                      & $("input\_arcs\_valid", (\bot,\bot,\bot)),$ \\
                                      & $("reinit\_time", (\bot,\bot,\bot)),$ \\
                                      & $("priority\_authorizations", (\bot,\bot,\bot)),$ \\
                                      & $("fired", \bot),$ \\
                                      & $("s\_condition\_combination", \bot),$ \\
                                      & $("s\_enabled", \bot),$ \\
                                      & $("s\_time\_counter", 0)\},$ \\
                   \end{tabular} \\
                 & \\
                 & $\mathcal{C}:=\emptyset$ \\
                 & $\mathcal{E}:=\emptyset$ \\
  $\}$ &  \\
\end{tabular}

\caption[An example of default design state for the transition
design.]{The default design state associated built during the
  elaboration phase along the elaborated design of
  Figure~\ref{fig:elab-version-of-t}. We use values enclosed between
  parentheses to represent array values.}
\label{fig:default-state-of-t}
\end{figure}

The component store of design state $\sigma_e$ is empty as there are
no component instances defining the behavior of the transition design.
Also, the set of events of a default design state is always empty.

\subsection{Generic clause elaboration}
\label{subsubsec:gen-clause-elab}

The \textit{egens} relation elaborates a list of generic constant
declarations.

\begin{premises}
  \begin{itemize}[label=-]
  \item $etype_g$ transforms a type indication, specifically attached
    to a generic constant declaration, into a $type$ instance and
    checks its well-formedness (see Section~\ref{subsec:type-elab}).
  \item The $e$ relation links an expression $e$ to its value $v$ in a
    given context (see Section~\ref{subsec:expr-rules}). The context
    of evaluation for an expression is composed of a given elaborated
    design, a given design state, and given local environment. We omit
    symbols at the left of the thesis when they refer to empty
    structures. For instance, $\vdash{}e\xrightarrow{e}v$ is a
    notation for
    $\Delta_\emptyset,\sigma_\emptyset,\Lambda_\emptyset\vdash
    \mathrm{e}\xrightarrow{e}v$.
  \item $SE_l$ states that an expression is $locally$ static (see
    Section~\ref{subsubsec:loc-static}).
  \item $v\in_c{}T$ and $\mathcal{M}(\mathrm{id}_g)\in_c{}T$ checks
    that the default value and the value of yielded by the
    dimensioning function belongs to the type of the declared generic
    constant (see Section~\ref{subsec:constr-satif-rel}).
  \end{itemize}  
\end{premises}

\begin{sideconds}
  The expression $id_g\in\Delta$ checks that the generic constant
  identifier $id_g$ is not already defined in the \emph{Gens}
  sub-environment of the elaborated design $\Delta$.
\end{sideconds}

\begin{table}[H]
  \begin{tabular}{@{}l}
    {\fontsize{8}{11}\selectfont\textsc{GenElabDimen}} \\
    {\begin{prooftree}

        % Well-formed type and elaborates type.
        \hypo{\vdash\tau\xrightarrow{etype_g}T}
        
        % Evaluates expr. default.
        \hypo{&\vdash\mathrm{e}\xrightarrow{e}v}

        % Checks static expr. default
        \hypo{&SE_l(\mathrm{e})}

        % Checks the type of the value yielded by the dimensioning fun.
        \hypo{v&\in_c{}T}
        \infer[no rule]1{\mathcal{M}(\mathrm{id}_g)&\in_c{}T}
        
        % Conclusion
        \infer[template={\inserttext}]4
        [{\renewcommand{\arraystretch}{1.5}
          \begin{tabular}{l}
            $\mathrm{id}_g\notin\Delta$ \\ 
            $\mathrm{id}_g\in\mathcal{M}$\\
          \end{tabular}
        }]
        {
          $\Delta,\mathcal{M}\vdash
          \mathtt{(}\mathrm{id}_g\mathtt{,}\tau\mathtt{,}\mathrm{e}\mathtt{)}
          \xrightarrow{egens}$
          $\Delta\cup{}(id_g,(T,\mathcal{M}(\mathrm{id}_g)))$
        }
      \end{prooftree}} \\
  \end{tabular}
\end{table}%

The \textsc{GenElabDefault} states that the value of declared generic
constant is defined by its default value when no value is specified by
the dimensioning function $\mathcal{M}$.

\begin{figure}[H]
  {\fontsize{8}{11}\selectfont\textsc{GenElabDefault}}
  
  \begin{prooftree}

    % Well-formed type and elaborates type.
    \hypo{\vdash\tau\xrightarrow{etype_g}T}

    % Evaluates default value.
    \hypo{ & \vdash{}\mathrm{e}\xrightarrow{e}v}

    % Checks static expr. default value.
    \hypo{&SE_l(\mathrm{e})}    

    % Well-typed default.
    \hypo{v\in_c{}T}
    
    % Conclusion
    \infer[template={\inserttext}]4
    [{\renewcommand{\arraystretch}{1.5}
      \begin{tabular}{@{}l}
        $\mathrm{id}_g\notin\Delta$ \\
        $\mathrm{id}_g\notin\mathcal{M}$\\
      \end{tabular}
    }]
    {
      $\Delta,\mathcal{M}\vdash
      \mathtt{(}\mathrm{id}_g\mathtt{,}\tau\mathtt{,}\mathrm{e}\mathtt{)}
      \xrightarrow{egens}$
      $\Delta\cup{}(id_g,(T,v))$
    }
  \end{prooftree}
\end{figure}

\begin{figure}[H]
  {\fontsize{8}{11}\selectfont\textsc{GenElabComp}}
    
  \begin{prooftree}

    % Evaluates GE1
    \hypo{\Delta,\mathcal{M}\vdash\mathrm{gdecl}\xrightarrow{egens}{}\Delta'}

    % Evaluates GE2.
    \hypo{\Delta',\mathcal{M}\vdash\mathrm{gens}\xrightarrow{egens}{}\Delta''}

    % Conclusion
    \infer[template={\inserttext}]2{
      $\Delta,\mathcal{M}\vdash
      \mathrm{gdecl}\mathtt{,}~\mathrm{gens}
      \xrightarrow{egens}\Delta''$
    }
  \end{prooftree}
\end{figure}

% \paragraph{An example of generic clause elaboration}

% $\Delta_\emptyset, \mathcal{M}\vdash$
% \begin{tabular}{@{}l@{}}
%   $("transition\_type", \mathtt{natural}(0,2),0),$ \\
%   $("input\_conditions", \mathtt{natural}(0,\mathtt{NATMAX}),2)$ \\
% \end{tabular}
% $\xrightarrow{egens}\Delta$


% \noindent{}where
% $\mathcal{M}:=\{("transition\_type", 2),("input\_conditions",2)\}$ and

% \noindent{}\begin{tabular}{@{}rl@{}}
%   $\Delta:=\{ Gens := \{$ & $("transition\_type", (\mathtt{nat}(0,2), 2)),$ \\
%                           & $("input\_conditions", (\mathtt{nat}(0,\mathtt{NATMAX}), 2)) \} \}$ \\
% \end{tabular}

\subsection{Port clause elaboration}
\label{subsubsec:port-clause-elab}

The $eports$ relation elaborates each port declaration defined in a
design's port clause. For each port declaration, the $eports$ relation
transforms the port's type indication into a semantic type and
retrieves the implicit default value of this type. Then, the $eports$
relation adds the binding between the input (resp. output) port
identifier and its type to the $Ins$ (resp. $Outs$) sub-environment of
the elaborated design structure $\Delta$. It also adds the binding
between the input (resp. output) port identifier and its implicit
default value to the default design state $\sigma$.

\begin{premises}
  \begin{itemize}
  \item The $etype$ relation associates a type indication to its
    corresponding semantic type and checks its well-formedness (see
    Section~\ref{subsec:type-elab}).
  \item The $defaultv$ relation associates a given semantic type to
    its implicit \emph{default} value.
\end{itemize}
\end{premises}

% Elaborate IN port.

\begin{figure}[H]
  {\fontsize{8}{11}\selectfont\textsc{InPortElab}}
  
  \begin{prooftree}
        
    % Elaborates type.
    \hypo{\Delta\vdash\tau\xrightarrow{etype}T}

    % Retrieves leftmost value of type T.
    \hypo{\Delta\vdash{}T\xrightarrow{defaultv}v}
    
    % Conclusion
    \infer[template={\inserttext}]2
    [{
      \begin{tabular}{@{}l}
        $\mathrm{id}\notin\Delta$ \\
        $\mathrm{id}\notin\sigma$ \\
      \end{tabular}
    }]
    {
      $\Delta,\sigma\vdash
      ($\vhdle|in|$,\mathrm{id},\tau)$
      $\xrightarrow{eports}$
      $\Delta\cup{}(id,T),$
      $\sigma\cup(id,v)$
    }
  \end{prooftree}
\end{figure}

% Elaborate OUT port.

\begin{figure}[H]
  {\fontsize{8}{11}\selectfont\textsc{OutPortElab}}
  
  \begin{prooftree}

    % Elaborates type.
    \hypo{\Delta\vdash\tau\xrightarrow{etype}T}

    % Retrieves leftmost value of type T.
    \hypo{\Delta\vdash{}T\xrightarrow{defaultv}v}
    
    % Conclusion
    \infer[template={\inserttext}]2
    [{
      \begin{tabular}{@{}l}
        $\mathrm{id}\notin\Delta$ \\
        $\mathrm{id}\notin\sigma$ \\
      \end{tabular}
    }]
    {
      $\Delta,\sigma\vdash
      ($\vhdle|out|$,\mathrm{id},\tau)$
      $\xrightarrow{eports}$
      $\Delta\cup{}(id,T),$
      $\sigma\cup(id,v)$
    }
  \end{prooftree}
\end{figure}

% Inductive def. of port elab.

\begin{figure}[H]
  {\fontsize{8}{11}\selectfont\textsc{PortElabComp}}
  
  \begin{prooftree}

    % Evaluates PE1
    \hypo{\Delta,\sigma\vdash\mathrm{pdecl}\xrightarrow{eports}{}\Delta',\sigma'}

    % Evaluates PE2.
    \hypo{\Delta',\sigma'\vdash\mathrm{ports}\xrightarrow{eports}{}\Delta'',\sigma''}

    % Conclusion
    \infer[template={\inserttext}]2{
      $\Delta,\sigma\vdash
      \mathrm{pdecl}\mathtt{,}~\mathrm{ports}
      \xrightarrow{eports}\Delta'',\sigma''$
    }
  \end{prooftree}
\end{figure}

\subsection{Architecture declarative part elaboration}
\label{subsubsec:arch-decl-part-elab}

The $esigs$ relation elaborates each internal signal declaration
defined in the declarative part of a design's archtecture. For each
signal declaration, the $esigs$ relation transforms the signal's type
indication into a semantic type and retrieves the implicit default
value of this type. Then, the $esigs$ relation adds the binding
between the signal identifier and its type to the $Sigs$
sub-environment of the elaborated design structure $\Delta$. It also
adds the binding between the signal identifier and its implicit
default value to the default design state $\sigma$.

% Signal elaboration rule.

\begin{figure}[H]
  {\fontsize{8}{11}\selectfont\textsc{SigElab}}
  
  \begin{prooftree}

    % Elaborates type.
    \hypo{\Delta\vdash\tau\xrightarrow{etype}T}
    
    % Retrieves leftmost value of type T.
    \hypo{\Delta\vdash{}T\xrightarrow{defaultv}v}
    
    % Conclusion
    \infer[template={\inserttext}]2
    [{
      \begin{tabular}{@{}l}
        $\mathrm{id}\notin\Delta$ \\
        $\mathrm{id}\notin\sigma$ \\
      \end{tabular}
    }]
    {
      $\Delta,\sigma\vdash$
      $(\mathrm{id},\tau)$
      $\xrightarrow{esigs}$
      $\Delta\cup{}(id,T),$
      $\sigma\cup(id,v)$
    }
  \end{prooftree}
\end{figure}


% Inductive elaboration rule for sequence of decl. entries.

\begin{figure}[H]
  {\fontsize{8}{11}\selectfont\textsc{SigElabComp}}
  
  \begin{prooftree}

    % Evaluates sdecl.
    \hypo{\Delta,\sigma\vdash\mathrm{sdecl}\xrightarrow{esigs}{}\Delta',\sigma'}

    % Evaluates sigs.
    \hypo{\Delta',\sigma'\vdash\mathrm{sigs}\xrightarrow{esigs}{}\Delta'',\sigma''}

    % Conclusion
    \infer[template={\inserttext}]2{
      $\Delta,\sigma\vdash
      \mathrm{sdecl}\mathtt{,}~\mathrm{sigs}
      \xrightarrow{esigs}\Delta'',\sigma''$
    }
  \end{prooftree}
\end{figure}

\subsection{Type indication elaboration}
\label{subsec:type-elab}

The $etype$ relation checks the well-formedness of a type indication
$\tau$, and transforms it into a semantic $type$ (as defined in
Table~\ref{tab:type-value}). A type indication $\tau$ is well-formed
in the context $\Delta$ if $\tau$ denotes the \texttt{boolean} keyword
or the \texttt{nat} or \texttt{array} keywords with a
\emph{well-formed} constraint, and a well-formed element type in the
\texttt{array} case.

\begin{table}[H]
  \centering
  \begin{tabular}{@{}l}
    {\fontsize{8}{11}\selectfont\textsc{ETypeBool}} \\
    {\begin{prooftree}
        
        % Conclusion
        \infer[template={\inserttext}]0
        {
          $\Delta\vdash$
          $~\mathtt{boolean}$
          $\xrightarrow{etype}$
          $bool$
        }
      \end{prooftree}} \\
  \end{tabular}
  \begin{tabular}{@{}l}
    {\fontsize{8}{11}\selectfont\textsc{ETypeNat}} \\
    {\begin{prooftree}
        
        % Well-formed constraint and evaluates constraint.
        \hypo{
          \Delta\vdash
          (\mathrm{e},\mathrm{e}')
          \xrightarrow{econstr}
          (v,v')
        }
        
        % Conclusion
        \infer[template={\inserttext}]1
        {
          $\Delta\vdash$
          $~\mathtt{natural}(\mathrm{e},\mathrm{e}')$
          $\xrightarrow{etype}$
          $nat(v,v')$
        }
      \end{prooftree}} \\
  \end{tabular}
\end{table}

\begin{table}[H]
  \centering
  \begin{tabular}{@{}l}
    {\fontsize{8}{11}\selectfont\textsc{ETypeArray}} \\
    {\begin{prooftree}

        % Checks well-formednes and evaluates tau_ind.
        \hypo{\Delta\vdash\tau\xrightarrow{etype}T}

        % Checks well-formednes and evaluates index constraint.
        \hypo{\Delta\vdash(\mathrm{e},\mathrm{e'})\xrightarrow{econstr}(v,v')}
        
        % Conclusion
        \infer[template={\inserttext}]2
        {
          $\Delta\vdash
          ~\mathtt{array(}\tau,\mathrm{e},\mathrm{e'}\mathtt{)}$
          $\xrightarrow{etype}$
          $array(T,v,v')$
        }
      \end{prooftree}} \\
  \end{tabular}
\end{table}

The $econstr$ relation checks that a constraint is well-formed and
evaluates the constraint bounds.  A constraint is well-formed in the
context $\Delta$ if:

\begin{itemize}[label=-]
\item its bounds are globally static expressions \cite[p.36]{VHDL2000}
  of the \texttt{nat} type.
\item its lower bound value is inferior or equal to its upper bound
  value.
\end{itemize}

\begin{remark}[Type of constraints]
  As the VHDL language reference stays unclear about the type of range
  and index constraints \cite[p.33]{VHDL2000}, we add the restriction
  that range and index constraints must have bounds of the
  \texttt{nat} type (i.e. value of type $nat$).
\end{remark}

\begin{premises}
  \begin{itemize}
  \item The $\in_c$ relation states that a given value conforms to a
    given type (see Section~\ref{subsec:type-elab}).
  \item The $SE_g$ relation states that an expression is
    \emph{globally} static (see Section~\ref{subsubsec:glob-static}).
\end{itemize}
\end{premises}

\begin{table}[H]
  \centering
  \begin{tabular}{@{}l}
    {\fontsize{8}{11}\selectfont\textsc{EConstr}} \\
    {\begin{prooftree}
        
        % Globally static e and e'.
        \hypo{\Delta\vdash{}SE_g(\mathrm{e})}
        \infer[no rule]1{\Delta\vdash{}SE_g(\mathrm{e}')}
        
        % Evaluates e and e'
        \hypo{\Delta&\vdash\mathrm{e}\xrightarrow{e}v}
        \infer[no rule]1{\Delta&\vdash\mathrm{e}'\xrightarrow{e}v'}

        % Well-typed e and e'.
        \hypo{v&\in_c{}nat(0,\mathtt{NATMAX})}
        \infer[no rule]1{v'&\in_c{}nat(0,\mathtt{NATMAX})}
        
        % Conclusion
        \infer[template={\inserttext}]3
        [{
          \renewcommand{\arraystretch}{1.5}
          \begin{tabular}{@{}l}
            $v\leq{}v'$ \\
          \end{tabular}
        }]
        {
          $\Delta\vdash$
          $(\mathrm{e},\mathrm{e}')$
          $\xrightarrow{econstr}$
          $(v,v')$
        }
      \end{prooftree}} \\
  \end{tabular}
\end{table}

When considering a type indication in a generic constant declaration,
the definition of well-formedness differs slightly from the general
definition. A type indication $\tau$ associated to a generic constant
declaration is well-formed if $\tau$ denotes the \texttt{boolean}
keyword, or the \texttt{nat} keyword with a \emph{well-formed}
constraint. A generic constant can not be associated with a composite
type indication (i.e. an array type).  The $etype_g$ relation is
specially defined to check the well-formedness of a type indication
associated with a generic constant declaration.

\begin{table}[H]
  \centering
  \begin{tabular}{@{}l}
    {\fontsize{8}{11}\selectfont\textsc{ETypeGBool}} \\
    {\begin{prooftree}
        
        % Conclusion
        \infer[template={\inserttext}]0
        {
          $\vdash$
          $~\mathtt{boolean}$
          $\xrightarrow{etype}$
          $bool$
        }
      \end{prooftree}} \\
  \end{tabular}
    \begin{tabular}{@{}l}
    {\fontsize{8}{11}\selectfont\textsc{ETypeGNat}} \\
    {\begin{prooftree}
        
        % Well-formed constraint and evaluates constraint.
        \hypo{
          \Delta\vdash
          (\mathrm{e},\mathrm{e}')
          \xrightarrow{econstr_g}
          (v,v')
        }
        
        % Conclusion
        \infer[template={\inserttext}]1
        {
          $\vdash$
          $~\mathtt{natural}(\mathrm{e},\mathrm{e}')$
          $\xrightarrow{etype}$
          $nat(v,v')$
        }
      \end{prooftree}} \\
  \end{tabular}
\end{table}

The $econstr_g$ relation checks that a \emph{generic} constraint (i.e,
a constraint appearing in a type indication associated with a generic
constant declaration) is well-formed and evaluates the constraint
bounds.  A \emph{generic} constraint is well-formed if:

\begin{itemize}[label=-]
\item its bounds are locally static expressions \cite[p.36]{VHDL2000} of
  the \texttt{nat} type.
\item its lower bound value is inferior or equal to its upper bound
  value.
\end{itemize}

\begin{table}[H]
  \centering
  \begin{tabular}{@{}l}
    {\fontsize{8}{11}\selectfont\textsc{EConstrG}} \\
    {\begin{prooftree}
        
        % Locally static e and e'.
        \hypo{&SE_l(\mathrm{e})}
        \infer[no rule]1{&SE_l(\mathrm{e}')}
        
        % Evaluates e and e'
        \hypo{&\vdash\mathrm{e}\xrightarrow{e}v}
        \infer[no rule]1{&\vdash\mathrm{e}'\xrightarrow{e}v'}

        % Well-typed v and v'.
        \hypo{v&\in_c{}nat(0,\mathtt{NATMAX})}
        \infer[no rule]1{v'&\in_c{}nat(0,\mathtt{NATMAX})}
        
        % Conclusion
        \infer[template={\inserttext}]3
        [{
          \renewcommand{\arraystretch}{1.5}
          \begin{tabular}{@{}l}
            $v\leq{}v'$ \\
          \end{tabular}
        }]
        {
          $\vdash$
          $(\mathrm{e},\mathrm{e}')$
          $\xrightarrow{econstr_g}$
          $(v,v')$
        }
      \end{prooftree}} \\
  \end{tabular}
\end{table}

\subsection{Behavior elaboration}
\label{subsec:beh-elab}

The $ebeh$ relation elaborates each concurrent statement composing the
behavioral part of a design's architecture.

\subsubsection{Elaboration of concurrent statements}
\label{subsubsec:conc-elab}

The elaboration of the composition of concurrent statements is
performed in a sequential manner.

\begin{table}[H]
  \begin{tabular}{@{}l}
  {\fontsize{8}{11}\selectfont\textsc{CsParElab}} \\
  {\begin{prooftree}

    % Elaborates first conc. stmt.
    \hypo{\mathcal{D},\Delta,\sigma\vdash\mathrm{cs}\xrightarrow{ebeh}\Delta',\sigma'}

    % Elaborates second conc. stmt.
    \hypo{\mathcal{D},\Delta',\sigma'\vdash\mathrm{cs'}\xrightarrow{ebeh}\Delta'',\sigma''}
    
    % Conclusion
    \infer[template={\inserttext}]2
    {
        $\mathcal{D},\Delta,\sigma\vdash$
        $~\mathrm{cs}~||~\mathrm{cs'}$
        $\xrightarrow{ebeh}$
        $\Delta'',\sigma''$
    }
  \end{prooftree}} \\
  \end{tabular}
  \begin{tabular}{l}
    {\fontsize{8}{11}\selectfont\textsc{CsNullElab}} \\
    {\begin{prooftree}

        % Conclusion
        \infer[template={\inserttext}]0
        {
          $\mathcal{D},\Delta,\sigma\vdash$
          $~\mathtt{null}$
          $\xrightarrow{ebeh}$
          $\Delta,\sigma$
        }
      \end{prooftree}} \\
  \end{tabular}
\end{table}

\subsubsection{Process statement elaboration}
\label{subsubsec:ps-elab}

To elaborate a process statement, the $ebeh$ relation associates the
process identifier with a local environment in the $Ps$
sub-environment of $\Delta$. The $ebeh$ builds the local environment
from the process's local variable declaration list (see the $evars$
relation). The $ebeh$ relation also checks that the sequential
statements composing the body of the process are well-typed (see the
$valid_{ss}$ relation in Section~\ref{subsubsec:valid-ss}).

% Well-typed process with sensitivity list and vars.

\begin{premises}
  The $\mathtt{valid}_{ss}$ relation states that a sequential
  statement is well-typed in the context
  $\Delta,\sigma,\Lambda$. During the elaboration of a process
  contained in the behavioral part of a design, $\Delta$ represents
  the elaborated design structure being built, $\sigma$ is the default
  design state being built, and $\Lambda$ is the local variable
  environment deduced from the elaboration of the process declarative
  part.
\end{premises}

\begin{sideconds}
  $\mathrm{sl}\subseteq{}Ins(\Delta)\cup{}Sigs(\Delta)$ indicates that
  the sensitivity list \emph{sl} must only contain signal identifiers
  that are readable, that is, \emph{input} ports and declared signals.
\end{sideconds}

\begin{figure}[H]
  {\fontsize{8}{11}\selectfont\textsc{PsElab}}
  \vspace{1em}
  
  \begin{prooftree}

    % Elaborates local context.
    \hypo{\Delta,\Lambda_\emptyset\vdash\mathrm{vars}\xrightarrow{evars}\Lambda}

    % Well-typed sequential statement.
    \hypo{\Delta,\sigma,\Lambda\vdash{}\mathtt{valid}_{ss}(\mathrm{ss})}
    
    % Conclusion
    \infer[template={\inserttext}]2
    [{\renewcommand{\arraystretch}{1.5}
      \begin{tabular}{@{}l}
        $\mathrm{id}_p\notin\Delta$ \\
        $\mathrm{sl}\subseteq{}Ins(\Delta)\cup{}Sigs(\Delta)$ \\
      \end{tabular}
    }]
    {
        $\mathcal{D},\Delta,\sigma\vdash$
        $~$\vhdle|process| \texttt{(}id$_p$\texttt{,} sl\texttt{,} vars\texttt{,} ss\texttt{)}
        $\xrightarrow{ebeh}$
        $\Delta\cup{}(id_p,\Lambda),\sigma$
    }
  \end{prooftree}
\end{figure}

\subsubsection{Process declarative part elaboration}
\label{subsubsec:ps-decl-elab}

The $evars$ relation builds a local environment out of a process
declarative part.

% Variable declaration elaboration.

\begin{figure}[H]
  {\fontsize{8}{11}\selectfont\textsc{VarElab}}
  
  \begin{prooftree}
        
    % Elaborates type ind.
    \hypo{\Delta\vdash\tau\xrightarrow{etype}T}

    % Retrieves leftmost value of type T.
    \hypo{\vdash{}T\xrightarrow{defaultv}v}
    
    % Conclusion
    \infer[template={\inserttext}]2
    [
    \begin{tabular}{@{}l@{}}
      $\mathrm{id}\notin{}\Lambda$ \\
      $\mathrm{id}\notin\Delta$ \\
    \end{tabular}
    ]
    {
      $\Delta,\Lambda\vdash$
      $~(\mathrm{id},\tau)$
      $\xrightarrow{evars}$
      $\Lambda\cup{}(id,(T,v))$
    }
  \end{prooftree}
\end{figure}

% Inductive elab. rule for composition of variable declaration.

\begin{figure}[H]
  {\fontsize{8}{11}\selectfont\textsc{VarElabComp}}
  
  \begin{prooftree}

    % Evaluates VE1
    \hypo{\Delta,\Lambda\vdash\mathrm{vdecl}\xrightarrow{evars}{}\Lambda'}

    % Evaluates VE2.
    \hypo{\Delta,\Lambda'\vdash\mathrm{vars}\xrightarrow{evars}{}\Lambda''}

    % Conclusion
    \infer[template={\inserttext}]2{
      $\Delta,\Lambda\vdash
      ~\mathrm{vdecl}\mathtt{,}~\mathrm{vars}
      \xrightarrow{evars}\Lambda''$
    }
  \end{prooftree}
\end{figure}

\subsubsection{Component instantiation statement elaboration}
\label{subsubsec:comp-inst-elab}

To elaborate a component instantiation statement, the $ebeh$ relation
first builds a dimensioning function $\mathcal{M}$ out of the
component instance generic map. Then, the design associated with the
entity identifier declared by the component instance (i.e. $id_e$) is
looked up and retrieved from the design store $\mathcal{D}$.  Then,
the $ebeh$ relation appeals to the $elab$ relation to build an
elaborated version $\Delta_c$ and a default design state $\delta_c$
for the retrieved design given the specific dimensioning function
$\mathcal{M}$. Consequently, the definition of the $elab$ and $ebeh$
relations is mutually recursive.

\begin{premises}
  \begin{itemize}[label=-]
  \item The $emapg$ relation builds a function
    $\mathcal{M}\in{}generic\mhyphen{}id\nrightarrow{}value$ out of a
    generic map (see definition below).
  \item \texttt{valid}$_{ipm}$ (resp. \texttt{valid}$_{opm}$) states
    that an input port map (resp. output port map) is valid, i.e
    well-formed and well-typed (see Section~\ref{subsec:valid-pm}).
  \end{itemize}
\end{premises}

\begin{sideconds}
  $\mathcal{M}\subseteq{}Gens(\Delta_c)$ checks that
  the generic map \emph{gmap} contains references to known generic
  constant identifiers only.
\end{sideconds}

\begin{table}[H]
  \begin{tabular}{@{}l}
    {\fontsize{8}{11}\selectfont\textsc{CompElab}} \\
    {\begin{prooftree}
        
        % Creates mapping and elaborates gens.
        \hypo{\mathcal{M}_\emptyset&\vdash\mathrm{gmap}\xrightarrow{emapg}\mathcal{M}}
        
        % Elaborates design.
        \infer[no rule]1{ \mathcal{D},\mathcal{M}&\vdash
          \mathcal{D}(\mathrm{id}_e)\xrightarrow{elab}\Delta_c,\sigma_c}

        % Checks in port map validity.
        \hypo{\Delta,\Delta_c,\sigma&\vdash\mathtt{valid}_{ipm}(\mathrm{i})}

        % Checks out port map validity.
        \infer[no rule]1{\Delta,\Delta_c&\vdash\mathtt{valid}_{opm}(\mathrm{o})}
        
        % Conclusion
        \infer[template={\inserttext}]2
        [{
          \renewcommand{\arraystretch}{1.5}
          \begin{tabular}{@{}l}
            $\mathrm{id}_c\notin\Delta$, $\mathrm{id}_c\notin\sigma$ \\
            $\mathrm{id}_e\in{}\mathcal{D}$\\
            % $\mathcal{D}(\mathrm{id}_e)=$ \vhdlep{7}{9}|design| id$_{ce}$ id$_{ca}$ gens ports sigs cs \\
            $\mathcal{M}\subseteq{}Gens(\Delta_c)$ \\
          \end{tabular}
        }]
        {
          $\mathcal{D},\Delta,\sigma\vdash$
          \vhdle|comp| $(\mathrm{id}_c, \mathrm{id}_e, \mathrm{g}, \mathrm{i}, \mathrm{o})\xrightarrow{ebeh}$
          $\Delta\cup{}(id_c,\Delta_c),$
          $\sigma\cup{}(id_c,\sigma_c)$
        }
      \end{prooftree}} \\
  \end{tabular}
\end{table}

A port map is a mapping between expressions and signals coming from an
embedding design ($\Delta$) and ports of an internal component
instance ($\Delta_c$). The formal part of an port map entry (i.e, left
of the arrow) belongs to the internal component, whereas the actual
part (i.e, right of the arrow) refers to the embedding
design. Therefore, we need both $\Delta$ and $\Delta_c$ to verify if a
port map is well-typed leveraging the $\mathtt{valid}_{pm}$ predicate.

\begin{remark}[Valid generic map]
  Note that we are not checking the validity of the generic map.  In
  case of an ill-formed generic map, a inconsistent mapping
  $\mathcal{M}$ is generated by the \emph{emapg} that will make the
  \emph{elab} relation, taking $\mathcal{M}$ as a parameter, never
  derivable. Therefore, the \emph{elab} relation does an implicit
  validity check on the generic map.
\end{remark}

% Creates a mapping function from an assoc. list.

% Case formal part is not partial.

The $emap_g$ relation builds a dimensioning function out of generic
map. 

\begin{table}[H]
  \begin{tabular}{@{}l}
    {\fontsize{8}{11}\selectfont\textsc{AssocGElab}} \\
    
    {\begin{prooftree}

        % Locally static expression e.
        \hypo{SE_l(\mathrm{e})}
        
        % Evaluates e.
        \hypo{\vdash\mathrm{e}\xrightarrow{e}v}

        % Conclusion
        \infer[template={\inserttext}]2
        [$\mathrm{id}_g\notin\mathcal{M}$]
        {
          $\mathcal{M}\vdash$
          $~\mathrm{id}_g\Rightarrow\mathrm{e}$
          $\xrightarrow{emapg}$
          $\mathcal{M}\cup{}(\mathrm{id}_g,v)$
        }
      \end{prooftree}} \\
  \end{tabular}
  \begin{tabular}{@{}l}
    {\fontsize{8}{11}\selectfont\textsc{GmapElabComp}} \\
    
    {\begin{prooftree}

        % Collects assoc_g.
        \hypo{\mathcal{M}\vdash\mathrm{assoc}_g\xrightarrow{emapg}\mathcal{M}'}

        % Collects lassoc_g.
        \hypo{\mathcal{M}'\vdash\mathrm{gmap}\xrightarrow{emapg}\mathcal{M}''}

        % Conclusion
        \infer[template={\inserttext}]2
        {
          $\mathcal{M}\vdash
          \mathrm{assoc}_g,~\mathrm{gmap}$
          $\xrightarrow{emapg}\mathcal{M}''$
        }
      \end{prooftree}} \\
  \end{tabular}
\end{table}

An $\mathrm{assoc}_g$ entry doesn't allow indexed identifiers in its
formal part, due to the restriction of generic constants to scalar
types.  Note that this restriction is not imposed by the LRM. We
choose to adopt this simplification of the VHDL syntax since the case
of generic constants with composite types is never encountered in the
\hilecop{} VHDL programs.

\paragraph{Example of component instantiation statement elaboration}

The following rule describes the elaboration of the transition
component instance presented Listing~\ref{lst:t-design-ci-abss}. Here,
$\Delta$ represents the (partially-built) elaborated version of the
design that contains the transition component instance $id_t$ in its
behavior. $\sigma$ represents the (partially-built) default state of
the same embedding design. Due to the size of definitions, the generic
map (resp. the input port and output port map) of the transition
component instance $id_t$ is aliased by $\mathrm{g}_t$
(resp. $\mathrm{i}_t$ and $\mathrm{o}_t$) (see
Listing~\ref{lst:t-design-ci-abss} for the full definitions).

\begin{figure}[H]
  {\begin{prooftree}
      
      % Creates mapping and elaborates gens.
      \hypo{\mathcal{M}_\emptyset&\vdash\mathrm{g}_t\xrightarrow{emapg}\mathcal{M}}
      
      % Elaborates design.
      \infer[no rule]1{ \mathcal{D},\mathcal{M}&\vdash
        \mathcal{D}_\mathcal{H}("transition")\xrightarrow{elab}\Delta_t,\sigma_t}

      % Checks in port map validity.
      \hypo{\Delta,\Delta_t,\sigma&\vdash\mathtt{valid}_{ipm}(\mathrm{i}_t)}

      % Checks out port map validity.
      \infer[no rule]1{\Delta,\Delta_c&\vdash\mathtt{valid}_{opm}(\mathrm{o}_t)}
      
      % Conclusion
      \infer[template={\inserttext}]2
      [{
        \renewcommand{\arraystretch}{1.5}
        \begin{tabular}{@{}l}
          $\mathrm{id}_t\notin\Delta$, $\mathrm{id}_t\notin\sigma$ \\
          $"transition"\in{}\mathcal{D}_\mathcal{H}$\\
          % $\mathcal{D}(\mathrm{id}_e)=$ \vhdlep{7}{9}|design| id$_{ce}$ id$_{ca}$ gens ports sigs cs \\
          $\mathcal{M}\subseteq{}Gens(\Delta_t)$ \\
        \end{tabular}
      }]
      {
        $\mathcal{D}_\mathcal{H},\Delta,\sigma\vdash$
        \vhdle|comp| $(\mathrm{id}_t, "transition", \mathrm{g}_t, \mathrm{i}_t, \mathrm{o}_t)\xrightarrow{ebeh}$
        $\Delta\cup{}(id_t,\Delta_t),$
        $\sigma\cup{}(id_t,\sigma_t)$
      }
    \end{prooftree}}
\end{figure}

\noindent{}where:

\begin{itemize}
\item $\mathcal{M}:=$
  \begin{tabular}{@{}l@{}}
    $\{("transition\_type",0),$\\
    $("input\_arcs\_number", 1),$ \\
    $("conditions\_number", 1),$\\
    $("maximal\_time\_counter",1)\}$\\
  \end{tabular}
\item $\mathcal{D}_\mathcal{H}("transition"):=$ \texttt{design}
  "transition" "transition\_architecture" $gens_t$ $ports_t$ $sigs_t$
  $cs_t$
\item $Gens(\Delta_t):=$
  \begin{tabular}{@{}l@{}}
    $\{("transition\_type", nat(0,2)),$ \\
    $("input\_arcs\_number", nat(0,\mathtt{NATMAX})),$ \\
    $("conditions\_number", nat(0,\mathtt{NATMAX})),$ \\
    $("maximal\_time\_counter", nat(0,\mathtt{NATMAX}))\}$ \\
  \end{tabular}
\end{itemize}

Then, the transition design declaration is retrieved from the design
store $\mathcal{D}_\mathcal{H}$, which is the specific \hilecop{}
design store. By definition, the \hilecop{} design store maps the
transition and the place identifiers to their corresponding design
declaration (the side condition
$"transition"\in\mathcal{D}_\mathcal{H}$ is true). Then, the $elab$
relation builds the elaborated design $\Delta_t$ and the default
design state $\sigma_t$ from the transition design declaration given
the dimensioning function $\mathcal{M}$. We do not detail the content
of $\Delta_t$ and $\sigma_t$ as it is really close to the content of
Figures~\ref{fig:elab-version-of-t} and
\ref{fig:default-state-of-t}. Finally, a mapping between the
identifier $id_t$ and $\Delta_t$ is added to the $Comps$
sub-environment of $\Delta$, i.e. $\Delta\cup{}(id_t,\Delta_t)$. Also,
a mapping between the identifier $id_t$ and the default state
$\sigma_t$ is added to the component store $\mathcal{C}$ of $\sigma$,
i.e. $\sigma\cup{}(id_t,\sigma_t)$.

\subsection{Implicit default value}
\label{subsec:implicit-default-v}

According to the VHDL reference, when declaring a port, a signal or a
variable, these items must receive an implicit default value depending
on their types \cite[p.61, 64, 173]{VHDL2000}. The $defaultv$ relation
determines the default value for a given type.

\begin{table}[H]
  \centering
  \begin{tabular}{@{}l}
    {\fontsize{10}{13}\selectfont\textsc{DefaultVBool}} \\
    {\begin{prooftree}

        % Conclusion
        \infer[template={\inserttext}]0
        {
          $\mathtt{bool}$
          $\xrightarrow{defaultv}\bot$
        }
      \end{prooftree}} \\
  \end{tabular}
  \begin{tabular}{@{}l}
    {\fontsize{10}{13}\selectfont\textsc{DefaultVCNat}} \\
    {\begin{prooftree}

        % Conclusion
        \infer[template={\inserttext}]0
        [$n\le{}m$]
        {
          $nat(n,m)$
          $\xrightarrow{defaultv}n$
        }
      \end{prooftree}} \\
  \end{tabular}
\end{table}

\begin{table}[H]
  \centering
  \begin{tabular}{@{}l}
    {\fontsize{10}{13}\selectfont\textsc{DefaultVCArr}} \\
    {\begin{prooftree}

        % Retrieves default value for element subtype.
        \hypo{T\xrightarrow{defaultv}v}
        
        % Conclusion
        \infer[template={\inserttext}]1
        [
        \begin{tabular}{@{}l}
          $n\le{}m$ \\
          $size=(m-n)+1$ \\
        \end{tabular}
        ]
        {
          $array(T,n,m)$
          $\xrightarrow{defaultv}$
          $\mathtt{create\_array}(size,T,v)$
        }
      \end{prooftree}} \\
  \end{tabular}
\end{table}

$\mathtt{create\_array}(size,T,v)$ creates an array of size $size$,
containing elements of type $T$, where each element is initialized
with the value $v$.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../main"
%%% End:
