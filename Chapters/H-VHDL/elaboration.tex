The goal of the elaboration phase is to build an elaborated design
$\Delta$ along with a \emph{default} state $\sigma_e$ out of a
\hvhdl{} design $d$ and for a given design store $\mathcal{D}$. The
elaboration relation performs type-checking operations over the
declarative and behavioral parts of the design. Even though the
elaboration of a design is described in the LRM, the formalization of
this phase has been performed in few works only
\cite{Borrione1995,Deharbe1995,VanTassel1995}, and never in a setting
that covers both syntactical well-formedness and type-checking of the
designs.  We are interested in the formalization of the elaboration
phase because we are interested in the \textit{well-formedness} of the
programs generated by the \hilecop{} transformation. Here, the term
well-formedness refers to a syntactically valid design, w.r.t. the
syntactic rules of the \vhdl{} language, and to a well-typed design,
w.r.t. the typing rules defined in the LRM. Formalizing the
elaboration phase is also a way to define how the runtime environment
and the runtime state of the simulation are built. For now, we haven't
tackle down the proof that the \hvhdl{} designs generated by
\hilecop{} are elaborable, i.e. syntactically well-formed and
well-typed. As explained in Chapter~\ref{chap:proof}, this task is
foreseen in our work perspectives. In our own formalization of the
elaboration phase, and contrary to what is prescribed by the LRM
\cite[p. 166]{VHDL2000}, we are not dealing with the transformation of
the component instantiation statements into block statements. We
prefer to preserve the hierarchical structure of the design (i.e. its
composite structure) during its elaboration. We argue that dealing
with component instantiation statements instead of block statements
does not complexify the semantics of the \hvhdl{} simulation rules.

In the following sections, the green frames give additional
explanations about the premises of the rule instances; the red frames
bring additional explanations about the side conditions of the rules.

\subsection{Design elaboration}
\label{subsubsec:design-elab}

One way to define a design's behavior is through the instantiation of
subcomponents which are instances of other designs. Each component
instance declares the entity identifier that points out to the
specific design being instantiated. Therefore, for each instantiation,
the associated design must be known through the definition of a global
design declaration environment called a \emph{design store}. A design
store is defined as follows:

\begin{definition}[Design store]
  \label{def:design-store}
  A design store
  $\mathcal{D}\in{}entity\mhyphen{}id\rightarrow{}\mathrm{design}$ is
  a function mapping design identifiers (i.e. the entity identifier of
  designs) to their corresponding representation in abstract
  syntax. As a prerequisite to the elaboration of \hilecop{}-generated
  designs (i.e, resulting from the transformation of a SITPN into an
  \hvhdl{} design), a particular design store
  $\mathcal{D}_\mathcal{H}$ is defined.  Design store
  $\mathcal{D}_\mathcal{H}$ binds the \texttt{transition} and
  \texttt{place} identifiers to the definition of the \texttt{place}
  and \texttt{transition} designs in \hvhdl{} abstract syntax:

  {\fontsize{11}{13}\selectfont
  \begin{tabular}{@{}ll@{}}

    $\mathcal{D}_\mathcal{H}:=$ & $\{(\mathtt{transition}, \mathtt{design}~\mathtt{transition}~\mathtt{transition\_architecture}~gens_t~ports_t~sigs_t~cs_t),$ \\
                                & $(\mathtt{place}, \mathtt{design}~\mathtt{place}~\mathtt{place\_architecture}~gens_p~ports_p~sigs_p~cs_p)\}$ \\
  \end{tabular}}\\

  The full definition of the \texttt{place} and \texttt{transition}
  designs in abstract syntax are given in
  Appendices~\ref{app:place-design} and \ref{app:trans-design}.
\end{definition}

At the beginning of the elaboration phase, a function
$\mathcal{M}_g\in{}generic\mhyphen{}id\nrightarrow{}value$ mapping the
top-level design's generic constants to values is passed as an element
of the environment. The $\mathcal{M}_g$ function is refered to as the
\emph{dimensioning} function. \\

Rule~\textsc{DesignElab} defines the design elaboration relation. It
relates an \hvhdl{} design to its resulting elaborated version and
default design state that were built in the context of the design
store $\mathcal{D}$ and the dimensioning function $\mathcal{M}_g$.

\begin{table}[H]
  \centering
  \begin{tabular}{@{}l}
    {\fontsize{8}{11}\selectfont\textsc{DesignElab}} \\    
    {\begin{prooftree}[template={\fontsize{11}{13}\selectfont$\inserttext$}, separation=10pt]

        % Elaborates gens, ports, sigs and cs.

        \hypo{\Delta_{\emptyset},\mathcal{M}_g\vdash{}\mathrm{gens}\xrightarrow{egens}\Delta}
        \hypo{\Delta,\sigma_\emptyset\vdash{}
          \mathrm{ports}\xrightarrow{eports}\Delta',\sigma}
        \hypo{\Delta',\sigma\vdash{}\mathrm{sigs}\xrightarrow{esigs}\Delta'',\sigma'}
        \hypo{\mathcal{D},\Delta'',\sigma'\vdash
          \mathrm{cs}\xrightarrow{ebeh}\Delta''',\sigma''}
        
        % Conclusion        
        \infer[template={\fontsize{12}{14}\selectfont\inserttext}]4
        {
          $\mathcal{D},\mathcal{M}_g\vdash$
          \vhdle|design| id$_e$ id$_a$ gens ports sigs cs
          $\xrightarrow{elab}$
          $\Delta''',\sigma''$
        }
      \end{prooftree}} \\
  \end{tabular}
\end{table}

$\Delta_\emptyset$ denotes an empty elaborated design, that is an
elaborated design initialized with empty fields (empty tables). In the
same manner, $\sigma_\emptyset$ denotes an empty design state.  The
effect of the $egens$, $eports$, $esigs$ and $ebeh$ relations that
respectively deal with the elaboration of the generic constants, the
ports, the architecture declarative part and the behavioral part of
the design, are explicited in the following sections.

\subsection{Generic clause elaboration}
\label{subsubsec:gen-clause-elab}

The \textit{egens} relation elaborates the list of generic constant
declarations, i.e. the generic clause of a design declaration. The
\textit{egens} relation is defined through the \textsc{GenElabDimen},
\textsc{GenElabDefault} and \textsc{GenElabComp} rules. The
elaboration of a generic constant declaration consists in:

\begin{enumerate}
\item Transforming the type indication associated with the constant
  into a semantic type.
\item Checking that the default value, and/or the value associated
  with the constant in the dimensioning function, is well-typed.
\item Adding the couple constant identifier and \textit{(type,value)}
  to the $Gens$ sub-environment of $\Delta$.
\end{enumerate}

\begin{premises}
  \begin{itemize}[label=-]
  \item $etype_g$ transforms a type indication, specifically attached
    to a generic constant declaration, into a $type$ instance and
    checks its well-formedness (see Section~\ref{subsec:type-elab}).
  \item The $e$ relation links an expression $e$ to its value $v$ in a
    given context (see Section~\ref{subsec:expr-rules}). The context
    of evaluation for an expression is composed of a given elaborated
    design, a given design state, and given local environment. We omit
    the thesis symbol and symbols at the left of the thesis when they
    refer to empty structures. For instance,
    $\mathrm{e}\xrightarrow{e}v$ is a notation for
    $\Delta_\emptyset,\sigma_\emptyset,\Lambda_\emptyset\vdash
    \mathrm{e}\xrightarrow{e}v$.
  \item $SE_l$ states that an expression is $locally$ static (see
    Section~\ref{subsubsec:loc-static}).
  \item $v\in_c{}T$ and $\mathcal{M}(\mathrm{id}_g)\in_c{}T$ checks
    that the default value and the value yielded by the dimensioning
    function belongs to the type of the declared generic constant (see
    Section~\ref{subsec:constr-satif-rel}).
  \end{itemize}  
\end{premises}

\begin{sideconds}
  The expression $id_g\notin\Delta$ checks that the generic constant
  identifier $id_g$ is not already defined in the domain of one
  sub-environment of the elaborated design $\Delta$.
\end{sideconds}

\begin{table}[H]
  \begin{tabular}{@{}l}
    {\fontsize{8}{11}\selectfont\textsc{GenElabDimen}} \\
    {\begin{prooftree}

        % Well-formed type and elaborates type.
        \hypo{\vdash\tau\xrightarrow{etype_g}T}
        
        % Evaluates expr. default.
        \hypo{&\mathrm{e}\xrightarrow{e}v}

        % Checks static expr. default
        \hypo{&SE_l(\mathrm{e})}

        % Checks the type of the value yielded by the dimensioning fun.
        \hypo{v&\in_c{}T}
        \infer[no rule]1{\mathcal{M}(\mathrm{id}_g)&\in_c{}T}
        
        % Conclusion
        \infer[template={\inserttext}]4
        [{\renewcommand{\arraystretch}{1.5}
          \begin{tabular}{l}
            $\mathrm{id}_g\notin\Delta$ \\ 
            $\mathrm{id}_g\in\mathcal{M}$\\
          \end{tabular}
        }]
        {
          $\Delta,\mathcal{M}\vdash
          \mathtt{(}\mathrm{id}_g\mathtt{,}\tau\mathtt{,}\mathrm{e}\mathtt{)}
          \xrightarrow{egens}$
          $\Delta\cup{}(id_g,(T,\mathcal{M}(\mathrm{id}_g)))$
        }
      \end{prooftree}} \\
  \end{tabular}
\end{table}%

The \textsc{GenElabDefault} rule states that the value of a generic
constant is defined by its type's default implicit value when no value
is specified by the dimensioning function $\mathcal{M}$.

\begin{figure}[H]
  {\fontsize{8}{11}\selectfont\textsc{GenElabDefault}}
  
  \begin{prooftree}

    % Well-formed type and elaborates type.
    \hypo{\vdash\tau\xrightarrow{etype_g}T}

    % Evaluates default value.
    \hypo{ & \vdash{}\mathrm{e}\xrightarrow{e}v}

    % Checks static expr. default value.
    \hypo{&SE_l(\mathrm{e})}    

    % Well-typed default.
    \hypo{v\in_c{}T}
    
    % Conclusion
    \infer[template={\inserttext}]4
    [{\renewcommand{\arraystretch}{1.5}
      \begin{tabular}{@{}l}
        $\mathrm{id}_g\notin\Delta$ \\
        $\mathrm{id}_g\notin\mathcal{M}$\\
      \end{tabular}
    }]
    {
      $\Delta,\mathcal{M}\vdash
      \mathtt{(}\mathrm{id}_g\mathtt{,}\tau\mathtt{,}\mathrm{e}\mathtt{)}
      \xrightarrow{egens}$
      $\Delta\cup{}(id_g,(T,v))$
    }
  \end{prooftree}
\end{figure}

\begin{figure}[H]
  {\fontsize{8}{11}\selectfont\textsc{GenElabComp}}
    
  \begin{prooftree}

    % Evaluates GE1
    \hypo{\Delta,\mathcal{M}\vdash\mathrm{gdecl}\xrightarrow{egens}{}\Delta'}

    % Evaluates GE2.
    \hypo{\Delta',\mathcal{M}\vdash\mathrm{gens}\xrightarrow{egens}{}\Delta''}

    % Conclusion
    \infer[template={\inserttext}]2{
      $\Delta,\mathcal{M}\vdash
      \mathrm{gdecl}\mathtt{,}~\mathrm{gens}
      \xrightarrow{egens}\Delta''$
    }
  \end{prooftree}
\end{figure}

% \paragraph{An example of generic clause elaboration}

% $\Delta_\emptyset, \mathcal{M}\vdash$
% \begin{tabular}{@{}l@{}}
%   $("transition\_type", \mathtt{natural}(0,2),0),$ \\
%   $("input\_conditions", \mathtt{natural}(0,\mathtt{NATMAX}),2)$ \\
% \end{tabular}
% $\xrightarrow{egens}\Delta$


% \noindent{}where
% $\mathcal{M}:=\{("transition\_type", 2),("input\_conditions",2)\}$ and

% \noindent{}\begin{tabular}{@{}rl@{}}
%   $\Delta:=\{ Gens := \{$ & $("transition\_type", (\mathtt{nat}(0,2), 2)),$ \\
%                           & $("input\_conditions", (\mathtt{nat}(0,\mathtt{NATMAX}), 2)) \} \}$ \\
% \end{tabular}

\subsection{Port clause elaboration}
\label{subsubsec:port-clause-elab}

The $eports$ relation elaborates each port declaration defined in a
design's port clause. For each port declaration, the $eports$ relation
transforms the port's type indication into a semantic type and
retrieves the implicit default value of this type. Then, the $eports$
relation adds the binding between the input (resp. output) port
identifier and its type to the $Ins$ (resp. $Outs$) sub-environment of
the elaborated design structure $\Delta$. It also adds the binding
between the input (resp. output) port identifier and its implicit
default value to the default design state $\sigma$.

\begin{premises}
  \begin{itemize}
  \item The $etype$ relation associates a type indication to its
    corresponding semantic type and checks its well-formedness (see
    Section~\ref{subsec:type-elab}).
  \item The $defaultv$ relation associates a given semantic type to
    its implicit \emph{default} value.
\end{itemize}
\end{premises}

\begin{sideconds}
  The expression $\mathrm{id}\notin\sigma$ checks that the identifier
  $id$ is not already defined in the domain of the signal store or the
  component store of the design state $\sigma$. It is a shorthand
  notation to
  $\mathrm{id}\notin\mathtt{dom}(\mathcal{S})\cup\mathtt{dom}(\mathcal{C})$
  where $\sigma={<}\mathcal{S},\mathcal{C},\mathcal{E}{>}$.
  
\end{sideconds}

% Elaborate IN port.

\begin{figure}[H]
  {\fontsize{8}{11}\selectfont\textsc{InPortElab}}
  
  \begin{prooftree}
        
    % Elaborates type.
    \hypo{\Delta\vdash\tau\xrightarrow{etype}T}

    % Retrieves leftmost value of type T.
    \hypo{\Delta\vdash{}T\xrightarrow{defaultv}v}
    
    % Conclusion
    \infer[template={\inserttext}]2
    [{
      \begin{tabular}{@{}l}
        $\mathrm{id}\notin\Delta$ \\
        $\mathrm{id}\notin\sigma$ \\
      \end{tabular}
    }]
    {
      $\Delta,\sigma\vdash
      ($\vhdle|in|$,\mathrm{id},\tau)$
      $\xrightarrow{eports}$
      $\Delta\cup{}(id,T),$
      $\sigma\cup(id,v)$
    }
  \end{prooftree}
\end{figure}

% Elaborate OUT port.

\begin{figure}[H]
  {\fontsize{8}{11}\selectfont\textsc{OutPortElab}}
  
  \begin{prooftree}

    % Elaborates type.
    \hypo{\Delta\vdash\tau\xrightarrow{etype}T}

    % Retrieves leftmost value of type T.
    \hypo{\Delta\vdash{}T\xrightarrow{defaultv}v}
    
    % Conclusion
    \infer[template={\inserttext}]2
    [{
      \begin{tabular}{@{}l}
        $\mathrm{id}\notin\Delta$ \\
        $\mathrm{id}\notin\sigma$ \\
      \end{tabular}
    }]
    {
      $\Delta,\sigma\vdash
      ($\vhdle|out|$,\mathrm{id},\tau)$
      $\xrightarrow{eports}$
      $\Delta\cup{}(id,T),$
      $\sigma\cup(id,v)$
    }
  \end{prooftree}
\end{figure}

% Inductive def. of port elab.

\begin{figure}[H]
  {\fontsize{8}{11}\selectfont\textsc{PortElabComp}}
  
  \begin{prooftree}

    % Evaluates PE1
    \hypo{\Delta,\sigma\vdash\mathrm{pdecl}\xrightarrow{eports}{}\Delta',\sigma'}

    % Evaluates PE2.
    \hypo{\Delta',\sigma'\vdash\mathrm{ports}\xrightarrow{eports}{}\Delta'',\sigma''}

    % Conclusion
    \infer[template={\inserttext}]2{
      $\Delta,\sigma\vdash
      \mathrm{pdecl}\mathtt{,}~\mathrm{ports}
      \xrightarrow{eports}\Delta'',\sigma''$
    }
  \end{prooftree}
\end{figure}

\subsection{Architecture declarative part elaboration}
\label{subsubsec:arch-decl-part-elab}

The $esigs$ relation elaborates each internal signal declaration
defined in the declarative part of a design's architecture. For each
signal declaration, the $esigs$ relation transforms the signal's type
indication into a semantic type and retrieves the implicit default
value of this type. Then, the $esigs$ relation adds the binding
between the signal identifier and its type to the $Sigs$
sub-environment of the elaborated design structure $\Delta$. It also
adds the binding between the signal identifier and its implicit
default value to the default design state $\sigma$.

% Signal elaboration rule.

\begin{figure}[H]
  {\fontsize{8}{11}\selectfont\textsc{SigElab}}
  
  \begin{prooftree}

    % Elaborates type.
    \hypo{\Delta\vdash\tau\xrightarrow{etype}T}
    
    % Retrieves leftmost value of type T.
    \hypo{\Delta\vdash{}T\xrightarrow{defaultv}v}
    
    % Conclusion
    \infer[template={\inserttext}]2
    [{
      \begin{tabular}{@{}l}
        $\mathrm{id}\notin\Delta$ \\
        $\mathrm{id}\notin\sigma$ \\
      \end{tabular}
    }]
    {
      $\Delta,\sigma\vdash$
      $(\mathrm{id},\tau)$
      $\xrightarrow{esigs}$
      $\Delta\cup{}(id,T),$
      $\sigma\cup(id,v)$
    }
  \end{prooftree}
\end{figure}


% Inductive elaboration rule for sequence of decl. entries.

\begin{figure}[H]
  {\fontsize{8}{11}\selectfont\textsc{SigElabComp}}
  
  \begin{prooftree}

    % Evaluates sdecl.
    \hypo{\Delta,\sigma\vdash\mathrm{sdecl}\xrightarrow{esigs}{}\Delta',\sigma'}

    % Evaluates sigs.
    \hypo{\Delta',\sigma'\vdash\mathrm{sigs}\xrightarrow{esigs}{}\Delta'',\sigma''}

    % Conclusion
    \infer[template={\inserttext}]2{
      $\Delta,\sigma\vdash
      \mathrm{sdecl}\mathtt{,}~\mathrm{sigs}
      \xrightarrow{esigs}\Delta'',\sigma''$
    }
  \end{prooftree}
\end{figure}

\subsection{Type indication elaboration}
\label{subsec:type-elab}

The $etype$ relation checks the well-formedness of a type indication
$\tau$, and transforms it into a semantic $type$ (as defined in
Table~\ref{tab:type-value}). A type indication $\tau$ is well-formed
in the context $\Delta$ if $\tau$ denotes the \texttt{boolean} keyword
or the \texttt{natural} or \texttt{array} keywords with a
\emph{well-formed} constraint, and a well-formed element type in the
\texttt{array} case.

\begin{table}[H]
  \centering
  \begin{tabular}{@{}l}
    {\fontsize{8}{11}\selectfont\textsc{ETypeBool}} \\
    {\begin{prooftree}
        
        % Conclusion
        \infer[template={\inserttext}]0
        {
          $\Delta\vdash$
          $~\mathtt{boolean}$
          $\xrightarrow{etype}$
          $bool$
        }
      \end{prooftree}} \\
  \end{tabular}
  \begin{tabular}{@{}l}
    {\fontsize{8}{11}\selectfont\textsc{ETypeNat}} \\
    {\begin{prooftree}
        
        % Well-formed constraint and evaluates constraint.
        \hypo{
          \Delta\vdash
          (\mathrm{e},\mathrm{e}')
          \xrightarrow{econstr}
          (v,v')
        }
        
        % Conclusion
        \infer[template={\inserttext}]1
        {
          $\Delta\vdash$
          $~\mathtt{natural}(\mathrm{e},\mathrm{e}')$
          $\xrightarrow{etype}$
          $nat(v,v')$
        }
      \end{prooftree}} \\
  \end{tabular}
\end{table}

\begin{table}[H]
  \centering
  \begin{tabular}{@{}l}
    {\fontsize{8}{11}\selectfont\textsc{ETypeArray}} \\
    {\begin{prooftree}

        % Checks well-formednes and evaluates tau_ind.
        \hypo{\Delta\vdash\tau\xrightarrow{etype}T}

        % Checks well-formednes and evaluates index constraint.
        \hypo{\Delta\vdash(\mathrm{e},\mathrm{e'})\xrightarrow{econstr}(v,v')}
        
        % Conclusion
        \infer[template={\inserttext}]2
        {
          $\Delta\vdash
          ~\mathtt{array(}\tau,\mathrm{e},\mathrm{e'}\mathtt{)}$
          $\xrightarrow{etype}$
          $array(T,v,v')$
        }
      \end{prooftree}} \\
  \end{tabular}
\end{table}

The $econstr$ relation checks that a constraint is well-formed and
evaluates the constraint bounds.  A constraint is well-formed in the
context $\Delta$ if:

\begin{itemize}[label=-]
\item its bounds are globally static expressions \cite[p.36]{VHDL2000}
  conforming to the $nat(0,\mathtt{NATMAX})$ type after evaluation.
\item its lower bound value is inferior or equal to its upper bound
  value.
\end{itemize}

\begin{remark}[Type of constraints]
  As the \vhdl{} language reference stays unclear about the type of range
  and index constraints \cite[p.33]{VHDL2000}, we add the restriction
  that range and index constraints must have bounds of the
  $nat(0,\mathtt{NATMAX})$ type, i.e. the interval of natural numbers
  representable with the \vhdl{} language.
\end{remark}

\begin{premises}
  \begin{itemize}
  \item The $\in_c$ relation states that a given value conforms to a
    given type (see Section~\ref{sec:constr-satif-rel}).
  \item The $SE_g$ relation states that an expression is
    \emph{globally} static (see Section~\ref{subsubsec:glob-static}).
\end{itemize}
\end{premises}

\begin{table}[H]
  \centering
  \begin{tabular}{@{}l}
    {\fontsize{8}{11}\selectfont\textsc{EConstr}} \\
    {\begin{prooftree}
        
        % Globally static e and e'.
        \hypo{\Delta\vdash{}SE_g(\mathrm{e})}
        \infer[no rule]1{\Delta\vdash{}SE_g(\mathrm{e}')}
        
        % Evaluates e and e'
        \hypo{\Delta&\vdash\mathrm{e}\xrightarrow{e}v}
        \infer[no rule]1{\Delta&\vdash\mathrm{e}'\xrightarrow{e}v'}

        % Well-typed e and e'.
        \hypo{v&\in_c{}nat(0,\mathtt{NATMAX})}
        \infer[no rule]1{v'&\in_c{}nat(0,\mathtt{NATMAX})}
        
        % Conclusion
        \infer[template={\inserttext}]3
        [{
          \renewcommand{\arraystretch}{1.5}
          \begin{tabular}{@{}l}
            $v\leq{}v'$ \\
          \end{tabular}
        }]
        {
          $\Delta\vdash$
          $(\mathrm{e},\mathrm{e}')$
          $\xrightarrow{econstr}$
          $(v,v')$
        }
      \end{prooftree}} \\
  \end{tabular}
\end{table}

When considering a type indication in a generic constant declaration,
the definition of well-formedness differs slightly from the general
definition. A type indication $\tau$ associated to a generic constant
declaration is well-formed if $\tau$ denotes the \texttt{boolean}
keyword, or the \texttt{natural} keyword with a \emph{well-formed}
constraint. A generic constant can not be associated with a composite
type indication (i.e. an \texttt{array} type).  The $etype_g$ relation
is specially defined to check the well-formedness of a type indication
associated with a generic constant declaration.

\begin{table}[H]
  \centering
  \begin{tabular}{@{}l}
    {\fontsize{8}{11}\selectfont\textsc{ETypeGBool}} \\
    {\begin{prooftree}
        
        % Conclusion
        \infer[template={\inserttext}]0
        {
          $\vdash$
          $~\mathtt{boolean}$
          $\xrightarrow{etype}$
          $bool$
        }
      \end{prooftree}} \\
  \end{tabular}
    \begin{tabular}{@{}l}
    {\fontsize{8}{11}\selectfont\textsc{ETypeGNat}} \\
    {\begin{prooftree}
        
        % Well-formed constraint and evaluates constraint.
        \hypo{
          \Delta\vdash
          (\mathrm{e},\mathrm{e}')
          \xrightarrow{econstr_g}
          (v,v')
        }
        
        % Conclusion
        \infer[template={\inserttext}]1
        {
          $\vdash$
          $~\mathtt{natural}(\mathrm{e},\mathrm{e}')$
          $\xrightarrow{etype}$
          $nat(v,v')$
        }
      \end{prooftree}} \\
  \end{tabular}
\end{table}

The $econstr_g$ relation checks that a \emph{generic} constraint (i.e,
a constraint appearing in a type indication associated with a generic
constant declaration) is well-formed and evaluates the constraint
bounds.  A \emph{generic} constraint is well-formed if:

\begin{itemize}[label=-]
\item its bounds are locally static expressions \cite[p.36]{VHDL2000}
  conforming to the $nat(0,\mathtt{NATMAX})$ type after evaluation.
\item its lower bound value is inferior or equal to its upper bound
  value.
\end{itemize}

\begin{table}[H]
  \centering
  \begin{tabular}{@{}l}
    {\fontsize{8}{11}\selectfont\textsc{EConstrG}} \\
    {\begin{prooftree}
        
        % Locally static e and e'.
        \hypo{&SE_l(\mathrm{e})}
        \infer[no rule]1{&SE_l(\mathrm{e}')}
        
        % Evaluates e and e'
        \hypo{&\vdash\mathrm{e}\xrightarrow{e}v}
        \infer[no rule]1{&\vdash\mathrm{e}'\xrightarrow{e}v'}

        % Well-typed v and v'.
        \hypo{v&\in_c{}nat(0,\mathtt{NATMAX})}
        \infer[no rule]1{v'&\in_c{}nat(0,\mathtt{NATMAX})}
        
        % Conclusion
        \infer[template={\inserttext}]3
        [{
          \renewcommand{\arraystretch}{1.5}
          \begin{tabular}{@{}l}
            $v\leq{}v'$ \\
          \end{tabular}
        }]
        {
          $\vdash$
          $(\mathrm{e},\mathrm{e}')$
          $\xrightarrow{econstr_g}$
          $(v,v')$
        }
      \end{prooftree}} \\
  \end{tabular}
\end{table}

\subsection{Behavior elaboration}
\label{subsec:beh-elab}

The $ebeh$ relation elaborates each concurrent statement composing the
behavioral part of a design.

\subsubsection{Elaboration of concurrent statements}
\label{subsubsec:conc-elab}

The elaboration of the composition of concurrent statements is
performed in a sequential manner.

\begin{table}[H]
  \begin{tabular}{@{}l}
  {\fontsize{8}{11}\selectfont\textsc{CsParElab}} \\
  {\begin{prooftree}

    % Elaborates first conc. stmt.
    \hypo{\mathcal{D},\Delta,\sigma\vdash\mathrm{cs}\xrightarrow{ebeh}\Delta',\sigma'}

    % Elaborates second conc. stmt.
    \hypo{\mathcal{D},\Delta',\sigma'\vdash\mathrm{cs'}\xrightarrow{ebeh}\Delta'',\sigma''}
    
    % Conclusion
    \infer[template={\inserttext}]2
    {
        $\mathcal{D},\Delta,\sigma\vdash$
        $~\mathrm{cs}~||~\mathrm{cs'}$
        $\xrightarrow{ebeh}$
        $\Delta'',\sigma''$
    }
  \end{prooftree}} \\
  \end{tabular}
  \begin{tabular}{l}
    {\fontsize{8}{11}\selectfont\textsc{CsNullElab}} \\
    {\begin{prooftree}

        % Conclusion
        \infer[template={\inserttext}]0
        {
          $\mathcal{D},\Delta,\sigma\vdash$
          $~\mathtt{null}$
          $\xrightarrow{ebeh}$
          $\Delta,\sigma$
        }
      \end{prooftree}} \\
  \end{tabular}
\end{table}

\subsubsection{Process statement elaboration}
\label{subsubsec:ps-elab}

To elaborate a process statement, the $ebeh$ relation associates the
process identifier with a local environment in the $Ps$
sub-environment of $\Delta$. The $ebeh$ builds the local environment
based on the process's local variable declaration list (see the
$evars$ relation). The $ebeh$ relation also checks that the sequential
statements composing the body of the process are well-typed (see the
$valid_{ss}$ relation in Section~\ref{subsubsec:valid-ss}).

% Well-typed process with sensitivity list and vars.

\begin{premises}
  The $\mathtt{valid}_{ss}$ relation states that a sequential
  statement is well-typed in the context $\Delta,\sigma,\Lambda$,
  where $\Lambda$ is the local variable environment deduced from the
  elaboration of the process declarative part.
\end{premises}

\begin{sideconds}
  $\mathrm{sl}\subseteq{}Ins(\Delta)\cup{}Sigs(\Delta)$ indicates that
  the sensitivity list sl must only contain \textit{readable} signal
  identifiers, that is, input ports and internal signals.
\end{sideconds}

\begin{figure}[H]
  {\fontsize{8}{11}\selectfont\textsc{PsElab}}
  \vspace{1em}
  
  \begin{prooftree}

    % Elaborates local context.
    \hypo{\Delta,\Lambda_\emptyset\vdash\mathrm{vars}\xrightarrow{evars}\Lambda}

    % Well-typed sequential statement.
    \hypo{\Delta,\sigma,\Lambda\vdash{}\mathtt{valid}_{ss}(\mathrm{ss})}
    
    % Conclusion
    \infer[template={\inserttext}]2
    [{\renewcommand{\arraystretch}{1.5}
      \begin{tabular}{@{}l}
        $\mathrm{id}_p\notin\Delta$ \\
        $\mathrm{sl}\subseteq{}Ins(\Delta)\cup{}Sigs(\Delta)$ \\
      \end{tabular}
    }]
    {
        $\mathcal{D},\Delta,\sigma\vdash$
        $~$\vhdle|process| \texttt{(}id$_p$\texttt{,} sl\texttt{,} vars\texttt{,} ss\texttt{)}
        $\xrightarrow{ebeh}$
        $\Delta\cup{}(id_p,\Lambda),\sigma$
    }
  \end{prooftree}
\end{figure}

\subsubsection{Process declarative part elaboration}
\label{subsubsec:ps-decl-elab}

The $evars$ relation builds a local environment out of a process
declarative part. For each local variable declaration, the $evars$
transforms the type indication associated with the variable identifier
into a semantic type and retrieves the implicit default value of this
type. Then, the $evars$ relation adds the binding between the variable
identifier, and the couple \textit{(type,value)} to the local
environment $\Lambda$.

% Variable declaration elaboration.

\begin{figure}[H]
  {\fontsize{8}{11}\selectfont\textsc{VarElab}}
  
  \begin{prooftree}
        
    % Elaborates type ind.
    \hypo{\Delta\vdash\tau\xrightarrow{etype}T}

    % Retrieves leftmost value of type T.
    \hypo{\vdash{}T\xrightarrow{defaultv}v}
    
    % Conclusion
    \infer[template={\inserttext}]2
    [
    \begin{tabular}{@{}l@{}}
      $\mathrm{id}\notin{}\Lambda$ \\
      $\mathrm{id}\notin\Delta$ \\
    \end{tabular}
    ]
    {
      $\Delta,\Lambda\vdash$
      $~(\mathrm{id},\tau)$
      $\xrightarrow{evars}$
      $\Lambda\cup{}(id,(T,v))$
    }
  \end{prooftree}
\end{figure}

% Inductive elab. rule for composition of variable declaration.

\begin{figure}[H]
  {\fontsize{8}{11}\selectfont\textsc{VarElabComp}}
  
  \begin{prooftree}

    % Evaluates VE1
    \hypo{\Delta,\Lambda\vdash\mathrm{vdecl}\xrightarrow{evars}{}\Lambda'}

    % Evaluates VE2.
    \hypo{\Delta,\Lambda'\vdash\mathrm{vars}\xrightarrow{evars}{}\Lambda''}

    % Conclusion
    \infer[template={\inserttext}]2{
      $\Delta,\Lambda\vdash
      ~\mathrm{vdecl}\mathtt{,}~\mathrm{vars}
      \xrightarrow{evars}\Lambda''$
    }
  \end{prooftree}
\end{figure}

\subsubsection{Component instantiation statement elaboration}
\label{subsubsec:comp-inst-elab}

To elaborate a component instantiation statement, the $ebeh$ relation
first builds a dimensioning function $\mathcal{M}$ out of the
component instance's generic map. Then, the design associated with the
entity identifier declared by the component instance (i.e. $id_e$) is
looked up and retrieved from the design store $\mathcal{D}$.  Then,
the $ebeh$ relation appeals to the $elab$ relation to build an
elaborated version $\Delta_c$ and a default design state $\sigma_c$
for the retrieved design given the specific dimensioning function
$\mathcal{M}$. Finally, the component instance identifier $id_c$ is
bound to its elaborated version $\Delta_c$ in the $Comps$
sub-environment of $\Delta$, and is bound to its own default design
state $\sigma_c$ in the component store $\mathcal{C}$ of
$\sigma$. Consequently, the definition of the $elab$ and $ebeh$
relations is mutually recursive.

\begin{premises}
  \begin{itemize}[label=-]
  \item The $emapg$ relation builds a function
    $\mathcal{M}\in{}generic\mhyphen{}id\nrightarrow{}value$ out of a
    generic map (see the definition below).
  \item \texttt{valid}$_{ipm}$ (resp. \texttt{valid}$_{opm}$) states
    that an input port map (resp. output port map) is valid, i.e
    well-formed and well-typed (see Section~\ref{subsec:valid-pm}).
  \end{itemize}
\end{premises}

\begin{sideconds}
  $\mathcal{M}\subseteq{}Gens(\Delta_c)$ checks that the generic map g
  contains references to known generic constant identifiers only.
\end{sideconds}

\begin{table}[H]
  \begin{tabular}{@{}l}
    {\fontsize{8}{11}\selectfont\textsc{CompElab}} \\
    {\begin{prooftree}
        
        % Creates mapping and elaborates gens.
        \hypo{\mathcal{M}_\emptyset&\vdash\mathrm{g}\xrightarrow{emapg}\mathcal{M}}
        
        % Elaborates design.
        \infer[no rule]1{ \mathcal{D},\mathcal{M}&\vdash
          \mathcal{D}(\mathrm{id}_e)\xrightarrow{elab}\Delta_c,\sigma_c}

        % Checks in port map validity.
        \hypo{\Delta,\Delta_c,\sigma&\vdash\mathtt{valid}_{ipm}(\mathrm{i})}

        % Checks out port map validity.
        \infer[no rule]1{\Delta,\Delta_c&\vdash\mathtt{valid}_{opm}(\mathrm{o})}
        
        % Conclusion
        \infer[template={\inserttext}]2
        [{
          \renewcommand{\arraystretch}{1.5}
          \begin{tabular}{@{}l}
            $\mathrm{id}_c\notin\Delta$, $\mathrm{id}_c\notin\sigma$ \\
            $\mathrm{id}_e\in{}\mathcal{D}$\\
            % $\mathcal{D}(\mathrm{id}_e)=$ \vhdlep{7}{9}|design| id$_{ce}$ id$_{ca}$ gens ports sigs cs \\
            $\mathcal{M}\subseteq{}Gens(\Delta_c)$ \\
          \end{tabular}
        }]
        {
          $\mathcal{D},\Delta,\sigma\vdash$
          \vhdle|comp| $(\mathrm{id}_c, \mathrm{id}_e, \mathrm{g}, \mathrm{i}, \mathrm{o})\xrightarrow{ebeh}$
          $\Delta\cup{}(id_c,\Delta_c),$
          $\sigma\cup{}(id_c,\sigma_c)$
        }
      \end{prooftree}} \\
  \end{tabular}
\end{table}

A port map is a mapping between expressions and signals coming from an
embedding design ($\Delta$) and the ports of an internal component
instance ($\Delta_c$). The formal part of an port map entry (i.e, the
left part) belongs to the internal component, whereas the actual part
(i.e, the right part) refers to the embedding design. Therefore, we
need both $\Delta$ and $\Delta_c$ to verify if a port map is
well-typed leveraging the $\mathtt{valid}_{ipm}$, or the
$\mathtt{valid}_{opm}$, relation.

\begin{remark}[Valid generic map]
  In Rule~\textsc{CompElab}, note that we are not checking the
  validity of the generic map g.  In case of an ill-formed generic
  map, an inconsistent mapping $\mathcal{M}$ is generated by the
  \emph{emapg} relation. In the presence of an ill-formed dimensioning
  function, the \emph{elab} relation is never derivable. Therefore,
  the \emph{elab} relation does an implicit validity check on the
  generic map.
\end{remark}

% Creates a mapping function from an assoc. list.

% Case formal part is not partial.

The $emap_g$ relation builds a dimensioning function out of generic
map. For each association of the generic map, the $emap_g$ relation
evaluates the actual part of the association, and adds a binding
between the generic constant identifier and its value to the
dimensioning function $\mathcal{M}$.

\begin{table}[H]
  \begin{tabular}{@{}l}
    {\fontsize{8}{11}\selectfont\textsc{AssocGElab}} \\
    
    {\begin{prooftree}

        % Locally static expression e.
        \hypo{SE_l(\mathrm{e})}
        
        % Evaluates e.
        \hypo{\mathrm{e}\xrightarrow{e}v}

        % Conclusion
        \infer[template={\inserttext}]2
        [$\mathrm{id}_g\notin\mathcal{M}$]
        {
          $\mathcal{M}\vdash$
          $~(\mathrm{id}_g,\mathrm{e})$
          $\xrightarrow{emapg}$
          $\mathcal{M}\cup{}(\mathrm{id}_g,v)$
        }
      \end{prooftree}} \\
  \end{tabular}
  \begin{tabular}{@{}l}
    {\fontsize{8}{11}\selectfont\textsc{GMElab}} \\
    
    {\begin{prooftree}

        % Collects assoc_g.
        \hypo{\mathcal{M}\vdash\mathrm{assoc}_g\xrightarrow{emapg}\mathcal{M}'}

        % Collects lassoc_g.
        \hypo{\mathcal{M}'\vdash\mathrm{gmap}\xrightarrow{emapg}\mathcal{M}''}

        % Conclusion
        \infer[template={\inserttext}]2
        {
          $\mathcal{M}\vdash
          \mathrm{assoc}_g,~\mathrm{gmap}$
          $\xrightarrow{emapg}\mathcal{M}''$
        }
      \end{prooftree}} \\
  \end{tabular}
\end{table}

An $\mathrm{assoc}_g$ entry doesn't allow indexed identifiers in its
formal part, due to the restriction of generic constants to scalar
types.  Note that this restriction is not imposed by the LRM. We
choose to adopt this simplification of the \vhdl{} syntax since the case
of generic constants with composite types is never encountered in the
\vhdl{} programs generated by \hilecop{}.

\subsection{Implicit default value}
\label{subsec:implicit-default-v}

According to the \vhdl{} LRM, at the declaration of a port, a signal or a
variable, these items must receive an implicit default value depending
on their types \cite[p.61, 64, 173]{VHDL2000}. The $defaultv$ relation
determines the default value for a given type.

\begin{table}[H]
  \centering
  \begin{tabular}{@{}l}
    {\fontsize{10}{13}\selectfont\textsc{DefaultVBool}} \\
    {\begin{prooftree}

        % Conclusion
        \infer[template={\inserttext}]0
        {
          $bool$
          $\xrightarrow{defaultv}\bot$
        }
      \end{prooftree}} \\
  \end{tabular}
  \begin{tabular}{@{}l}
    {\fontsize{10}{13}\selectfont\textsc{DefaultVCNat}} \\
    {\begin{prooftree}

        % Conclusion
        \infer[template={\inserttext}]0
        [$n\le{}m$]
        {
          $nat(n,m)$
          $\xrightarrow{defaultv}n$
        }
      \end{prooftree}} \\
  \end{tabular}
\end{table}

\begin{table}[H]
  \centering
  \begin{tabular}{@{}l}
    {\fontsize{10}{13}\selectfont\textsc{DefaultVCArr}} \\
    {\begin{prooftree}

        % Retrieves default value for element subtype.
        \hypo{T\xrightarrow{defaultv}v}
        
        % Conclusion
        \infer[template={\inserttext}]1
        [
        \begin{tabular}{@{}l}
          $n\le{}m$ \\
          $size=(m-n)+1$ \\
        \end{tabular}
        ]
        {
          $array(T,n,m)$
          $\xrightarrow{defaultv}$
          $\mathtt{create\_array}(size,T,v)$
        }
      \end{prooftree}} \\
  \end{tabular}
\end{table}

The $\mathtt{create\_array}(size,T,v)$ expression yields an array of
size $size$, containing elements of type $T$, where each element is
initialized with the value $v$.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../main"
%%% End:
