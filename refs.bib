
@inproceedings{Breuer1994,
	location = {Paris, France},
	title = {Clean formal semantics for {VHDL}},
	isbn = {978-0-8186-5410-7},
	url = {http://ieeexplore.ieee.org/document/326810/},
	doi = {10.1109/EDTC.1994.326810},
	eventtitle = {European Design and Test Conference {EDAC}-{ETC}-{EUROASIC}},
	pages = {641--647},
	booktitle = {Proceedings of European Design and Test Conference {EDAC}-{ETC}-{EUROASIC}},
	publisher = {{IEEE} Comput. Soc. Press},
	author = {Breuer, P.T. and Fernandez, L.S. and Kloos, C.D.},
	urldate = {2019-09-03},
	date = {1994}
}

@inproceedings{zotero-12,
	title = {The semantics of behavioral {VHDL} '93 descriptions}
}

@incollection{Fuchs1995,
	location = {Boston, {MA}},
	title = {A Functional Semantics for Delta-Delay {VHDL} Based on Focus},
	volume = {307},
	isbn = {978-1-4613-5941-8 978-1-4615-2237-9},
	url = {http://link.springer.com/10.1007/978-1-4615-2237-9_2},
	pages = {9--42},
	booktitle = {Formal Semantics for {VHDL}},
	publisher = {Springer {US}},
	author = {Fuchs, Max and Mendler, Michael},
	editor = {Kloos, Carlos Delgado and Breuer, Peter T.},
	editorb = {Allen, Jonathan},
	editorbtype = {redactor},
	urldate = {2019-09-03},
	date = {1995},
	doi = {10.1007/978-1-4615-2237-9_2}
}

@incollection{Breuer1995,
	location = {Boston, {MA}},
	title = {A Functional Semantics for Unit-Delay {VHDL}},
	volume = {307},
	isbn = {978-1-4613-5941-8 978-1-4615-2237-9},
	url = {http://link.springer.com/10.1007/978-1-4615-2237-9_3},
	pages = {43--70},
	booktitle = {Formal Semantics for {VHDL}},
	publisher = {Springer {US}},
	author = {Breuer, Peter T. and Fernández, Luis Sánchez and Kloos, Carlos Delgado},
	editor = {Kloos, Carlos Delgado and Breuer, Peter T.},
	editorb = {Allen, Jonathan},
	editorbtype = {redactor},
	urldate = {2019-09-09},
	date = {1995},
	doi = {10.1007/978-1-4615-2237-9_3}
}

@incollection{VanTassel1995,
	location = {Boston, {MA}},
	title = {An Operational Semantics for a Subset of {VHDL}},
	volume = {307},
	isbn = {978-1-4613-5941-8 978-1-4615-2237-9},
	url = {http://link.springer.com/10.1007/978-1-4615-2237-9_4},
	pages = {71--106},
	booktitle = {Formal Semantics for {VHDL}},
	publisher = {Springer {US}},
	author = {Van Tassel, John P.},
	editor = {Kloos, Carlos Delgado and Breuer, Peter T.},
	editorb = {Allen, Jonathan},
	editorbtype = {redactor},
	urldate = {2019-09-12},
	date = {1995},
	doi = {10.1007/978-1-4615-2237-9_4}
}

@incollection{Borger1995,
	location = {Boston, {MA}},
	title = {A Formal Definition of an Abstract {VHDL}’93 Simulator by {EA}-Machines},
	volume = {307},
	isbn = {978-1-4613-5941-8 978-1-4615-2237-9},
	url = {http://link.springer.com/10.1007/978-1-4615-2237-9_5},
	pages = {107--139},
	booktitle = {Formal Semantics for {VHDL}},
	publisher = {Springer {US}},
	author = {Börger, Egon and Glässer, Uwe and Muller, Wolfgang},
	editor = {Kloos, Carlos Delgado and Breuer, Peter T.},
	editorb = {Allen, Jonathan},
	editorbtype = {redactor},
	urldate = {2019-09-12},
	date = {1995},
	doi = {10.1007/978-1-4615-2237-9_5}
}

@book{VHDL2000,
	location = {New York, N.Y.},
	title = {{IEEE} standard {VHDL} language reference manual},
	isbn = {978-0-7381-1948-9 978-0-7381-1949-6},
	url = {http://ieeexplore.ieee.org/lpdocs/epic03/standards.htm},
	publisher = {Institute of Electrical and Electronics Engineers},
	author = {{IEEE Computer Society} and {Design Automation Standards Committee} and {IEEE Standards Coordinating Committee 20} and {Automatic Test Program Generation Subcommittee} and {Institute of Electrical and Electronics Engineers} and {IEEE-SA Standards Board}},
	urldate = {2019-09-16},
	date = {2000},
	note = {{OCLC}: 49592632}
}

@article{Pandey1999,
	title = {{VHDL} semantics and validating transformations},
	volume = {18},
	issn = {02780070},
	url = {http://ieeexplore.ieee.org/document/771177/},
	doi = {10.1109/43.771177},
	pages = {936--955},
	number = {7},
	journaltitle = {{IEEE} Transactions on Computer-Aided Design of Integrated Circuits and Systems},
	shortjournal = {{IEEE} Trans. Comput.-Aided Des. Integr. Circuits Syst.},
	author = {Pandey, S.L. and Umamageswaran, K. and Wilsey, P.A.},
	urldate = {2019-09-18},
	date = {1999-07}
}

@article{Borrione1995,
	title = {Denotational semantics of a synchronous {VHDL} subset},
	volume = {7},
	issn = {0925-9856, 1572-8102},
	url = {http://link.springer.com/10.1007/BF01383873},
	doi = {10.1007/BF01383873},
	pages = {53--71},
	number = {1},
	journaltitle = {Formal Methods in System Design},
	shortjournal = {Form Method Syst Des},
	author = {Borrione, Dominique and Salem, Ashraf},
	urldate = {2019-09-18},
	date = {1995-08},
	langid = {english}
}

@article{Jiang2015,
	title = {Design of Mixed Synchronous/Asynchronous Systems with Multiple Clocks},
	volume = {26},
	issn = {1045-9219},
	url = {http://ieeexplore.ieee.org/document/6874581/},
	doi = {10.1109/TPDS.2014.2346171},
	pages = {2220--2232},
	number = {8},
	journaltitle = {{IEEE} Transactions on Parallel and Distributed Systems},
	shortjournal = {{IEEE} Trans. Parallel Distrib. Syst.},
	author = {Jiang, Yu and Zhang, Hehua and Zhang, Huafeng and Liu, Han and Song, Xiaoyu and Gu, Ming and Sun, Jiaguang},
	urldate = {2019-09-19},
	date = {2015-08-01}
}

@collection{Meyer2012,
	location = {Berlin ; New York},
	title = {Tools for practical software verification: {LASER}, International Summer School 2011, Elba Island, Italy, revised tutorial lectures},
	isbn = {978-3-642-35745-9},
	series = {Lecture notes in computer science},
	shorttitle = {Tools for practical software verification},
	pagetotal = {181},
	number = {7682},
	publisher = {Springer},
	editor = {Meyer, Bertrand and Nordio, Martin},
	date = {2012},
	note = {{OCLC}: ocn829655089},
	keywords = {Computer software, Congresses, Software engineering, Verification}
}

@incollection{Paulin-Mohring2012,
	location = {Berlin, Heidelberg},
	title = {Introduction to the Coq Proof-Assistant for Practical Software Verification},
	volume = {7682},
	isbn = {978-3-642-35745-9 978-3-642-35746-6},
	url = {http://link.springer.com/10.1007/978-3-642-35746-6_3},
	pages = {45--95},
	booktitle = {Tools for Practical Software Verification},
	publisher = {Springer Berlin Heidelberg},
	author = {Paulin-Mohring, Christine},
	editor = {Meyer, Bertrand and Nordio, Martin},
	urldate = {2019-10-14},
	date = {2012},
	langid = {english},
	doi = {10.1007/978-3-642-35746-6_3},
	file = {Version soumise:/home/iampietro/Zotero/storage/5JLKSFST/Paulin-Mohring - 2012 - Introduction to the Coq Proof-Assistant for Practi.pdf:application/pdf}
}

@book{Bertot2004,
	location = {Berlin ; New York},
	title = {Interactive theorem proving and program development: Coq'Art: the calculus of inductive constructions},
	isbn = {978-3-540-20854-9},
	series = {Texts in theoretical computer science},
	shorttitle = {Interactive theorem proving and program development},
	pagetotal = {469},
	publisher = {Springer},
	author = {Bertot, Yves and Castéran, P.},
	date = {2004},
	note = {{OCLC}: ocm55514299},
	keywords = {Automatic theorem proving, Computer programming}
}

@inproceedings{Bjorner1987,
	location = {Los Alamitos, {CA}, {USA}},
	title = {On the Use of Formal Methods in Software Development},
	isbn = {978-0-89791-216-7},
	url = {http://dl.acm.org/citation.cfm?id=41765.41768},
	series = {{ICSE} '87},
	abstract = {We propose a total framework for the software development stages of specification (definition), design and coding. This framework is based on three cornerstones: (a) the concept of software development graphs which specify all the stages and steps of development; (b) the use of formal methods, in our case {VDM}, the Vienna Software Development Method, in all stages and steps of development; and (c) the clearly separate rôles of theoretical computer scientists, programmers, software engineers, and development managers in all aspects of software development. Thus not only programming is formalised (ie. programs considered formal objects), but also development, its engineering and management (ie. the entire programming itself is also considered a formal object about which to reason).},
	pages = {17--29},
	booktitle = {Proceedings of the 9th International Conference on Software Engineering},
	publisher = {{IEEE} Computer Society Press},
	author = {Bjorner, D.},
	urldate = {2019-11-13},
	date = {1987},
	note = {event-place: Monterey, California, {USA}}
}

@online{zotero-46,
	title = {Formal Methods},
	url = {https://users.ece.cmu.edu/~koopman/des_s99/formal_methods/},
	urldate = {2019-11-13},
	file = {Formal Methods:/home/iampietro/Zotero/storage/MMNRTEUY/formal_methods.html:text/html}
}

@article{Leroy,
	title = {Spécification et vérification formelles   avec l'assistant à la preuve Coq},
	pages = {41},
	author = {Leroy, Xavier},
	langid = {french},
	file = {Leroy - Spécification et vérification formelles   avec l'a.pdf:/home/iampietro/Zotero/storage/SQ8PLDG5/Leroy - Spécification et vérification formelles   avec l'a.pdf:application/pdf}
}

@collection{Abran2004,
	location = {Los Alamitos, Calif.},
	title = {Guide to the software engineering body of knowledge, 2004 version: {SWEBOK} ; a project of the {IEEE} Computer Society Professional Practices Committee},
	isbn = {978-0-7695-2330-9},
	shorttitle = {Guide to the software engineering body of knowledge, 2004 version},
	publisher = {{IEEE} Computer Society},
	editor = {Abran, Alain},
	date = {2004},
	note = {{OCLC}: 934432015}
}

@book{Neumann1995,
	location = {New York, New York : Reading, Mass},
	title = {Computer-related risks},
	isbn = {978-0-201-55805-0},
	pagetotal = {367},
	publisher = {{ACM} Press ; Addison-Wesley},
	author = {Neumann, Peter},
	date = {1995},
	keywords = {Electronic digital computers, Reliability, Risk management}
}

@article{Abadi,
	title = {Dynamic typing in a statically typed language},
	abstract = {Statically typed programming languages allow earlier error checking, better enforcement of disciplined programming styles, and generation of more e cient object code than languages where all type consistency checks are performed at run time. However, even in statically typed languages, there is often the need to deal with data whose type cannot be determined at compile time. To handle such situations safely, we propose to add a type Dynamic whose values are pairs of a value v and a type tag T where v has the type denoted by T. Instances of Dynamic are built with an explicit tagging construct and inspected with a type safe typecase construct.},
	pages = {35},
	author = {Abadi, Martin and Cardelli, Luca and Pierce, Benjamin C and Plotkin, Gordon D},
	langid = {english},
	file = {Abadi et al. - Dynamic typing in a statically typed language.pdf:/home/iampietro/Zotero/storage/G327YFUU/Abadi et al. - Dynamic typing in a statically typed language.pdf:application/pdf}
}

@inproceedings{Shields1998,
	location = {San Diego, California, United States},
	title = {Dynamic typing as staged type inference},
	isbn = {978-0-89791-979-1},
	url = {http://portal.acm.org/citation.cfm?doid=268946.268970},
	doi = {10.1145/268946.268970},
	abstract = {Dynamic typing extends statically typed languages with a universal datatype, simplifying programs which must manipulate other programs as data, such as distributed, persistent, interpretive and generic programs. Current approaches, however, limit the use of polymorphism in dynamic values, and can be syntactically awkward.},
	eventtitle = {the 25th {ACM} {SIGPLAN}-{SIGACT} symposium},
	pages = {289--302},
	booktitle = {Proceedings of the 25th {ACM} {SIGPLAN}-{SIGACT} symposium on Principles of programming languages  - {POPL} '98},
	publisher = {{ACM} Press},
	author = {Shields, Mark and Sheard, Tim and Peyton Jones, Simon},
	urldate = {2019-11-19},
	date = {1998},
	langid = {english},
	file = {Shields et al. - 1998 - Dynamic typing as staged type inference.pdf:/home/iampietro/Zotero/storage/F92ISQM9/Shields et al. - 1998 - Dynamic typing as staged type inference.pdf:application/pdf}
}

@inproceedings{HongweiXi2000,
	location = {Santa Barbara, {CA}, {USA}},
	title = {Imperative programming with dependent types},
	isbn = {978-0-7695-0725-5},
	url = {http://ieeexplore.ieee.org/document/855785/},
	doi = {10.1109/LICS.2000.855785},
	abstract = {In this paper, we enrich imperative programming with a form of dependent types. We start with explaining some motivations for this enrichment and mentioning some major obstacles that need to be overcome. We then present the design of a source level dependently typed imperative programming language Xanadu, forming both static and dynamic semantics and then establishing the type soundness theorem. We also present realistic examples, which have all been veriﬁed in a prototype implementation, in support of the practicality of Xanadu. We claim that the language design of Xanadu is novel and it serves as an informative example that demonstrates a means to combine imperative programming with dependent types.},
	eventtitle = {Fifteenth Annual {IEEE} Symposium on Logic in Computer Science ({LICS} 2000)},
	pages = {375--387},
	booktitle = {Proceedings Fifteenth Annual {IEEE} Symposium on Logic in Computer Science (Cat. No.99CB36332)},
	publisher = {{IEEE} Comput. Soc},
	author = {{Hongwei Xi}},
	urldate = {2019-11-27},
	date = {2000},
	langid = {english},
	file = {Hongwei Xi - 2000 - Imperative programming with dependent types.pdf:/home/iampietro/Zotero/storage/C7FR78SH/Hongwei Xi - 2000 - Imperative programming with dependent types.pdf:application/pdf}
}

@online{zotero-62,
	title = {Lecture 7: Type Checking},
	url = {http://www.cse.chalmers.se/edu/year/2015/course/DAT150/lectures/proglang-07.html},
	urldate = {2019-11-27},
	file = {Lecture 7\: Type Checking:/home/iampietro/Zotero/storage/MQ4PYYMA/proglang-07.html:text/html}
}

@inproceedings{Gonthier2008,
	location = {Berlin, Heidelberg},
	title = {The Four Colour Theorem: Engineering of a Formal Proof},
	isbn = {978-3-540-87827-8},
	doi = {10.1007/978-3-540-87827-8_28},
	series = {Lecture Notes in Computer Science},
	shorttitle = {The Four Colour Theorem},
	abstract = {The 150 year old Four Colour Theorem is the first famous result with a proof that requires large computer calculations. Such proofs are still controversial: It is thought that computer programs cannot be reviewed with mathematical rigor.To overturn this belief, we have created a fully computer-checked proof of the Four Colour Theorem. Using the Coq proof assistant, we wrote an extended program that specifies both the calculations and their mathematical justification. Only the interface of the program – the statement of the theorem – needs to be reviewed. The rest (99.8\%) is self-checking: Coq verifies that it strictly follows the rules of logic. Thus, our proof is more rigorous than a traditional one.Our effort turned out to be more than just an exercise in verification; having to definine rigorously all key concepts provided new mathematical insight into the concept of planarity. Planarity has topological and combinatorial characterizations, which are often confused in arguments that are both pictorially appealing and logically incomplete. The rigor of our computer proof imposed a strict separation between the two.We developed a purely combinatorial theory of planarity based on a symmetrical presentation of hypermaps, which greatly simplified the proof. The theory supplies an elegant analogue of the Jordan Curve property, which allowed us to prove the Theorem under minimal topological assumptions, without appealing to Jordan Curve theorem.},
	pages = {333--333},
	booktitle = {Computer Mathematics},
	publisher = {Springer},
	author = {Gonthier, Georges},
	editor = {Kapur, Deepak},
	date = {2008},
	langid = {english}
}

@inproceedings{Cuoq2012,
	location = {Berlin, Heidelberg},
	title = {Frama-C},
	isbn = {978-3-642-33826-7},
	doi = {10.1007/978-3-642-33826-7_16},
	series = {Lecture Notes in Computer Science},
	abstract = {Frama-C is a source code analysis platform that aims at conducting verification of industrial-size C programs. It provides its users with a collection of plug-ins that perform static analysis, deductive verification, and testing, for safety- and security-critical software. Collaborative verification across cooperating plug-ins is enabled by their integration on top of a shared kernel and datastructures, and their compliance to a common specification language. This foundational article presents a consolidated view of the platform, its main and composite analyses, and some of its industrial achievements.},
	pages = {233--247},
	booktitle = {Software Engineering and Formal Methods},
	publisher = {Springer},
	author = {Cuoq, Pascal and Kirchner, Florent and Kosmatov, Nikolai and Prevosto, Virgile and Signoles, Julien and Yakobowski, Boris},
	editor = {Eleftherakis, George and Hinchey, Mike and Holcombe, Mike},
	date = {2012},
	langid = {english},
	keywords = {Abstract Interpretation, Memory Location, Memory Model, Smart Card, Theorem Prover}
}

@article{Alexiev1994,
	title = {Applications of Linear Logic to Computation: An Overview},
	volume = {2},
	doi = {10.1093/jigpal/2.1.77},
	shorttitle = {Applications of Linear Logic to Computation},
	abstract = {This paper gives an overview of existing applications of Linear Logic ({LL}) to issues of computation. Alter a substantial introduction
to {LL}, it discusses the implications of {LL} to functional programming, logic programming, concurrent and object-oriented programming
and some other applications of {LL}, like semantios of negation in {LP}, non-monotonic issues in {AI} planning, etc. Although the overview covers pretty much the state-of-the-art in this area, by necessity many of the works are only mentioned
and referenced, but not discussed in any considerable detail. The paper does not presuppose any previous exposition to {LL},
and is addressed more to computer scientists (probably with a theoretical inclination) than to logicians. The paper contains
over 140 references, of which some 80 are about applications of {LL}.},
	journaltitle = {Logic Journal of {IGPL}},
	shortjournal = {Logic Journal of {IGPL}},
	author = {Alexiev, Vladimir},
	date = {1994-10-11},
	file = {Full Text PDF:/home/iampietro/Zotero/storage/JWAI768T/Alexiev - 1994 - Applications of Linear Logic to Computation An Ov.pdf:application/pdf}
}

@inproceedings{Berramla2015,
	title = {Formal validation of model transformation with Coq proof assistant},
	doi = {10.1109/NTIC.2015.7368755},
	abstract = {Facing the increasing complexity of systems and their design methods, the Model Driven Engineering ({MDE}) brings solutions to facilitate and automate the software development process. The model transformation is the most important artifact in {MDE} that it defines the automatic passing from one model to another. The validation of such model transformation are necessary to improve the safety of this latter, but most transformation languages have not a formal semantics to add detailed specifications on the expected behavior. So it is important to give solutions to integrate formal methods at this level. For this, we utilize the Coq proof assistant that is based on various calculus, for validating a model transformation specified with {QVT}-operational language. We illustrate our approach by transforming a {UML} state diagram into Petri net.},
	eventtitle = {2015 First International Conference on New Technologies of Information and Communication ({NTIC})},
	pages = {1--6},
	booktitle = {2015 First International Conference on New Technologies of Information and Communication ({NTIC})},
	author = {Berramla, Karima and Deba, El Abbassia and Senouci, Mohammed},
	date = {2015-11},
	note = {{ISSN}: null},
	keywords = {Verification, calculus, Calculus, Computational modeling, Coq proof assistant, formal methods, Formal Methods, formal verification, {MDE}, Metamodeling, model driven engineering, Model Transformation, model transformation formal validation, Model-Driven Engineering, Operational {QVT}, Petri net, Petri nets, Query-View-Transformation Language, {QVT}-operational language, Semantics, Software, theorem proving, transformation languages, {UML} state diagram, Unified modeling language, Validation},
	file = {IEEE Xplore Abstract Record:/home/iampietro/Zotero/storage/73APVN34/7368755.html:text/html}
}

@inproceedings{Fronc2011,
	location = {Berlin, Heidelberg},
	title = {Towards a Certified Petri Net Model-Checker},
	isbn = {978-3-642-25318-8},
	doi = {10.1007/978-3-642-25318-8_24},
	series = {Lecture Notes in Computer Science},
	abstract = {Petri nets are widely used in the domain of automated verification through model-checking. In this approach, a Petri Net model of the system of interest is produced and its reachable states are computed, searching for erroneous executions. Model compilation can accelerate this analysis by generating code to explore the reachable states. This avoids the use of a fixed exploration tool involving an “interpretation” of the Petri net structure. In this paper, we show how to compile Petri nets targeting the {LLVM} language (a high-level assembly language) and formally prove the correctness of the produced code. To this aim, we define a structural operational semantics for the fragment of {LLVM} we use.},
	pages = {322--336},
	booktitle = {Programming Languages and Systems},
	publisher = {Springer},
	author = {Fronc, Lukasz and Pommereau, Franck},
	editor = {Yang, Hongseok},
	date = {2011},
	langid = {english},
	keywords = {explicit model-checking, {LLVM}, model compilation, {SOS}},
	file = {Springer Full Text PDF:/home/iampietro/Zotero/storage/W3ZLFXLF/Fronc et Pommereau - 2011 - Towards a Certified Petri Net Model-Checker.pdf:application/pdf}
}

@thesis{Fronc2013,
	title = {Compilation de réseaux de Petri : modèles haut niveau et symétries de processus},
	url = {https://hal.archives-ouvertes.fr/tel-01096725},
	shorttitle = {Compilation de réseaux de Petri},
	abstract = {Cette thèse s'intéresse à la vérification de systèmes automatisables par model-checking. La question sous-jacente autour de laquelle se construit la contribution est la recherche d'un compromis entre différents objectifs potentiellement contradictoires : la décidabilité des systèmes à vérifier, l'expressivité des formalismes de modélisation, l'efficacité de la vérification, et la certification des outils utilisés. Dans ce but, on choisit de baser la modélisation sur des réseaux de Petri annotés par des langages de programmation réels. Cela implique la semi-décidabilité de la plupart des questions puisque la responsabilité de la terminaison est remise entre les mains du modélisateur (tout comme la terminaison des programmes est de la responsabilité du programmeur). Afin d'exploiter efficacement ces annotations, on choisit ensuite une approche de compilation de modèle qui permet de générer des programmes efficaces dans le langage des annotations, qui sont alors exécutées de la manière la plus efficace. De plus, la compilation est optimisée en tirant partie des spécificités de chaque modèle et nous utilisons l'approche de model-checking explicite qui autorise cette richesse d'annotations tout en facilitant le diagnostique et en restant compatible avec la simulation (les modèles compilés peuvent servir à de la simulation efficace). Enfin, pour combattre l'explosion combinatoire, nous utilisons des techniques de réductions de symétries qui permettent de réduire les temps d'exploration et l'espace mémoire nécessaire.},
	institution = {Université d'Evry Val d'Essonne},
	type = {phdthesis},
	author = {Fronc, Lukasz},
	urldate = {2020-01-16},
	date = {2013-11-28},
	langid = {french},
	file = {Full Text PDF:/home/iampietro/Zotero/storage/2M678ZE4/Fronc - 2013 - Compilation de réseaux de Petri  modèles haut niv.pdf:application/pdf;Snapshot:/home/iampietro/Zotero/storage/MGTN3FTH/tel-01096725.html:text/html}
}

@inproceedings{Fronc2013a,
	location = {Cham},
	title = {{LTL} Model Checking with Neco},
	isbn = {978-3-319-02444-8},
	doi = {10.1007/978-3-319-02444-8_33},
	series = {Lecture Notes in Computer Science},
	abstract = {We introduce neco-spot, an {LTL} model checker for Petri net models. It builds upon Neco, a compiler turning Petri nets into native shared libraries that allows fast on-the-fly exploration of the state-space, and upon Spot, a C++ library of model-checking algorithms. We show the architecture of Neco and explain how it was combined with Spot to build an {LTL} model checker.},
	pages = {451--454},
	booktitle = {Automated Technology for Verification and Analysis},
	publisher = {Springer International Publishing},
	author = {Fronc, Łukasz and Duret-Lutz, Alexandre},
	editor = {Van Hung, Dang and Ogawa, Mizuhito},
	date = {2013},
	langid = {english},
	file = {Springer Full Text PDF:/home/iampietro/Zotero/storage/VDKMUAD2/Fronc et Duret-Lutz - 2013 - LTL Model Checking with Neco.pdf:application/pdf}
}

@inproceedings{Meghzili2017,
	title = {On the Verification of {UML} State Machine Diagrams to Colored Petri Nets Transformation Using Isabelle/{HOL}},
	doi = {10.1109/IRI.2017.63},
	abstract = {The Unified Modeling Language ({UML}) is a modeling language standardized by the {OMG}. The goal of {UML} is to supply software engineers, software developers, and system architects with tools for analysis, design, and implementation of software-based systems as well as for modeling business and similar processes. However, {UML} semantics is not formally defined. On the other hand, Colored Petri nets models ({CPNs}) are based on mathematical principle and have several verification capabilities. In this paper, we present another way to transform State Machine Diagrams ({UML} {SMD}) into Colored petri nets models and prove certain structural properties in this transformation itself. Therefore, we have described {UML} {SMD} (source model), Colored Petri nets (target model) and the transformation algorithm within Isabelle/{HOL} theorem prover. We demonstrate, also within Isabelle/{HOL}, that this transformation preserves certain structural properties for any input model ({UML} {SMD}).},
	eventtitle = {2017 {IEEE} International Conference on Information Reuse and Integration ({IRI})},
	pages = {419--426},
	booktitle = {2017 {IEEE} International Conference on Information Reuse and Integration ({IRI})},
	author = {Meghzili, Said and Chaoui, Allaoua and Strecker, Martin and Kerkouche, Elhillali},
	date = {2017-08},
	note = {{ISSN}: null},
	keywords = {formal verification, Model Transformation, Petri nets, theorem proving, Unified modeling language, Biological system modeling, Colored Petri nets ({CPN}), Colored Petri nets models, {CPN}, finite state machines, formal specification, Formal verification, Isabelle-{HOL} theorem prover, Isabelle/ {HOL}, Mathematical model, Object oriented modeling, Semantic correctness, software developers, software engineering, software engineers, Tools, Transforms, {UML} semantics, {UML} {SMD}, {UML} state machine diagrams, unified modeling language, Unified Modeling Language, verification capabilities},
	file = {IEEE Xplore Abstract Record:/home/iampietro/Zotero/storage/XK5572SC/8102966.html:text/html}
}

@article{Yang2014,
	title = {From {AADL} to Timed Abstract State Machines: A verified model transformation},
	volume = {93},
	issn = {0164-1212},
	url = {http://www.sciencedirect.com/science/article/pii/S0164121214000727},
	doi = {10.1016/j.jss.2014.02.058},
	shorttitle = {From {AADL} to Timed Abstract State Machines},
	abstract = {Architecture Analysis and Design Language ({AADL}) is an architecture description language standard for embedded real-time systems widely used in the avionics and aerospace industry to model safety-critical applications. To verify and analyze the {AADL} models, model transformation technologies are often used to automatically extract a formal specification suitable for analysis and verification. In this process, it remains a challenge to prove that the model transformation preserves the semantics of the initial {AADL} model or, at least, some of the specific properties or requirements it needs to satisfy. This paper presents a machine checked semantics-preserving transformation of a subset of {AADL} (including periodic threads, data port communications, mode changes, and the {AADL} behavior annex) into Timed Abstract State Machines ({TASM}). The {AADL} standard itself lacks at present a formal semantics to make this translation validation possible. Our contribution is to bridge this gap by providing two formal semantics for the subset of {AADL}. The execution semantics provided by the {AADL} standard is formalized as Timed Transition Systems ({TTS}). This formalization gives a reference expression of {AADL} semantics which can be compared with the {TASM}-based translation (for verification purpose). Finally, the verified transformation is mechanized in the theorem prover Coq.},
	pages = {42--68},
	journaltitle = {Journal of Systems and Software},
	shortjournal = {Journal of Systems and Software},
	author = {Yang, Zhibin and Hu, Kai and Ma, Dianfu and Bodeveix, Jean-Paul and Pi, Lei and Talpin, Jean-Pierre},
	urldate = {2020-01-16},
	date = {2014-07-01},
	langid = {english},
	keywords = {Architecture Analysis and Design Language ({AADL}), Coq, Model transformation, Model-driven engineering, Semantics preservation, Timed Abstract State Machine ({TASM})},
	file = {ScienceDirect Full Text PDF:/home/iampietro/Zotero/storage/WBN3YA9Z/Yang et al. - 2014 - From AADL to Timed Abstract State Machines A veri.pdf:application/pdf;ScienceDirect Snapshot:/home/iampietro/Zotero/storage/WAL8UI96/S0164121214000727.html:text/html}
}

@inproceedings{Calegari2011,
	location = {Berlin, Heidelberg},
	title = {A Type-Theoretic Framework for Certified Model Transformations},
	isbn = {978-3-642-19829-8},
	doi = {10.1007/978-3-642-19829-8_8},
	series = {Lecture Notes in Computer Science},
	abstract = {We present a framework based on the Calculus of Inductive Constructions ({CIC}) and its associated tool the Coq proof assistant to allow certification of model transformations in the context of Model-Driven Engineering ({MDE}). The approached is based on a semi-automatic translation process from metamodels, models and transformations of the {MDE} technical space into types, propositions and functions of the {CIC} technical space. We describe this translation and illustrate its use in a standard case study.},
	pages = {112--127},
	booktitle = {Formal Methods: Foundations and Applications},
	publisher = {Springer},
	author = {Calegari, Daniel and Luna, Carlos and Szasz, Nora and Tasistro, Álvaro},
	editor = {Davies, Jim and Silva, Leila and Simao, Adenilso},
	date = {2011},
	langid = {english},
	keywords = {Model Transformation, Inductive Type, Matched Rule, Object Constraint Language, Transformation Rule},
	file = {Springer Full Text PDF:/home/iampietro/Zotero/storage/YJ5TW6HE/Calegari et al. - 2011 - A Type-Theoretic Framework for Certified Model Tra.pdf:application/pdf}
}

@article{Cheng2019,
	title = {{CoqTL}: a Coq {DSL} for rule-based model transformation},
	issn = {1619-1374},
	url = {https://doi.org/10.1007/s10270-019-00765-6},
	doi = {10.1007/s10270-019-00765-6},
	shorttitle = {{CoqTL}},
	abstract = {In model-driven engineering, model transformation ({MT}) verification is essential for reliably producing software artifacts. While recent advancements have enabled automatic Hoare-style verification for non-trivial {MTs}, there are certain verification tasks (e.g. induction) that are intrinsically difficult to automate. Existing tools that aim at simplifying the interactive verification of {MTs} typically translate the {MT} specification (e.g. in {ATL}) and properties to prove (e.g. in {OCL}) into an interactive theorem prover. However, since the {MT} specification and proof phases happen in separate languages, the proof developer needs a detailed knowledge of the translation logic. Naturally, any error in the {MT} translation could cause unsound verification, i.e. the {MT} executed in the original environment may have different semantics from the verified {MT}. We propose an alternative solution by designing and implementing an internal domain-specific language, namely {CoqTL}, for the specification of declarative {MTs} directly in the Coq interactive theorem prover. Expressions in {CoqTL} are written in Gallina (the specification language of Coq), increasing the possibilities of reusing native Coq libraries in the transformation definition and proof. {CoqTL} specifications can be directly executed by our transformation engine encoded in Coq, or a certified implementation of the transformation can be generated by the native Coq extraction mechanism. We ensure that {CoqTL} has the same expressive power of Gallina (i.e. if a {MT} can be computed in Gallina, then it can also be represented in {CoqTL}). In this article, we introduce {CoqTL}, evaluate its practical applicability on a use case, and identify its current limitations.},
	journaltitle = {Software and Systems Modeling},
	shortjournal = {Softw Syst Model},
	author = {Cheng, Zheng and Tisi, Massimo and Douence, Rémi},
	urldate = {2020-01-16},
	date = {2019-11-16},
	langid = {english},
	keywords = {Coq, Model transformation, Model-driven engineering, Domain-specific language, Interactive theorem proving},
	file = {Version soumise:/home/iampietro/Zotero/storage/P32VSYCM/Cheng et al. - 2019 - CoqTL a Coq DSL for rule-based model transformati.pdf:application/pdf}
}

@misc{zotero-95
}

@article{Choppy2008,
	title = {Experimenting Formal Proofs of Petri Nets Refinements},
	volume = {214},
	issn = {1571-0661},
	url = {http://www.sciencedirect.com/science/article/pii/S157106610800354X},
	doi = {10.1016/j.entcs.2008.06.011},
	series = {Proceedings of the 13th {BAC}-{FACS} Refinement Workshop ({REFINE} 2008)},
	abstract = {Petri nets are a formalism for modelling and validating critical systems. Generally, the approach to specification starts from an abstract view of the system under study. Once validated, a refinement step takes place, enhancing some parts of the initial model so as to obtain a more concrete specification. Some refinement techniques have been proposed in the framework of high-level Petri nets. Up to now, proving that a concrete net refines an abstract one, i.e. that there is a refinement relation between them, is completely manual. Our work aims at proving the refinement relation between two nets, both formally and automatically. For that purpose, we use the Coq theorem prover. We aim at having a framework general and parameterised enough to use Coq for any input nets. Moreover, this work constitutes a stepping stone towards bridging the gap between Petri nets and proof assistants techniques, and we claim that theorem proving methods are appropriate to prove the correctness of Petri net refinement.},
	pages = {231--254},
	journaltitle = {Electronic Notes in Theoretical Computer Science},
	shortjournal = {Electronic Notes in Theoretical Computer Science},
	author = {Choppy, Christine and Mayero, Micaela and Petrucci, Laure},
	urldate = {2020-01-20},
	date = {2008-06-28},
	langid = {english},
	keywords = {Petri net, theorem proving, Coq, refinement},
	file = {ScienceDirect Full Text PDF:/home/iampietro/Zotero/storage/5BCCEWEL/Choppy et al. - 2008 - Experimenting Formal Proofs of Petri Nets Refineme.pdf:application/pdf;ScienceDirect Snapshot:/home/iampietro/Zotero/storage/ZL6TU7ZY/S157106610800354X.html:text/html}
}

@article{Choppy2010,
	title = {Coloured Petri net refinement specification and correctness proof with Coq},
	volume = {6},
	issn = {1614-5054},
	url = {https://doi.org/10.1007/s11334-010-0131-2},
	doi = {10.1007/s11334-010-0131-2},
	abstract = {In this work, we address the issue of the formal proof (using the proof assistant Coq) of refinement correctness for symmetric nets, a subclass of coloured Petri nets. We provide a formalisation of the net models, and of their type refinement in Coq. Then the Coq proof assistant is used to prove the refinement correctness lemma. An example adapted from a protocol example illustrates our work.},
	pages = {195--202},
	number = {3},
	journaltitle = {Innovations in Systems and Software Engineering},
	shortjournal = {Innovations Syst Softw Eng},
	author = {Choppy, Christine and Mayero, Micaela and Petrucci, Laure},
	urldate = {2020-01-20},
	date = {2010-09-01},
	langid = {english},
	keywords = {Coloured Petri nets, Refinement, Theorem proving},
	file = {Springer Full Text PDF:/home/iampietro/Zotero/storage/B7F8JH7D/Choppy et al. - 2010 - Coloured Petri net refinement specification and co.pdf:application/pdf}
}

@article{Tan,
	title = {A New Veriﬁed Compiler Backend for {CakeML}},
	abstract = {We have developed and mechanically veriﬁed a new compiler backend for {CakeML}. Our new compiler features a sequence of intermediate languages that allows it to incrementally compile away high-level features and enables veriﬁcation at the right levels of semantic detail. In this way, it resembles mainstream (unveriﬁed) compilers for strict functional languages. The compiler supports efﬁcient curried multi-argument functions, conﬁgurable data representations, exceptions that unwind the call stack, register allocation, and more. The compiler targets several architectures: x86-64, {ARMv}6, {ARMv}8, {MIPS}-64, and {RISC}-V.},
	pages = {14},
	author = {Tan, Yong Kiam and Fox, Anthony and Myreen, Magnus O and Owens, Scott and Kumar, Ramana and Norrish, Michael},
	langid = {english},
	file = {Tan et al. - A New Veriﬁed Compiler Backend for CakeML.pdf:/home/iampietro/Zotero/storage/RVDITR6S/Tan et al. - A New Veriﬁed Compiler Backend for CakeML.pdf:application/pdf}
}

@article{Bourke,
	title = {A Formally Verified Compiler for Lustre},
	abstract = {The correct compilation of block diagram languages like Lustre, Scade, and a discrete subset of Simulink is important since they are used to program critical embedded control software. We describe the speciﬁcation and veriﬁcation in an Interactive Theorem Prover of a compilation chain that treats the key aspects of Lustre: sampling, nodes, and delays. Building on {CompCert}, we show that repeated execution of the generated assembly code faithfully implements the dataﬂow semantics of source programs.},
	pages = {17},
	author = {Bourke, Timothy and Brun, Lélio and Dagand, Pierre-Evariste and Leroy, Xavier and Pouzet, Marc and Rieg, Lionel},
	langid = {english},
	file = {Bourke et al. - A Formally Verified Compiler for Lustre.pdf:/home/iampietro/Zotero/storage/QULKJUXC/Bourke et al. - A Formally Verified Compiler for Lustre.pdf:application/pdf}
}

@article{Yang2016,
	title = {Towards a verified compiler prototype for the synchronous language {SIGNAL}},
	volume = {10},
	issn = {2095-2236},
	url = {https://doi.org/10.1007/s11704-015-4364-y},
	doi = {10.1007/s11704-015-4364-y},
	abstract = {{SIGNAL} belongs to the synchronous languages family which are widely used in the design of safety-critical real-time systems such as avionics, space systems, and nuclear power plants. This paper reports a compiler prototype for {SIGNAL}. Compared with the existing {SIGNAL} compiler, we propose a new intermediate representation (named S-{CGA}, a variant of clocked guarded actions), to integrate more synchronous programs into our compiler prototype in the future. The front-end of the compiler, i.e., the translation from {SIGNAL} to S-{CGA}, is presented. As well, the proof of semantics preservation is mechanized in the theorem prover Coq. Moreover, we present the back-end of the compiler, including sequential code generation and multithreaded code generation with time-predictable properties. With the rising importance of multi-core processors in safety-critical embedded systems or cyber-physical systems ({CPS}), there is a growing need for model-driven generation of multithreaded code and thus mapping on multi-core. We propose a time-predictable multi-core architecture model in architecture analysis and design language ({AADL}), and map the multi-threaded code to this model.},
	pages = {37--53},
	number = {1},
	journaltitle = {Frontiers of Computer Science},
	shortjournal = {Front. Comput. Sci.},
	author = {Yang, Zhibin and Bodeveix, Jean-Paul and Filali, Mamoun and Hu, Kai and Zhao, Yongwang and Ma, Dianfu},
	urldate = {2020-01-21},
	date = {2016-02-01},
	langid = {english},
	keywords = {Coq, architecture analysis and design language ({AADL}), guarded actions, {SIGNAL}, synchronous languages, verified compiler},
	file = {Version acceptée:/home/iampietro/Zotero/storage/4HC3UKV2/Yang et al. - 2016 - Towards a verified compiler prototype for the sync.pdf:application/pdf}
}

@article{Leroy2009,
	title = {A Formally Verified Compiler Back-end},
	volume = {43},
	issn = {1573-0670},
	url = {https://doi.org/10.1007/s10817-009-9155-4},
	doi = {10.1007/s10817-009-9155-4},
	abstract = {This article describes the development and formal verification (proof of semantic preservation) of a compiler back-end from Cminor (a simple imperative intermediate language) to {PowerPC} assembly code, using the Coq proof assistant both for programming the compiler and for proving its soundness. Such a verified compiler is useful in the context of formal methods applied to the certification of critical software: the verification of the compiler guarantees that the safety properties proved on the source code hold for the executable compiled code as well.},
	pages = {363},
	number = {4},
	journaltitle = {Journal of Automated Reasoning},
	shortjournal = {J Autom Reasoning},
	author = {Leroy, Xavier},
	urldate = {2020-01-21},
	date = {2009-11-04},
	langid = {english},
	keywords = {Compiler transformations and optimizations, Compiler verification, Formal methods, Program proof, Semantic preservation, The Coq theorem prover},
	file = {Springer Full Text PDF:/home/iampietro/Zotero/storage/R2WMM385/Leroy - 2009 - A Formally Verified Compiler Back-end.pdf:application/pdf}
}

@article{Oliva1995,
	title = {The {VLISP} verified {PreScheme} compiler},
	volume = {8},
	issn = {1573-0557},
	url = {https://doi.org/10.1007/BF01128408},
	doi = {10.1007/BF01128408},
	abstract = {This paper describes a verified compiler for {PreScheme}, the implementation language for thevlisp run-time system. The compiler and proof were divided into three parts: A transformational front end that translates source text into a core language, a syntax-directed compiler that translates the core language into a combinator-based tree-manipulation language, and a linearizer that translates combinator code into code for an abstract stored-program machine with linear memory for both data and code. This factorization enabled different proof techniques to be used for the different phases of the compiler, and also allowed the generation of good code. Finally, the whole process was made possible by carefully defining the semantics ofvlisp {PreScheme} rather than just adopting Scheme's. We believe that the architecture of the compiler and its correctness proof can easily be applied to compilers for languages other than {PreScheme}.},
	pages = {111--182},
	number = {1},
	journaltitle = {{LISP} and Symbolic Computation},
	shortjournal = {Lisp and Symbolic Computation},
	author = {Oliva, Dino P. and Ramsdell, John D. and Wand, Mitchell},
	urldate = {2020-01-21},
	date = {1995-03-01},
	langid = {english},
	keywords = {compiler, verified},
	file = {Springer Full Text PDF:/home/iampietro/Zotero/storage/NDM22FYS/Oliva et al. - 1995 - The VLISP verified PreScheme compiler.pdf:application/pdf}
}

@inproceedings{Fredlund1990,
	location = {Berlin, Heidelberg},
	title = {An implementation of a translational semantics for an imperative language},
	isbn = {978-3-540-46395-5},
	doi = {10.1007/BFb0039064},
	series = {Lecture Notes in Computer Science},
	abstract = {We present a semantics for an imperative programming language, Lunsen, with constructs for concurrency and communication. The semantics is given through a translation into {CCS}. We have implemented this translation within the framework of the Concurrency Workbench, which is a tool for analysis of finite-state systems in {CCS}. The point of the translational semantics is that by imposing restrictions on Lunsen so that the semantics of a program is finite-state, we can analyze Lunsen programs automatically using the Concurrency Workbench. As an illustration we include an analysis of a mutual exclusion algorithm.},
	pages = {246--262},
	booktitle = {{CONCUR} '90 Theories of Concurrency: Unification and Extension},
	publisher = {Springer},
	author = {Fredlund, Lars-åke and Jonsson, Bengt and Parrow, Joachim},
	editor = {Baeten, J. C. M. and Klop, J. W.},
	date = {1990},
	langid = {english},
	keywords = {Concurrent Program, Critical Section, Imperative Language, Mutual Exclusion Algorithm, Procedure Call},
	file = {Springer Full Text PDF:/home/iampietro/Zotero/storage/IA4TECXW/Fredlund et al. - 1990 - An implementation of a translational semantics for.pdf:application/pdf}
}

@incollection{Delahaye2000,
	location = {Berlin, Heidelberg},
	title = {A Tactic Language for the System Coq},
	volume = {1955},
	isbn = {978-3-540-41285-4},
	url = {http://link.springer.com/10.1007/3-540-44404-1_7},
	abstract = {We propose a new tactic language for the system goq, which is intended to enrich the current tactic combinators (tacticals). This language is based on a functional core with recursors and matching operators for goq terms but also for proof contexts. It can be used directly in proof scripts or in toplevel de nitions (tactic de nitions). We show that the implementation of this language involves considerable changes in the interpretation of proof scripts, essentially due to the matching operators. We give some examples which solve small proof parts locally and some others which deal with non-trivial problems. Finally, we discuss the status of this meta-language with respect to the goq language and the implementation language of goq.},
	pages = {85--95},
	booktitle = {Logic for Programming and Automated Reasoning},
	publisher = {Springer Berlin Heidelberg},
	author = {Delahaye, David},
	editor = {Parigot, Michel and Voronkov, Andrei},
	urldate = {2020-01-23},
	date = {2000},
	langid = {english},
	doi = {10.1007/3-540-44404-1_7},
	file = {Delahaye - 2000 - A Tactic Language for the System Coq.pdf:/home/iampietro/Zotero/storage/WYNY6EHD/Delahaye - 2000 - A Tactic Language for the System Coq.pdf:application/pdf}
}

@inproceedings{Chargueraud2013,
	location = {Berlin, Heidelberg},
	title = {Pretty-Big-Step Semantics},
	isbn = {978-3-642-37036-6},
	doi = {10.1007/978-3-642-37036-6_3},
	series = {Lecture Notes in Computer Science},
	abstract = {In spite of the popularity of small-step semantics, big-step semantics remain used by many researchers. However, big-step semantics suffer from a serious duplication problem, which appears as soon as the semantics account for exceptions and/or divergence. In particular, many premises need to be copy-pasted across several evaluation rules. This duplication problem, which is particularly visible when scaling up to full-blown languages, results in formal definitions growing far bigger than necessary. Moreover, it leads to unsatisfactory redundancy in proofs. In this paper, we address the problem by introducing pretty-big-step semantics. Pretty-big-step semantics preserve the spirit of big-step semantics, in the sense that terms are directly related to their results, but they eliminate the duplication associated with big-step semantics.},
	pages = {41--60},
	booktitle = {Programming Languages and Systems},
	publisher = {Springer},
	author = {Charguéraud, Arthur},
	editor = {Felleisen, Matthias and Gardner, Philippa},
	date = {2013},
	langid = {english},
	keywords = {Evaluation Premise, Evaluation Rule, Exception Handler, Intermediate Term, Operational Semantic},
	file = {Springer Full Text PDF:/home/iampietro/Zotero/storage/8BZYTDI5/Charguéraud - 2013 - Pretty-Big-Step Semantics.pdf:application/pdf}
}

@thesis{Merzoug2018,
	title = {Validation formelle des systèmes numériques critiques : génération de l'espace d'états de réseaux de Petri exécutés en synchrone},
	url = {https://tel.archives-ouvertes.fr/tel-01704776},
	shorttitle = {Validation formelle des systèmes numériques critiques},
	abstract = {La méthodologie {HILECOP} a été élaborée pour la conception formelle de systèmes numériques complexes critiques ; elle couvre donc l'intégralité du processus, allant de la modélisation à la génération de code pour l’implantation sur la cible matérielle (composant électronique de type {FPGA}), en passant par la validation formelle. Or, si le modèle formel, les réseaux de Petri en l'occurrence, est par essence asynchrone, il est néanmoins exécuté de manière synchrone sur la cible. De fait, les approches d'analyse usuelles ne sont pas adaptées au sens où elles construisent des graphes d'états non conformes à l'évolution d'états réelle au sein de la cible. Dans l'objectif de gagner en confiance quant à la validité des résultats de l’analyse formelle, ces travaux visent à capturer les caractéristiques dites non-fonctionnelles, à les réifier sur le modèle et enfin à considérer leur impact à travers l’analyse. En d’autres termes, l’objectif est d’améliorer l’expressivité du modèle et la pertinence de l'analyse, en considérant des aspects comme la synchronisation d'horloge, le parallélisme effectif, le risque de blocage induit par l'expression conjointe d'un événement (condition) et d'une fenêtre temporelle d'occurrence, sans omettre la gestion des exceptions. Pour traiter tous ces aspects, nous avons proposé une nouvelle méthode d'analyse pour les réseaux de Petri temporels généralisés étendus interprétés exécutés en synchrone, en les transformant vers un formalisme équivalent analysable. Ce formalisme est associé avec une sémantique formelle intégrant toutes les aspects particuliers de l'exécution et un algorithme de construction d'un graphe d'états spécifique : le Graphe de Comportement Synchrone. Nos travaux ont été appliqués à un cas industriel, plus précisément à la validation du comportement de la partie numérique d'un neuro-stimulateur.},
	institution = {Université Montpellier},
	type = {phdthesis},
	author = {Merzoug, Ibrahim},
	urldate = {2020-02-10},
	date = {2018-01-15},
	langid = {french},
	file = {Full Text PDF:/home/iampietro/Zotero/storage/MIEAW9RC/Merzoug - 2018 - Validation formelle des systèmes numériques critiq.pdf:application/pdf;Snapshot:/home/iampietro/Zotero/storage/YDWQPESN/tel-01704776.html:text/html}
}

@thesis{Leroux2014,
	title = {Méthodologie de conception d'architectures numériques complexes : du formalisme à l’implémentation en passant par l'analyse, préservation de la conformité. Application aux neuroprothèses},
	url = {https://tel.archives-ouvertes.fr/tel-01766458},
	shorttitle = {Méthodologie de conception d'architectures numériques complexes},
	abstract = {Dans ce mémoire, la conception de systèmes numériques complexes, et notamment de systèmes embarqués critiques, est abordée au travers d'une méthodologie allant de la modélisation formelle à l'implantation sur {FPGA} : la méthodologie {HILECOP}. Celle-ci offre au concepteur la possibilité de représenter dans un modèle formel d'une part l'architecture du système selon un assemblage de composants, et d'autre part le comportement de ces composants et leur composition par réseaux de Petri temporels. Le modèle décrit est ensuite transformé automatiquement en un modèle implémentable (en langage {VHDL}) pour son exécution sur la cible matérielle, mais également en un modèle analysable pour permettre l'analyse formelle des propriétés du système. Les deux objectifs principaux des travaux présentés sont l'étude de la conformité d'un point de vue comportemental entre les différents modèles utilisés dans la méthodologie (modèle conçu, modèle implémentable et modèle analysable), ainsi que l'intégration d'un mécanisme de gestion efficace des exceptions. Ces travaux ont permis de fiabiliser l'implémentation du modèle et d'obtenir un modèle analysable plus pertinent par rapport au modèle conçu, dans le sens où il garantit l'inclusion du comportement du modèle conçu dans celui du modèle analysé et réduit, dans une certaine mesure, le risque d'explosion combinatoire. Les limites de la pertinence des résultats obtenus par analyse formelle sont de plus désormais connues. En ce qui concerne la gestion des exceptions, principalement étudiée au niveau comportemental, le mécanisme de la macro-place a été retenu et adapté aux contraintes fonctionnelles et non-fonctionnelles des systèmes embarqués critiques. L'apport de la macro-place et la conservation de la conformité ont pu être validés sur des modèles industriels relatifs à l'architecture numérique de neuroprothèses.},
	institution = {Université Montpellier {II} - Sciences et Techniques du Languedoc},
	type = {phdthesis},
	author = {Leroux, Hélène},
	urldate = {2020-02-10},
	date = {2014-10-28},
	langid = {french},
	file = {Full Text PDF:/home/iampietro/Zotero/storage/S5QY5MNY/Leroux - 2014 - Méthodologie de conception d'architectures numériq.pdf:application/pdf;Snapshot:/home/iampietro/Zotero/storage/74EIEPPM/tel-01111881.html:text/html}
}

@article{Breuer1995a,
	title = {A simple denotational semantics, proof theory and a validation condition generator for unit-delay {VHDL}},
	volume = {7},
	issn = {1572-8102},
	url = {https://doi.org/10.1007/BF01383872},
	doi = {10.1007/BF01383872},
	abstract = {A denotational semantics and a Hoare programming logic for a subset of the standard hardware description {languageVHDL} are set out here. Both define the behaviour of synchronously {clockedVHDL} simulators in declarative and compositional style. The logic is proved complete with respect to the denotational semantics and a natural implementation of the logic {inPROLOG} as a validation condition generator {forVHDL} is also described.},
	pages = {27--51},
	number = {1},
	journaltitle = {Formal Methods in System Design},
	shortjournal = {Form Method Syst Des},
	author = {Breuer, Peter T. and Fernández, Luis Sánchez and Kloos, Carlos Delgado},
	urldate = {2020-02-20},
	date = {1995-08-01},
	langid = {english},
	file = {Springer Full Text PDF:/home/iampietro/Zotero/storage/L8CV4MEB/Breuer et al. - 1995 - A simple denotational semantics, proof theory and .pdf:application/pdf}
}

@inproceedings{Braibant2013,
	location = {Berlin, Heidelberg},
	title = {Formal Verification of Hardware Synthesis},
	isbn = {978-3-642-39799-8},
	doi = {10.1007/978-3-642-39799-8_14},
	series = {Lecture Notes in Computer Science},
	abstract = {We report on the implementation of a certified compiler for a high-level hardware description language ({HDL}) called Fe-Si ({FEatherweight} {SynthesIs}). Fe-Si is a simplified version of Bluespec, an {HDL} based on a notion of guarded atomic actions. Fe-Si is defined as a dependently typed deep embedding in Coq. The target language of the compiler corresponds to a synthesisable subset of Verilog or {VHDL}. A key aspect of our approach is that input programs to the compiler can be defined and proved correct inside Coq. Then, we use extraction and a Verilog back-end (written in {OCaml}) to get a certified version of a hardware design.},
	pages = {213--228},
	booktitle = {Computer Aided Verification},
	publisher = {Springer},
	author = {Braibant, Thomas and Chlipala, Adam},
	editor = {Sharygina, Natasha and Veith, Helmut},
	date = {2013},
	langid = {english},
	keywords = {Atomic Action, Hardware Description Language, Hardware Design, Memory Element, Transactional Memory},
	file = {Springer Full Text PDF:/home/iampietro/Zotero/storage/67YW7JK5/Braibant et Chlipala - 2013 - Formal Verification of Hardware Synthesis.pdf:application/pdf}
}

@incollection{Hansen2007,
	location = {Berlin, Heidelberg},
	title = {Semantics and Verification of a Language for Modelling Hardware Architectures},
	isbn = {978-3-540-75221-9},
	url = {https://doi.org/10.1007/978-3-540-75221-9_13},
	series = {Lecture Notes in Computer Science},
	abstract = {In this paper we consider a high-level hardware description language Gezel, from which hardware can be synthesized through a translation to {VHDL}. The language is equipped with a simulator and supports exploration of hardware designs. The language has no semantics and it is difficult to get a deep understanding of many of the constructions. We therefore give a semantic domain for Gezel. Aiming at automated verification we relate this domain to the timed-automata model and we have experimented with verification of Gezel-specifications using the Uppaal system. In particular, we have proven the correctness of a hardware specification of the Simplified {DES} algorithm. We have also used Uppaal for small experiments of verifying resource usage.},
	pages = {300--319},
	booktitle = {Formal Methods and Hybrid Real-Time Systems: Essays in Honor of Dines Bjørner and Chaochen Zhou on the Occasion of Their 70th Birthdays},
	publisher = {Springer},
	author = {Hansen, Michael R. and Madsen, Jan and Brekling, Aske Wiid},
	editor = {Jones, Cliff B. and Liu, Zhiming and Woodcock, Jim},
	urldate = {2020-02-20},
	date = {2007},
	langid = {english},
	doi = {10.1007/978-3-540-75221-9_13},
	keywords = {Hardware descriptions, model- checking, semantics, verification},
	file = {Springer Full Text PDF:/home/iampietro/Zotero/storage/DIAQAKIF/Hansen et al. - 2007 - Semantics and Verification of a Language for Model.pdf:application/pdf}
}

@article{Thirunarayan2001,
	title = {Structural Operational Semantics for a Portable Subset of Behavioral {VHDL}-93},
	volume = {18},
	issn = {1572-8102},
	url = {https://doi.org/10.1023/A:1008786720393},
	doi = {10.1023/A:1008786720393},
	abstract = {Goossens defined structural operational semantics for a subset of {VHDL}-87 and proved that the parallelism present in {VHDL} is benign. We extend this work to include {VHDL}-93 features such as shared variables and postponed processes that change the underlying semantic model. In the presence of shared variables, non-deterministic execution of {VHDL}-93 processes destroys the unique meaning property. We identify and characterize a class of portable {VHDL}-93 descriptions for which unique meaning property can be salvaged. We analyze the computability of the portability condition and show that portability checks are neither local nor static. Our formal specification can serve as a correctness criteria for a {VHDL}-93 simulator or can be used as a basis for coding a simulator.},
	pages = {69--88},
	number = {1},
	journaltitle = {Formal Methods in System Design},
	shortjournal = {Formal Methods in System Design},
	author = {Thirunarayan, Krishnaprasad and Ewing, Robert L.},
	urldate = {2020-03-02},
	date = {2001-01-01},
	langid = {english},
	file = {Springer Full Text PDF:/home/iampietro/Zotero/storage/92Y2KQKW/Thirunarayan et Ewing - 2001 - Structural Operational Semantics for a Portable Su.pdf:application/pdf}
}

@incollection{Olcoz1995,
	location = {Boston, {MA}},
	title = {A Formal Model of {VHDL} Using Coloured Petri Nets},
	isbn = {978-1-4615-2237-9},
	url = {https://doi.org/10.1007/978-1-4615-2237-9_6},
	series = {The Kluwer International Series in Engineering and Computer Science},
	abstract = {A formal model for {VHDL} which can cover all aspects of the language is proposed here, based on coloured Petri nets. The starting point is the interacting processes executable model of the language described in the language reference manual. The formal model will consist of the specification in Petri nets of the user-defined processes resulting from the elaboration of a {VHDL} description, plus the kernel process (simulator) and the communicating links between them.},
	pages = {140--169},
	booktitle = {Formal Semantics for {VHDL}},
	publisher = {Springer {US}},
	author = {Olcoz, Serafín},
	editor = {Kloos, Carlos Delgado and Breuer, Peter T.},
	urldate = {2020-03-02},
	date = {1995},
	langid = {english},
	doi = {10.1007/978-1-4615-2237-9_6},
	keywords = {Hardware Description Language, Executable Model, Kernel Process, Sequential Statement, Wait Statement},
	file = {Springer Full Text PDF:/home/iampietro/Zotero/storage/AD4KDNPL/Olcoz - 1995 - A Formal Model of VHDL Using Coloured Petri Nets.pdf:application/pdf}
}

@incollection{Dohmen1995,
	location = {Boston, {MA}},
	title = {A Deterministic Finite-State Model for {VHDL}},
	isbn = {978-1-4615-2237-9},
	url = {https://doi.org/10.1007/978-1-4615-2237-9_7},
	series = {The Kluwer International Series in Engineering and Computer Science},
	abstract = {In this chapter we present a method for translating {VHDL} ’87 into deterministic finitestate models. The method can handle those aspects of {VHDL} which have a finite representation and obtains the semantics defined in the {IEEE} standard. The model can be used to interface {VHDL} with {BDD}-based verification tools.},
	pages = {170--204},
	booktitle = {Formal Semantics for {VHDL}},
	publisher = {Springer {US}},
	author = {Döhmen, Gert and Herrmann, Ronald},
	editor = {Kloos, Carlos Delgado and Breuer, Peter T.},
	urldate = {2020-03-02},
	date = {1995},
	langid = {english},
	doi = {10.1007/978-1-4615-2237-9_7},
	keywords = {Sequential Statement, Auxiliary Function, Composition Operator, Data Space, Input Port},
	file = {Springer Full Text PDF:/home/iampietro/Zotero/storage/FBDRIJ7H/Döhmen et Herrmann - 1995 - A Deterministic Finite-State Model for VHDL.pdf:application/pdf}
}

@incollection{Reetz1995,
	location = {Boston, {MA}},
	title = {A Flow Graph Semantics of {VHDL}: A Basis for Hardware Verification with {VHDL}},
	isbn = {978-1-4615-2237-9},
	url = {https://doi.org/10.1007/978-1-4615-2237-9_8},
	series = {The Kluwer International Series in Engineering and Computer Science},
	shorttitle = {A Flow Graph Semantics of {VHDL}},
	abstract = {{VHDL}-based verification methods require a formal semantics of the language as a starting point. It has been shown recently that flow graphs are an excellent means for capturing such semantics. Our approach differs importantly from earlier work in that we use flow graphs as an intermediate for the “deep” embedding of {VHDL} in higher order logic. I.e., each {VHDL} program becomes a well-formed formula of the logic. This leads to a transparent semantics in which all constructs are explicitly conservative extensions to the underlying logic, which in turn allows reasoning about {VHDL} constructs to be carried out in the setting. As we provide a general framework, different verification techniques such as model-checking, first-order theorem proving or invariant-based approaches may be applied, depending on the verification task at hand. In particular, the separation of a flow graph into control flow and data flow components helps to structure the verification process.},
	pages = {205--238},
	booktitle = {Formal Semantics for {VHDL}},
	publisher = {Springer {US}},
	author = {Reetz, Ralf and Kropf, Thomas},
	editor = {Kloos, Carlos Delgado and Breuer, Peter T.},
	urldate = {2020-03-02},
	date = {1995},
	langid = {english},
	doi = {10.1007/978-1-4615-2237-9_8},
	keywords = {Flow Graph, High Order Logic, Place Node, Simulation Cycle, Variable Node},
	file = {Springer Full Text PDF:/home/iampietro/Zotero/storage/WM82IBX8/Reetz et Kropf - 1995 - A Flow Graph Semantics of VHDL A Basis for Hardwa.pdf:application/pdf}
}

@article{Masseron1993,
	title = {Generating plans in linear logic: I. actions as proofs},
	volume = {113},
	issn = {0304-3975},
	url = {http://www.sciencedirect.com/science/article/pii/030439759390007G},
	doi = {10.1016/0304-3975(93)90007-G},
	shorttitle = {Generating plans in linear logic},
	abstract = {There is an increasing interest in the relation between logic and the changes involved in reasoning and, specifically, in plan generation. Up to now, several attempts in this direction have been made, either by embedding actions into a classical framework or by using nonstandard formalisms. We think that these attempts, though promising, miss their objectives, for a lack of a suitable logic, and that the effort must be pursued. In this paper, we show how to obtain a strong and clean correspondence between proofs and sequences of actions by using only Girard's linear logic, eliminating from the classical logic the structural rules which are not adapted to our purpose. A theorem is presented which expresses the new adequacy between proofs and actions.},
	pages = {349--370},
	number = {2},
	journaltitle = {Theoretical Computer Science},
	shortjournal = {Theoretical Computer Science},
	author = {Masseron, M. and Tollu, C. and Vauzeilles, J.},
	urldate = {2020-03-03},
	date = {1993-06-07},
	langid = {english},
	file = {ScienceDirect Full Text PDF:/home/iampietro/Zotero/storage/AAKSAJDK/Masseron et al. - 1993 - Generating plans in linear logic I. actions as pr.pdf:application/pdf;ScienceDirect Snapshot:/home/iampietro/Zotero/storage/7IE9UF6F/030439759390007G.html:text/html}
}

@article{Pandey1999a,
	title = {{VHDL} semantics and validating transformations},
	volume = {18},
	issn = {1937-4151},
	doi = {10.1109/43.771177},
	abstract = {Formal models are used to provide an unambiguous definition of the semantics of very high speed integrated circuit hardware description language ({VHDL}) and to prove equivalences of {VHDL} programs. This paper presents a formal model of the dynamic semantics of {VHDL} that characterizes several important features of {VHDL} such as delta delays, pulse rejection limits, disconnection delays, postponed processes, sequential statements, and resolution functions. The underlying logic is interval temporal logic, which assists in characterizing the timing information contained in a {VHDL} program. The semantic definition is not dependent on the {VHDL} simulation cycle since it only defines the net effect of evaluating a {VHDL} program. It is argued that this declarative style coupled with the inherent advantages of temporal logic makes it possible to validate transformations (or rewrite rules) on {VHDL} programs and to formally reason about the timing aspects of {VHDL}. In particular, we present proofs of soundness of rewrite rules such as process folding and signal collapsing, and use temporal logic to derive an algorithm for determining when a given {VHDL} program is free of transaction preemption.},
	pages = {936--955},
	number = {7},
	journaltitle = {{IEEE} Transactions on Computer-Aided Design of Integrated Circuits and Systems},
	author = {Pandey, S.L. and Umamageswaran, K. and Wilsey, P.A.},
	date = {1999-07},
	note = {Conference Name: {IEEE} Transactions on Computer-Aided Design of Integrated Circuits and Systems},
	keywords = {Computational modeling, formal verification, Circuit simulation, Circuit synthesis, Delay, delays, delta delays, Design automation, disconnection delays, dynamic semantics, equivalences, formal models, hardware description languages, Hardware design languages, high level synthesis, interval temporal logic, Logic, postponed processes, process folding, programming language semantics, pulse rejection limits, resolution functions, rewrite rules, sequential statements, signal collapsing, temporal logic, Time warp simulation, timing, Timing, timing information, transaction preemption, very high speed integrated circuit hardware description language, very high speed integrated circuits, Very high speed integrated circuits, {VHDL} semantics},
	file = {00771177.pdf:/home/iampietro/Téléchargements/00771177.pdf:application/pdf;IEEE Xplore Abstract Record:/home/iampietro/Zotero/storage/WHPYKIZ9/771177.html:text/html}
}

@incollection{Gupta1993,
	location = {Boston, {MA}},
	title = {Formal Hardware Verification Methods: A Survey},
	isbn = {978-1-4615-3556-0},
	url = {https://doi.org/10.1007/978-1-4615-3556-0_2},
	shorttitle = {Formal Hardware Verification Methods},
	abstract = {Growing advances in {VLSI} technology have led to an increased level of complexity in current hardware systems. Late detection of design errors typically results in higher costs due to the associated time delay as well as loss of production. Thus it is important that hardware designs be free of errors. Formal verification has become an increasingly important technique towards establishing the correctness of hardware designs. In this article we survey the research that has been done in this area, with an emphasis on more recent trends. We present a classification framework for the various methods, based on the forms of the specification, the implementation, and the proof method. This framework enables us to better highlight the relationships and interactions between seemingly different approaches.},
	pages = {5--92},
	booktitle = {Computer-Aided Verification: A Special Issue of Formal Methods In System Design on Computer-Aided Verification},
	publisher = {Springer {US}},
	author = {Gupta, Aarti},
	editor = {Kurshan, Robert},
	urldate = {2020-03-16},
	date = {1993},
	langid = {english},
	doi = {10.1007/978-1-4615-3556-0_2},
	keywords = {formal verification, design correctness, hardware verification, proof methods, specification}
}

@article{Dederichs1993,
	title = {Focus: A Formal Design Method for Distributed Systems},
	url = {https://link.springer.com/chapter/10.1007/978-3-662-21577-7_14},
	doi = {10.1007/978-3-662-21577-7_14},
	shorttitle = {{\textless}Emphasis Type="{SmallCaps}"{\textgreater}Focus{\textless}/Emphasis{\textgreater}},
	abstract = {Focusis a formal method for the development of distributed systems. It covers all the way of formal system development in three abstraction levels: requirements specification, design specification,...},
	pages = {190--202},
	journaltitle = {Parallel Computer Architectures},
	author = {Dederichs, Frank and Dendorfer, Claus and Weber, Rainer},
	urldate = {2020-03-31},
	date = {1993},
	langid = {english},
	note = {Publisher: Springer, Berlin, Heidelberg},
	file = {Full Text PDF:/home/iampietro/Zotero/storage/QUGX7FBR/Dederichs et al. - 1993 - Emphasis Type=SmallCapsFocusEmphasis A For.pdf:application/pdf;Snapshot:/home/iampietro/Zotero/storage/PW6DLF7K/978-3-662-21577-7_14.html:text/html}
}

@report{Jones1994,
	title = {The implementation of the Gofer functional programming system},
	abstract = {The Gofer system is a functional programming environment for a small, Haskell-like language. Supporting a wide range of di erent machines, including home computers, the system is widely used, both for teaching and research.},
	pages = {52},
	institution = {Yale University, Department of Computer Science},
	author = {Jones, Mark P.},
	date = {1994-05},
	langid = {english},
	file = {Jones et Box - The implementation of the Gofer functional program.pdf:/home/iampietro/Zotero/storage/C362PADH/Jones et Box - The implementation of the Gofer functional program.pdf:application/pdf}
}

@inproceedings{Owre1994,
	title = {A tutorial on using {PVS} for hardware verification},
	url = {https://link.springer.com/chapter/10.1007/3-540-59047-1_53},
	doi = {10.1007/3-540-59047-1_53},
	abstract = {{PVS} stands for “Prototype Verification System.” It consists of a specification language integrated with support tools and a theorem prover. {PVS} tries to provide the mechanization needed to apply...},
	eventtitle = {International Conference on Theorem Provers in Circuit Design},
	pages = {258--279},
	booktitle = {Theorem Provers in Circuit Design},
	publisher = {Springer, Berlin, Heidelberg},
	author = {Owre, S. and Rushby, J. M. and Shankar, N. and Srivas, M. K.},
	urldate = {2020-03-31},
	date = {1994-09-26},
	langid = {english},
	file = {Full Text PDF:/home/iampietro/Zotero/storage/5X3TY34A/Owre et al. - 1994 - A tutorial on using PVS for hardware verification.pdf:application/pdf;Snapshot:/home/iampietro/Zotero/storage/AJBSFHJS/3-540-59047-1_53.html:text/html}
}

@article{Colmerauer1990,
	title = {An Introduction to Prolog {III}},
	url = {https://link.springer.com/chapter/10.1007/978-3-642-76274-1_2},
	doi = {10.1007/978-3-642-76274-1_2},
	abstract = {The Prolog {III} programming language extends Prolog by redefining the fundamental process at its heart: unification. Into this mechanism, Prolog {III} integrates refined processing of trees and lists,...},
	pages = {37--79},
	journaltitle = {Computational Logic},
	author = {Colmerauer, Alain},
	urldate = {2020-03-31},
	date = {1990},
	langid = {english},
	note = {Publisher: Springer, Berlin, Heidelberg},
	file = {Snapshot:/home/iampietro/Zotero/storage/4VSFGLYL/978-3-642-76274-1_2.html:text/html}
}

@inproceedings{Deharbe1995,
	title = {Semantics of a verification-oriented subset of {VHDL}},
	url = {https://link.springer.com/chapter/10.1007/3-540-60385-9_18},
	doi = {10.1007/3-540-60385-9_18},
	abstract = {This paper gives operational semantics for a subset of {VHDL} in terms of abstract machines. Restrictions to the {VHDL} source code are the finiteness of data types, and the absence of quantitative...},
	eventtitle = {Advanced Research Working Conference on Correct Hardware Design and Verification Methods},
	pages = {293--310},
	booktitle = {Correct Hardware Design and Verification Methods},
	publisher = {Springer, Berlin, Heidelberg},
	author = {Déharbe, David and Borrione, Dominique},
	urldate = {2020-04-01},
	date = {1995-10-02},
	langid = {english},
	file = {Full Text PDF:/home/iampietro/Zotero/storage/73BHYPQN/Déharbe et Borrione - 1995 - Semantics of a verification-oriented subset of VHD.pdf:application/pdf;Snapshot:/home/iampietro/Zotero/storage/LDGZZ5B9/3-540-60385-9_18.html:text/html}
}

@article{Shankar1997,
	title = {A Polymodal Semantics for {VHDL}},
	url = {https://link.springer.com/chapter/10.1007/978-0-387-35190-2_6},
	doi = {10.1007/978-0-387-35190-2_6},
	abstract = {This paper presents a formal semantics for a subset of {VHDL} that includes the basic control constructs, delta and unit delay signal assignment, variable assignment, and all forms of wait statements....},
	pages = {88--105},
	journaltitle = {Advances in Hardware Design and Verification},
	author = {Shankar, Subash and Slagle, James},
	urldate = {2020-04-01},
	date = {1997},
	langid = {english},
	note = {Publisher: Springer, Boston, {MA}},
	file = {Full Text PDF:/home/iampietro/Zotero/storage/XUUCXTGS/Shankar et Slagle - 1997 - A Polymodal Semantics for VHDL.pdf:application/pdf;Snapshot:/home/iampietro/Zotero/storage/SADMBGFC/10.html:text/html}
}

@inproceedings{Goossens1995,
	title = {Reasoning about {VHDL} using operational and observational semantics},
	url = {https://link.springer.com/chapter/10.1007/3-540-60385-9_19},
	doi = {10.1007/3-540-60385-9_19},
	abstract = {We define a Plotkin-style structural operational semantics for a subset of vhdlthat includes delta time, zero-delay scheduling and waits, arbitrary wait statements, and (commutative) resolution...},
	eventtitle = {Advanced Research Working Conference on Correct Hardware Design and Verification Methods},
	pages = {311--327},
	booktitle = {Correct Hardware Design and Verification Methods},
	publisher = {Springer, Berlin, Heidelberg},
	author = {Goossens, K. G. W.},
	urldate = {2020-04-01},
	date = {1995-10-02},
	langid = {english},
	file = {Full Text PDF:/home/iampietro/Zotero/storage/X9CAJY95/Goossens - 1995 - Reasoning about VHDL using operational and observa.pdf:application/pdf;Snapshot:/home/iampietro/Zotero/storage/DZLAMUT5/3-540-60385-9_19.html:text/html}
}

@article{Hutton1994,
	title = {Introduction to {HOL}: a theorem proving environment for higher order logic by Mike Gordon and Tom Melham (eds.), Cambridge University Press, 1993, {ISBN} 0-521-44189-7},
	volume = {4},
	issn = {1469-7653, 0956-7968},
	url = {https://www.cambridge.org/core/journals/journal-of-functional-programming/article/introduction-to-hol-a-theorem-proving-environment-for-higher-order-logic-by-gordon-mike-and-melham-tom-eds-cambridge-university-press-1993-isbn-0521441897/682CAD7058D7014549AE3F9580D0220B},
	doi = {10.1017/S0956796800001180},
	shorttitle = {Introduction to {HOL}},
	abstract = {//static.cambridge.org/content/id/urn\%3Acambridge.org\%3Aid\%3Aarticle\%3AS0956796800001180/resource/name/{firstPage}-S0956796800001180a.jpg},
	pages = {557--559},
	number = {4},
	journaltitle = {Journal of Functional Programming},
	author = {Hutton, Graham},
	urldate = {2020-04-22},
	date = {1994-10},
	langid = {english},
	note = {Publisher: Cambridge University Press},
	file = {Full Text PDF:/home/iampietro/Zotero/storage/CXZQ4VQN/Hutton - 1994 - Introduction to HOL a theorem proving environment.pdf:application/pdf;Snapshot:/home/iampietro/Zotero/storage/UMUMI36E/682CAD7058D7014549AE3F9580D0220B.html:text/html}
}

@article{Leroux2015,
	title = {Handling Exceptions in Petri Net-Based Digital Architecture: From Formalism to Implementation on {FPGAs}},
	volume = {11},
	issn = {1941-0050},
	doi = {10.1109/TII.2015.2435696},
	shorttitle = {Handling Exceptions in Petri Net-Based Digital Architecture},
	abstract = {A component-based approach to the specification and implementation of complex digital systems on field-programmable gate arrays ({FPGAs}) has been developed, with the behavior and composition of the components specified by Petri nets ({PNs}). Yet modeling behavior in the case of error becomes intricate if only {PNs} are used. In this case, the designer often has to address every possible situation when an error occurs, which leads to complex models and human errors. This paper offers a way to model exception handling by adding the concept of macroplace ({MP}) to the formalism while preserving the conformity and efficiency of the implementation on a programmable logic device (such as {FPGAs}), as well as the analyzability of the model.},
	pages = {897--906},
	number = {4},
	journaltitle = {{IEEE} Transactions on Industrial Informatics},
	author = {Leroux, Hélène and Andreu, David and Godary-Dejean, Karen},
	date = {2015-08},
	note = {Conference Name: {IEEE} Transactions on Industrial Informatics},
	keywords = {Petri nets, Semantics, Analytical models, complex digital systems, component-based approach, Data models, Digital systems, exception, Exception, field programmable gate arrays, Field programmable gate arrays, field-programmable gate array ({FPGA}), field-programmable gate arrays, {FPGA}, handling exceptions, implementation, Informatics, macroplace, macroplace ({MP}), Petri net-based digital architecture, Petri nets ({PNs}), {PN}, programmable logic device, validation},
	file = {IEEE Xplore Abstract Record:/home/iampietro/Zotero/storage/DVHAYHTI/7111285.html:text/html}
}

@article{Leroux2015a,
	title = {Handling Exceptions in Petri Net-Based Digital Architecture: From Formalism to Implementation on {FPGAs}},
	volume = {11},
	issn = {1941-0050},
	doi = {10.1109/TII.2015.2435696},
	shorttitle = {Handling Exceptions in Petri Net-Based Digital Architecture},
	abstract = {A component-based approach to the specification and implementation of complex digital systems on field-programmable gate arrays ({FPGAs}) has been developed, with the behavior and composition of the components specified by Petri nets ({PNs}). Yet modeling behavior in the case of error becomes intricate if only {PNs} are used. In this case, the designer often has to address every possible situation when an error occurs, which leads to complex models and human errors. This paper offers a way to model exception handling by adding the concept of macroplace ({MP}) to the formalism while preserving the conformity and efficiency of the implementation on a programmable logic device (such as {FPGAs}), as well as the analyzability of the model.},
	pages = {897--906},
	number = {4},
	journaltitle = {{IEEE} Transactions on Industrial Informatics},
	author = {Leroux, Hélène and Andreu, David and Godary-Dejean, Karen},
	date = {2015-08},
	note = {Conference Name: {IEEE} Transactions on Industrial Informatics},
	keywords = {Petri nets, Semantics, Analytical models, complex digital systems, component-based approach, Data models, Digital systems, exception, Exception, field programmable gate arrays, Field programmable gate arrays, field-programmable gate array ({FPGA}), field-programmable gate arrays, {FPGA}, handling exceptions, implementation, Informatics, macroplace, macroplace ({MP}), Petri net-based digital architecture, Petri nets ({PNs}), {PN}, programmable logic device, validation}
}

@article{Marranghello1998,
	title = {Digital systems synthesis from Petri net descriptions},
	rights = {Copyright (c)},
	issn = {2245-9316},
	url = {https://tidsskrift.dk/daimipb/article/view/7059},
	doi = {10.7146/dpb.v27i530.7059},
	abstract = {The design of digital systems has reached a degree of complexity that virtually prevents their effective realization without computer aided design tools. Several languages were already proposed to be used in such tools, each with the objective of capturing as much hardware characteristics as possible. During about the last fifteen years the importance and use of Petri nets as a language for modeling digital systems have greatly increased. Many computer aided design tools dealing with Petri nets for the analyzis, verification and synthesis of this sort of hardware have been recently developed as well. With such a growing importance in mind, this report aims at presenting an overview of the research going on the application of Petri nets to the description of digital systems and the synthesis of the corresponding hardware from these descriptions.},
	number = {530},
	journaltitle = {{DAIMI} Report Series},
	author = {Marranghello, Norian},
	urldate = {2020-05-19},
	date = {1998-03-01},
	langid = {english},
	note = {Number: 530},
	file = {Full Text PDF:/home/iampietro/Zotero/storage/GQYRDH6F/Marranghello - 1998 - Digital systems synthesis from Petri net descripti.pdf:application/pdf;Snapshot:/home/iampietro/Zotero/storage/B3BCHGF9/7059.html:text/html}
}

@incollection{Yakovlev2006,
	title = {Petri nets and digital hardware design},
	abstract = {Petri nets are a powerful language for describing processes in digital hardware, and particularly asynchronous or self-timed circuits. Self-timed circuits are designed to operate without the use of a global clock signal. Applications for such circuits are likely to increase during the next decade, due to problems with on-chip event coordination as {VLSI} technology approaches a density of one hundred million transistors per chip. Designing such circuits without help of formal tools does not seem to be possible. We present an overview of the methods for specification, verification and synthesis of asynchronous circuits with the aid of Petri nets. We present a number of design examples which are used to illustrate the authors' belief that Petri nets could become widely accepted by digital system designers as a design method.},
	pages = {154--236},
	booktitle = {Lecture Notes in Computer Science - {LNCS}},
	author = {Yakovlev, Alex and Koelmans, Albert},
	date = {2006-04-11},
	doi = {10.1007/3-540-65307-4_49},
	note = {Journal Abbreviation: Lecture Notes in Computer Science - {LNCS}},
	file = {Full Text PDF:/home/iampietro/Zotero/storage/QAY8SIH9/Yakovlev et Koelmans - 2006 - Petri nets and digital hardware design.pdf:application/pdf}
}

@article{Barrow1984,
	title = {Verify: A program for proving correctness of digital hardware designs},
	volume = {24},
	issn = {0004-3702},
	url = {http://www.sciencedirect.com/science/article/pii/0004370284900444},
	doi = {10.1016/0004-3702(84)90044-4},
	shorttitle = {Verify},
	abstract = {verify is a prolog program that attempts to prove the correctness of a digital design. It does so by showing that the behavior inferred from the interconnection of its parts and their behaviors is equivalent to the specified behavior. It has successfully verified large designs involving many thousands of transistors.},
	pages = {437--491},
	number = {1},
	journaltitle = {Artificial Intelligence},
	shortjournal = {Artificial Intelligence},
	author = {Barrow, Harry G.},
	urldate = {2020-05-19},
	date = {1984-12-01},
	langid = {english},
	file = {ScienceDirect Snapshot:/home/iampietro/Zotero/storage/9LEXZUUH/0004370284900444.html:text/html}
}

@inproceedings{Schreiner2016,
	title = {Digital Hardware Design Based on Metamodels and Model Transformations},
	url = {https://link.springer.com/chapter/10.1007/978-3-319-67104-8_5},
	doi = {10.1007/978-3-319-67104-8_5},
	abstract = {This contribution presents a Model-driven Architecture ({MDA}) inspired strategy for the automation of digital hardware design starting at specification level and targeting {RT}-level. This strategy...},
	eventtitle = {{IFIP}/{IEEE} International Conference on Very Large Scale Integration - System on a Chip},
	pages = {83--107},
	booktitle = {{VLSI}-{SoC}: System-on-Chip in the Nanoscale Era – Design, Verification and Reliability},
	publisher = {Springer, Cham},
	author = {Schreiner, Johannes and Ecker, Wolfgang},
	urldate = {2020-05-19},
	date = {2016-09-26},
	langid = {english},
	file = {Snapshot:/home/iampietro/Zotero/storage/35B6T4HJ/10.html:text/html;Version soumise:/home/iampietro/Zotero/storage/VQLDZ2TG/Schreiner et Ecker - 2016 - Digital Hardware Design Based on Metamodels and Mo.pdf:application/pdf}
}

@book{Friedenthal2014,
	title = {A Practical Guide to {SysML}: The Systems Modeling Language},
	isbn = {978-0-12-800800-3},
	shorttitle = {A Practical Guide to {SysML}},
	abstract = {A Practical Guide to {SysML}, Third Edition, fully updated for {SysML} version 1.4, provides a comprehensive and practical guide for modeling systems with {SysML}. With their unique perspective as leading contributors to the language, Friedenthal, Moore, and Steiner provide a full description of the language along with a quick reference guide and practical examples to help you use {SysML}. The book begins with guidance on the most commonly used features to help you get started quickly. Part 1 explains the benefits of a model-based approach, providing an overview of the language and how to apply {SysML} to model systems. Part 2 includes a comprehensive description of {SysML} that provides a detailed understanding that can serve as a foundation for modeling with {SysML}, and as a reference for practitioners. Part 3 includes methods for applying model-based systems engineering using {SysML} to specify and design systems, and how these methods can help manage complexity. Part 4 deals with topics related to transitioning {MBSE} practice into your organization, including integration of the system model with other engineering models, and strategies for adoption of {MBSE}.Learn how and why to deploy {MBSE} in your organization with an introduction to systems and model-based systems engineering Use {SysML} to describe systems with this general overview and a detailed description of the Systems Modeling Language Review practical examples of {MBSE} methodologies to understand their application to specifying and designing a {systemIncludes} comprehensive modeling notation tables as an appendix that can be used as a standalone reference},
	pagetotal = {631},
	publisher = {Morgan Kaufmann},
	author = {Friedenthal, Sanford and Moore, Alan and Steiner, Rick},
	date = {2014-10-23},
	langid = {english},
	note = {Google-Books-{ID}: Ze60AwAAQBAJ},
	keywords = {Computers / Programming / Object Oriented, Computers / Programming Languages / General, Computers / Systems Architecture / General, Technology \& Engineering / Engineering (General)}
}

@inproceedings{Yankova2007,
	title = {Automated {HDL} Generation: Comparative Evaluation},
	doi = {10.1109/ISCAS.2007.378622},
	shorttitle = {Automated {HDL} Generation},
	abstract = {Reconfigurable computing ({RC}) systems, coupling general purpose processor with reconfigurable components, offer a lot of advantages. Nevertheless, currently a designer needs both in-depth software and hardware design knowledge to develop applications for such platforms. The automated hardware generation addresses this problem. However, the success of such tools remains marginal. This paper discusses the reasons for the lack of success. It presents a quantitative and qualitative comparison of three hardware generators using the following criteria: quality of the hardware model, the supported {HLL} constructs, and the level of automation.},
	eventtitle = {2007 {IEEE} International Symposium on Circuits and Systems},
	pages = {2750--2753},
	booktitle = {2007 {IEEE} International Symposium on Circuits and Systems},
	author = {Yankova, Yana and Bertels, Koen and Vassiliadis, Stamatis and Meeuws, Roel and Virginia, Arcilio},
	date = {2007-05},
	note = {{ISSN}: 2158-1525},
	keywords = {Design automation, hardware description languages, Hardware design languages, Application software, automated hardware generation, automated {HDL} generation, comparative evaluation, Design optimization, electronic design automation, general purpose processor, high level languages, High level languages, Laboratories, microprocessor chips, reconfigurable computing systems, Software design, Software tools, Sparks, Testing},
	file = {IEEE Xplore Abstract Record:/home/iampietro/Zotero/storage/YIWJXHFN/4253247.html:text/html;IEEE Xplore Full Text PDF:/home/iampietro/Zotero/storage/SEZ9J5QD/Yankova et al. - 2007 - Automated HDL Generation Comparative Evaluation.pdf:application/pdf}
}

@article{Dyck2019,
	title = {Automatic verification of behavior preservation at the transformation level for relational model transformation},
	volume = {18},
	rights = {2018 The Author(s)},
	issn = {1619-1374},
	url = {https://link.springer.com/article/10.1007/s10270-018-00706-9},
	doi = {10.1007/s10270-018-00706-9},
	abstract = {The correctness of model transformations is a crucial element for model-driven engineering of high-quality software. In particular, behavior preservation is an important correctness property avoiding the introduction of semantic errors during the model-driven engineering process. Behavior preservation verification techniques show some kind of behavioral equivalence or refinement between source and target model of the transformation. Automatic tool support is available for verifying behavior preservation at the instance level, i.e., for a given source and target model specified by the model transformation. However, until now there is no sound and automatic verification approach available at the transformation level, i.e., for all source and target models. In this article, we extend our results presented in earlier work (Giese and Lambers, in: Ehrig et al (eds) Graph transformations, Springer, Berlin, 2012) and outline a new transformation-level approach for the sound and automatic verification of behavior preservation captured by bisimulation resp.\&nbsp;simulation for outplace model transformations specified by triple graph grammars and semantic definitions given by graph transformation rules. In particular, we first show how behavior preservation can be modeled in a symbolic manner at the transformation level and then describe that transformation-level verification of behavior preservation can be reduced to invariant checking of suitable conditions for graph transformations. We demonstrate that the resulting checking problem can be addressed by our own invariant checker for an example of a transformation between sequence charts and communicating automata.},
	pages = {2937--2972},
	number = {5},
	journaltitle = {Software \& Systems Modeling},
	shortjournal = {Softw Syst Model},
	author = {Dyck, Johannes and Giese, Holger and Lambers, Leen},
	urldate = {2020-05-22},
	date = {2019-10-01},
	langid = {english},
	note = {Company: Springer
Distributor: Springer
Institution: Springer
Label: Springer
Number: 5
Publisher: Springer Berlin Heidelberg},
	file = {Full Text PDF:/home/iampietro/Zotero/storage/W8CY5PIH/Dyck et al. - 2019 - Automatic verification of behavior preservation at.pdf:application/pdf;Snapshot:/home/iampietro/Zotero/storage/5N5QGSWM/10.html:text/html}
}

@article{Chlipala2010,
	title = {A verified compiler for an impure functional language},
	volume = {45},
	issn = {0362-1340},
	url = {https://doi.org/10.1145/1707801.1706312},
	doi = {10.1145/1707801.1706312},
	abstract = {We present a verified compiler to an idealized assembly language from a small, untyped functional language with mutable references and exceptions. The compiler is programmed in the Coq proof assistant and has a proof of total correctness with respect to big-step operational semantics for the source and target languages. Compilation is staged and includes standard phases like translation to continuation-passing style and closure conversion, as well as a common subexpression elimination optimization. In this work, our focus has been on discovering and using techniques that make our proofs easy to engineer and maintain. While most programming language work with proof assistants uses very manual proof styles, all of our proofs are implemented as adaptive programs in Coq's tactic language, making it possible to reuse proofs unchanged as new language features are added. In this paper, we focus especially on phases of compilation that rearrange the structure of syntax with nested variable binders. That aspect has been a key challenge area in past compiler verification projects, with much more effort expended in the statement and proof of binder-related lemmas than is found in standard pencil-and-paper proofs. We show how to exploit the representation technique of parametric higher-order abstract syntax to avoid the need to prove any of the usual lemmas about binder manipulation, often leading to proofs that are actually shorter than their pencil-and-paper analogues. Our strategy is based on a new approach to encoding operational semantics which delegates all concerns about substitution to the meta language, without using features incompatible with general-purpose type theories like Coq's logic.},
	pages = {93--106},
	number = {1},
	journaltitle = {{ACM} {SIGPLAN} Notices},
	shortjournal = {{SIGPLAN} Not.},
	author = {Chlipala, Adam},
	urldate = {2020-05-22},
	date = {2010-01-17},
	keywords = {compiler verification, interactive proof assistants},
	file = {Full Text PDF:/home/iampietro/Zotero/storage/ZSAHQ4U2/Chlipala - 2010 - A verified compiler for an impure functional langu.pdf:application/pdf}
}

@article{Leroy2009a,
	title = {A Formally Verified Compiler Back-end},
	volume = {43},
	rights = {2009 Springer Science+Business Media B.V.},
	issn = {1573-0670},
	url = {https://link.springer.com/article/10.1007/s10817-009-9155-4},
	doi = {10.1007/s10817-009-9155-4},
	abstract = {This article describes the development and formal verification (proof of semantic preservation) of a compiler back-end from Cminor (a simple imperative intermediate language) to {PowerPC} assembly code, using the Coq proof assistant both for programming the compiler and for proving its soundness. Such a verified compiler is useful in the context of formal methods applied to the certification of critical software: the verification of the compiler guarantees that the safety properties proved on the source code hold for the executable compiled code as well.},
	pages = {363--446},
	number = {4},
	journaltitle = {Journal of Automated Reasoning},
	shortjournal = {J Autom Reasoning},
	author = {Leroy, Xavier},
	urldate = {2020-05-22},
	date = {2009-12-01},
	langid = {english},
	note = {Company: Springer
Distributor: Springer
Institution: Springer
Label: Springer
Number: 4
Publisher: Springer Netherlands},
	file = {Full Text PDF:/home/iampietro/Zotero/storage/TLFGVM4I/Leroy - 2009 - A Formally Verified Compiler Back-end.pdf:application/pdf;Snapshot:/home/iampietro/Zotero/storage/JH4JP7CL/10.html:text/html}
}

@article{Dave2003,
	title = {Compiler verification: a bibliography},
	volume = {28},
	issn = {01635948},
	url = {http://portal.acm.org/citation.cfm?doid=966221.966235},
	doi = {10.1145/966221.966235},
	shorttitle = {Compiler verification},
	pages = {2},
	number = {6},
	journaltitle = {{ACM} {SIGSOFT} Software Engineering Notes},
	shortjournal = {{SIGSOFT} Softw. Eng. Notes},
	author = {Dave, Maulik A.},
	urldate = {2020-05-22},
	date = {2003-11-01},
	langid = {english},
	file = {Dave - 2003 - Compiler verification a bibliography.pdf:/home/iampietro/Zotero/storage/PFA4WVIC/Dave - 2003 - Compiler verification a bibliography.pdf:application/pdf}
}

@inproceedings{Blazy2006,
	title = {Formal Verification of a C Compiler Front-End},
	url = {https://link.springer.com/chapter/10.1007/11813040_31},
	doi = {10.1007/11813040_31},
	abstract = {This paper presents the formal verification of a compiler front-end that translates a subset of the C language into the Cminor intermediate language. The semantics of the source and target languages...},
	eventtitle = {International Symposium on Formal Methods},
	pages = {460--475},
	booktitle = {{FM} 2006: Formal Methods},
	publisher = {Springer, Berlin, Heidelberg},
	author = {Blazy, Sandrine and Dargaye, Zaynah and Leroy, Xavier},
	urldate = {2020-05-25},
	date = {2006-08-21},
	langid = {english},
	file = {Full Text PDF:/home/iampietro/Zotero/storage/TP2E4FDM/Blazy et al. - 2006 - Formal Verification of a C Compiler Front-End.pdf:application/pdf;Snapshot:/home/iampietro/Zotero/storage/CZBE9NCI/10.html:text/html}
}

@article{Calegari2013,
	title = {Verification of Model Transformations: A Survey of the State-of-the-Art},
	volume = {292},
	doi = {10.1016/j.entcs.2013.02.002},
	shorttitle = {Verification of Model Transformations},
	abstract = {Within the Model-Driven Engineering paradigm, software development is based on the definition of models providing different views of the system to be constructed and model transformations supporting a (semi)automatic development process. The verification of models and model transformations is crucial in order to improve the quality and the reliability of the products developed using this paradigm. In this context, the verification of a model transformation has three main components: the transformation itself, the properties of interest addressed, and the verification techniques used to establish the properties. In this paper we present an exhaustive review of the literature on the verification of model transformations analyzing these three components. We also take a problem-based approach exemplifying those aspects of interest that could be verified on a model transformation and show how this can be done. Finally, we conclude the need of an integrated environment for addressing the heterogeneous verification of model transformations.},
	pages = {5--25},
	journaltitle = {Electronic Notes in Theoretical Computer Science},
	shortjournal = {Electronic Notes in Theoretical Computer Science},
	author = {Calegari, Daniel and Szasz, Nora},
	date = {2013-03-05},
	file = {Full Text PDF:/home/iampietro/Zotero/storage/PZ5LUYHT/Calegari et Szasz - 2013 - Verification of Model Transformations A Survey of.pdf:application/pdf}
}

@article{Combemale2009,
	title = {Essay on Semantics Definition in {MDE}. An Instrumented Approach for Model Verification},
	volume = {4},
	doi = {10.4304/jsw.4.9.943-958},
	abstract = {In the context of {MDE} (Model-Driven Engineering), our objective is to define the semantics for a given {DSL} (Domain Specific Language) either to simulate its models or to check properties on them using model-checking techniques. In both cases, the purpose is to formalize the {DSL} semantics as it is known by the {DSL} designer but often in an informal way. After several experiments to define operational semantics on the one hand, and translational semantics on the other hand, we discuss both approaches and we specify in which cases these semantics seem to be judicious. As a second step, we introduce a pragmatic and instrumented approach to define a translational semantics and to validate it against a reference operational semantics expressed by the {DSL} designer. We apply this approach to the {xSPEM} process description language in order to verify process models.},
	journaltitle = {Journal of Software},
	shortjournal = {Journal of Software},
	author = {Combemale, Benoît and Crégut, Xavier and Garoche, Pierre-Loic and Thirioux, Xavier},
	date = {2009-11-01},
	file = {Version soumise:/home/iampietro/Zotero/storage/5WBWKZB5/Combemale et al. - 2009 - Essay on Semantics Definition in MDE. An Instrumen.pdf:application/pdf}
}

@inproceedings{Baresi2006,
	title = {Verification of Model Transformations: A Case Study with {BPEL}},
	url = {https://link.springer.com/chapter/10.1007/978-3-540-75336-0_12},
	doi = {10.1007/978-3-540-75336-0_12},
	shorttitle = {Verification of Model Transformations},
	abstract = {Model transformations, like refinement or refactoring, have to respect the semantics of the models transformed. In the case of behavioural models this semantics can be specified by transformations,...},
	eventtitle = {International Symposium on Trustworthy Global Computing},
	pages = {183--199},
	booktitle = {Trustworthy Global Computing},
	publisher = {Springer, Berlin, Heidelberg},
	author = {Baresi, Luciano and Ehrig, Karsten and Heckel, Reiko},
	urldate = {2020-05-25},
	date = {2006-11-07},
	langid = {english},
	file = {Full Text PDF:/home/iampietro/Zotero/storage/5NPX5PYB/Baresi et al. - 2006 - Verification of Model Transformations A Case Stud.pdf:application/pdf;Snapshot:/home/iampietro/Zotero/storage/KJSB5V8D/978-3-540-75336-0_12.html:text/html}
}

@inproceedings{Lano2010,
	title = {Specification and Verification of Model Transformations Using {UML}-{RSDS}},
	url = {https://link.springer.com/chapter/10.1007/978-3-642-16265-7_15},
	doi = {10.1007/978-3-642-16265-7_15},
	abstract = {In this paper we describe techniques for the specification and verification of model transformations using a combination of {UML} and formal methods. The use of {UML} 2 notations to specify model...},
	eventtitle = {International Conference on Integrated Formal Methods},
	pages = {199--214},
	booktitle = {Integrated Formal Methods},
	publisher = {Springer, Berlin, Heidelberg},
	author = {Lano, Kevin and Kolahdouz-Rahimi, Shekoufeh},
	urldate = {2020-05-25},
	date = {2010-10-11},
	langid = {english},
	file = {Full Text PDF:/home/iampietro/Zotero/storage/FWQGNPUP/Lano et Kolahdouz-Rahimi - 2010 - Specification and Verification of Model Transforma.pdf:application/pdf;Snapshot:/home/iampietro/Zotero/storage/T7D95DCU/978-3-642-16265-7_15.html:text/html}
}

@article{Hermann2010,
	title = {Specification and Verification of Model Transformations},
	volume = {30},
	rights = {Copyright (c)},
	issn = {1863-2122},
	url = {https://journal.ub.tu-berlin.de/eceasst/article/view/424},
	doi = {10.14279/tuj.eceasst.30.424},
	abstract = {Model transformations are a key concept within model driven development and there is an enormous need for suitable formal analysis techniques for model transformations,  in particular with respect to behavioural equivalence of source models and their corresponding target models. 

For this reason, we discuss the general challenges that arise for the specification and verification of model transformations and present suitable formal techniques that are based on graph transformation. In this context, triple graph grammars show many benefits for the specification process, e.g. modelers can work on an intuitive level of abstraction and there are formal results for syntactical correctness, completeness and efficient execution.  In order to verify model transformations with respect to behavioural equivalence we apply well-studied techniques based on the double pushout approach with borrowed context, for which the model transformations specified by triple graph transformation rules are flattened to plain (in-situ) graph transformation rules.

The potential and adequateness of the presented techniques are demonstrated by an intuitive example, for which we show the correctness of the model transformation with respect to bisimilarity of source and target models.},
	number = {0},
	journaltitle = {Electronic Communications of the {EASST}},
	author = {Hermann, Frank and Hülsbusch, Mathias and König, Barbara},
	urldate = {2020-05-25},
	date = {2010-11-01},
	langid = {english},
	note = {Number: 0},
	file = {Full Text PDF:/home/iampietro/Zotero/storage/KQ6YV2RQ/Hermann et al. - 2010 - Specification and Verification of Model Transforma.pdf:application/pdf;Snapshot:/home/iampietro/Zotero/storage/SJCU9D4A/424.html:text/html}
}

@article{Narayanan2008,
	title = {Towards Verifying Model Transformations},
	volume = {211},
	issn = {1571-0661},
	url = {http://www.sciencedirect.com/science/article/pii/S1571066108002569},
	doi = {10.1016/j.entcs.2008.04.041},
	series = {Proceedings of the Fifth International Workshop on Graph Transformation and Visual Modeling Techniques ({GT}-{VMT} 2006)},
	abstract = {In model-based software development, a complete design and analysis process involves designing the system using the design language, converting it into the analysis language, and performing the verification and analysis on the analysis model. Graph transformation is increasingly being used to automate this conversion. In such a scenario, it is very important that the conversion preserves the semantics of the design model. This paper discusses an approach to verify this semantic equivalence for each transformation. We will show how to check whether a particular transformation resulted in an output model that preserves the semantics of the input model with respect to a particular property.},
	pages = {191--200},
	journaltitle = {Electronic Notes in Theoretical Computer Science},
	shortjournal = {Electronic Notes in Theoretical Computer Science},
	author = {Narayanan, Anantha and Karsai, Gabor},
	urldate = {2020-05-25},
	date = {2008-04-28},
	langid = {english},
	keywords = {Verification, Bisimulation, Graph Transformation},
	file = {ScienceDirect Full Text PDF:/home/iampietro/Zotero/storage/F9V48R6L/Narayanan et Karsai - 2008 - Towards Verifying Model Transformations.pdf:application/pdf;ScienceDirect Snapshot:/home/iampietro/Zotero/storage/Y5BFWWEP/S1571066108002569.html:text/html}
}

@inproceedings{Rangel2008,
	title = {Behavior Preservation in Model Refactoring Using {DPO} Transformations with Borrowed Contexts},
	url = {https://link.springer.com/chapter/10.1007/978-3-540-87405-8_17},
	doi = {10.1007/978-3-540-87405-8_17},
	abstract = {Behavior preservation, namely the fact that the behavior of a model is not altered by the transformations, is a crucial property in refactoring. The most common approaches to behavior preservation...},
	eventtitle = {International Conference on Graph Transformation},
	pages = {242--256},
	booktitle = {Graph Transformations},
	publisher = {Springer, Berlin, Heidelberg},
	author = {Rangel, Guilherme and Lambers, Leen and König, Barbara and Ehrig, Hartmut and Baldan, Paolo},
	urldate = {2020-05-25},
	date = {2008-09-07},
	langid = {english},
	file = {Full Text PDF:/home/iampietro/Zotero/storage/8DPHIN37/Rangel et al. - 2008 - Behavior Preservation in Model Refactoring Using D.pdf:application/pdf;Snapshot:/home/iampietro/Zotero/storage/BSPBDWDS/978-3-540-87405-8_17.html:text/html}
}

@inproceedings{Fronc2011a,
	location = {Berlin, Heidelberg},
	title = {Towards a Certified Petri Net Model-Checker},
	isbn = {978-3-642-25318-8},
	doi = {10.1007/978-3-642-25318-8_24},
	series = {Lecture Notes in Computer Science},
	abstract = {Petri nets are widely used in the domain of automated verification through model-checking. In this approach, a Petri Net model of the system of interest is produced and its reachable states are computed, searching for erroneous executions. Model compilation can accelerate this analysis by generating code to explore the reachable states. This avoids the use of a fixed exploration tool involving an “interpretation” of the Petri net structure. In this paper, we show how to compile Petri nets targeting the {LLVM} language (a high-level assembly language) and formally prove the correctness of the produced code. To this aim, we define a structural operational semantics for the fragment of {LLVM} we use.},
	pages = {322--336},
	booktitle = {Programming Languages and Systems},
	publisher = {Springer},
	author = {Fronc, Lukasz and Pommereau, Franck},
	editor = {Yang, Hongseok},
	date = {2011},
	langid = {english},
	keywords = {explicit model-checking, {LLVM}, model compilation, {SOS}}
}

@inproceedings{Gomes2007,
	title = {From Petri net models to {VHDL} implementation of digital controllers},
	doi = {10.1109/IECON.2007.4460403},
	abstract = {Modeling of discrete-event systems using Petri net models is well-studied. Also, their usage for specification of digital controllers is widely used. Yet, it is recognized that we have a lack of tools when facing support for the implementation of these models, namely for automatic code generation. The paper briefly presents the {FORDESIGN} project that aims to develop a set of tools to contribute for filling this gap within automation systems and (networked) embedded systems development. The set of tools is based on a Petri net class, named as Input-Output Petri Net ({IOPT}), and its representation using the Petri Net Markup Language ({PNML}). The paper presents some rules used by an automatic code generator able to produce {VHDL} code starting with the {PNML} representation of the Petri net model.},
	eventtitle = {{IECON} 2007 - 33rd Annual Conference of the {IEEE} Industrial Electronics Society},
	pages = {94--99},
	booktitle = {{IECON} 2007 - 33rd Annual Conference of the {IEEE} Industrial Electronics Society},
	author = {Gomes, Luis and Costa, Aniko and Barros, Joao Paulo and Lima, Paulo},
	date = {2007-11},
	note = {{ISSN}: 1553-572X},
	keywords = {Petri nets, hardware description languages, automatic code generation, Automatic control, Automation, automation systems, control engineering computing, digital control, Digital control, digital controllers, discrete event systems, Discrete event systems, discrete-event systems, Embedded system, embedded systems development, Fires, {FORDESIGN} project, Industrial Electronics Society, input-output Petri Net, {IOPT}, Petri net markup language, Petri net models, {PNML}, program compilers, Synchronization, {VHDL} implementation},
	file = {IEEE Xplore Abstract Record:/home/iampietro/Zotero/storage/ZDSIQC3V/4460403.html:text/html}
}

@inproceedings{Wan2016,
	title = {Petri Net-based Modeling and {VHDL} Implementation of Digital Systems},
	isbn = {978-94-6252-213-8},
	url = {https://www.atlantis-press.com/proceedings/cset-16/25859234},
	doi = {10.2991/cset-16.2016.26},
	abstract = {Petri net-based digital systems modeling and hardware implementation method is well-studied. However, the existing methods are mainly applied to synchronous circuits. In this paper, a new approach is proposed for the modeling and {VHDL} implementation of digital systems based on an extended class of Petri nets. The generalized synchronous self-modifying...},
	eventtitle = {2016 International Conference on Computer Science and Electronic Technology},
	pages = {108--111},
	publisher = {Atlantis Press},
	author = {Wan, Jun},
	urldate = {2020-06-01},
	date = {2016-08},
	langid = {english},
	note = {{ISSN}: 2352-538X},
	file = {Full Text PDF:/home/iampietro/Zotero/storage/FTNLQADE/Wan - 2016 - Petri Net-based Modeling and VHDL Implementation o.pdf:application/pdf;Snapshot:/home/iampietro/Zotero/storage/GPFCT4UT/25859234.html:text/html}
}

@article{Prothero2000,
	title = {Modelling and Implementation of Petri Nets Using {VHDL}},
	url = {https://link.springer.com/chapter/10.1007/978-1-4757-3143-9_12},
	doi = {10.1007/978-1-4757-3143-9_12},
	abstract = {The use of Petri nets for the modelling of concurrent systems is longestablished. Their application in the field of digital design is to the specification and modelling of self-timed systems within...},
	pages = {223--236},
	journaltitle = {Hardware Design and Petri Nets},
	author = {Prothero, Dave},
	urldate = {2020-06-01},
	date = {2000},
	langid = {english},
	note = {Publisher: Springer, Boston, {MA}},
	file = {Full Text PDF:/home/iampietro/Zotero/storage/8JXBHYKR/Prothero - 2000 - Modelling and Implementation of Petri Nets Using V.pdf:application/pdf;Snapshot:/home/iampietro/Zotero/storage/RT229ZCB/978-1-4757-3143-9_12.html:text/html}
}

@article{Brambilla2012,
	title = {Model-Driven Software Engineering in Practice},
	volume = {1},
	issn = {2328-3319, 2328-3327},
	url = {http://www.morganclaypool.com/doi/abs/10.2200/S00441ED1V01Y201208SWE001},
	doi = {10.2200/S00441ED1V01Y201208SWE001},
	pages = {1--182},
	number = {1},
	journaltitle = {Synthesis Lectures on Software Engineering},
	shortjournal = {Synthesis Lectures on Software Engineering},
	author = {Brambilla, Marco and Cabot, Jordi and Wimmer, Manuel},
	urldate = {2020-06-01},
	date = {2012-09-21},
	langid = {english},
	file = {Brambilla et al. - 2012 - Model-Driven Software Engineering in Practice.pdf:/home/iampietro/Zotero/storage/V4BANK6D/Brambilla et al. - 2012 - Model-Driven Software Engineering in Practice.pdf:application/pdf}
}

@article{Lano2014,
	title = {Model-Transformation Design Patterns},
	volume = {40},
	doi = {10.1109/TSE.2014.2354344},
	abstract = {This paper defines a catalogue of patterns for the specification and design of model transformations, and provides a systematic scheme and classification of these patterns, together with pattern application examples in leading model transformation languages such as {ATL}, {QVT}, {GrGen}.{NET}, and others. We consider patterns for improving transformation modularization and efficiency and for reducing data storage requirements. We define a metamodel-based formalization of model transformation design patterns, and measurement-based techniques to guide the selection of patterns. We also provide an evaluation of the effectiveness of transformation patterns on a range of different case studies.},
	pages = {1224--1259},
	journaltitle = {Software Engineering, {IEEE} Transactions on},
	shortjournal = {Software Engineering, {IEEE} Transactions on},
	author = {Lano, Kevin and Kolahdouz Rahimi, Shekoufeh},
	date = {2014-12-01},
	file = {Full Text PDF:/home/iampietro/Zotero/storage/X4344AMD/Lano et Kolahdouz Rahimi - 2014 - Model-Transformation Design Patterns.pdf:application/pdf}
}

@article{Lano2018,
	title = {A survey of model transformation design patterns in practice},
	volume = {140},
	doi = {10.1016/j.jss.2018.03.001},
	pages = {48--73},
	journaltitle = {Journal of Systems and Software},
	shortjournal = {Journal of Systems and Software},
	author = {Lano, Kevin and Kolahdouz Rahimi, Shekoufeh and Yassipour Tehrani, Sobhan and Sharbaf, Mohammadreza},
	date = {2018-06-01},
	file = {Full Text PDF:/home/iampietro/Zotero/storage/S5JRL8XZ/Lano et al. - 2018 - A survey of model transformation design patterns i.pdf:application/pdf}
}

@article{Andreu2009,
	title = {A distributed architecture for activating the peripheral nervous system},
	volume = {6},
	issn = {1741-2560, 1741-2552},
	url = {https://iopscience.iop.org/article/10.1088/1741-2560/6/2/026001},
	doi = {10.1088/1741-2560/6/2/026001},
	abstract = {We present a new system for functional electrical stimulation ({FES}) applications based on networked stimulation units. They embed an advanced analog circuit, which provides multipolar and multiphasic stimulation proﬁles, and digital circuits, which ensure safety, locally executed programmed proﬁles, and communication with the master controller. This architecture is thus based on distributed stimulation units ({DSU}) that need only a two-wire bus to communicate, regardless of the number of poles of each {DSU}-driven electrode. This structure minimizes the required bandwidth between master and distributed units, increases the safety and stimulation features and decreases the complexity of the surgical approach. We have successfully tested this network-based stimulation architecture on benchtop stimulators. This original approach allows broad exploration of all possible methods to stimulate peripheral nerves, particularly in the goal of restoring the motor function. It provides a powerful research device to determine the optimal, least aggressive and the most efﬁcient way to activate the peripheral nervous system using an implanted {FES} system that is less invasive than other existing devices.},
	pages = {026001},
	number = {2},
	journaltitle = {Journal of Neural Engineering},
	shortjournal = {J. Neural Eng.},
	author = {Andreu, David and Guiraud, David and Souquet, Guillaume},
	urldate = {2020-06-08},
	date = {2009-04-01},
	langid = {english},
	file = {Andreu et al. - 2009 - A distributed architecture for activating the peri.pdf:/home/iampietro/Zotero/storage/DXYZXMAI/Andreu et al. - 2009 - A distributed architecture for activating the peri.pdf:application/pdf}
}

@inproceedings{Strecker2002,
	title = {Formal Verification of a Java Compiler in Isabelle},
	url = {https://link.springer.com/chapter/10.1007/3-540-45620-1_5},
	doi = {10.1007/3-540-45620-1_5},
	abstract = {This paper reports on the formal proof of correctness of a compiler from a substantial subset of Java source language to Java bytecode in the proof environment Isabelle. This work is based on...},
	eventtitle = {International Conference on Automated Deduction},
	pages = {63--77},
	booktitle = {Automated Deduction—{CADE}-18},
	publisher = {Springer, Berlin, Heidelberg},
	author = {Strecker, Martin},
	urldate = {2020-06-08},
	date = {2002-07-27},
	langid = {english},
	file = {Full Text PDF:/home/iampietro/Zotero/storage/HNSKGTY7/Strecker - 2002 - Formal Verification of a Java Compiler in Isabelle.pdf:application/pdf;Snapshot:/home/iampietro/Zotero/storage/SQCWSLSS/3-540-45620-1_5.html:text/html}
}

@inproceedings{Bandyopadhyay2015,
	title = {Validating {SPARK}: High Level Synthesis Compiler},
	doi = {10.1109/ISVLSI.2015.56},
	shorttitle = {Validating {SPARK}},
	abstract = {Embedded systems have found applications in diverse domains. Due to the criticality of their operations, verification of embedded systems is a necessity. With the advancement of multi-core and multiprocessor systems, there has been a paradigm shift to incorporate these features in embedded systems as well. The initial behavioural specification of a system goes through significant optimizing transformations using automated high level synthesis ({HLS}) compiler like {SPARK}, before being mapped to an architecture. Establishing the validity of these transformations is crucial to ensure that correct optimizations are applied during synthesis. To model parallel behaviours, especially in embedded systems, the use of {PRES}+ models is advocated for. In this paper, two path based equivalence checking methods foruntimed {PRES}+ models are given. The experimental results demonstrate the efficiency the of the method.},
	eventtitle = {2015 {IEEE} Computer Society Annual Symposium on {VLSI}},
	pages = {195--198},
	booktitle = {2015 {IEEE} Computer Society Annual Symposium on {VLSI}},
	author = {Bandyopadhyay, Soumyadip and Sarkar, Dipankar and Mandal, Chittaranjan},
	date = {2015-07},
	note = {{ISSN}: 2159-3477},
	keywords = {Computational modeling, formal verification, Petri nets, high level synthesis, Data models, Sparks, program compilers, embedded systems, Embedded systems, embedded systems verification, Equivalence checking, equivalence checking methods, equivalence classes, {FSMD} model, High level synthesis, high level synthesis compiler, {HLS}, {HLS} compiler, multicore systems, multiprocessing programs, multiprocessor systems, {PRES}+ model, {PRES}+ models, {SPARK}, Very large scale integration},
	file = {IEEE Xplore Abstract Record:/home/iampietro/Zotero/storage/SNH2HP6X/7309563.html:text/html}
}

@article{Hansen2007a,
	title = {Semantics and Verification of a Language for Modelling Hardware Architectures},
	url = {https://link.springer.com/chapter/10.1007/978-3-540-75221-9_13},
	doi = {10.1007/978-3-540-75221-9_13},
	abstract = {In this paper we consider a high-level hardware description language Gezel, from which hardware can be synthesized through a translation to {VHDL}. The language is equipped with a simulator and...},
	pages = {300--319},
	journaltitle = {Formal Methods and Hybrid Real-Time Systems},
	author = {Hansen, Michael R. and Madsen, Jan and Brekling, Aske Wiid},
	urldate = {2020-07-01},
	date = {2007},
	langid = {english},
	note = {Publisher: Springer, Berlin, Heidelberg},
	file = {Full Text PDF:/home/iampietro/Zotero/storage/FKWBYJWE/Hansen et al. - 2007 - Semantics and Verification of a Language for Model.pdf:application/pdf;Snapshot:/home/iampietro/Zotero/storage/FARYWJN7/978-3-540-75221-9_13.html:text/html}
}

@article{Edwards1997,
	title = {Design of embedded systems: formal models, validation, and synthesis},
	volume = {85},
	issn = {1558-2256},
	doi = {10.1109/5.558710},
	shorttitle = {Design of embedded systems},
	abstract = {This paper addresses the design of reactive real-time embedded systems. Such systems are often heterogeneous in implementation technologies and design styles, for example by combining hardware application-specific integrated circuits ({ASICs}) with embedded software. The concurrent design process for such embedded systems involves solving the specification, validation, and synthesis problems. We review the variety of approaches to these problems that have been taken.},
	pages = {366--390},
	number = {3},
	journaltitle = {Proceedings of the {IEEE}},
	author = {Edwards, S. and Lavagno, L. and Lee, E.A. and Sangiovanni-Vincentelli, A.},
	date = {1997-03},
	note = {Conference Name: Proceedings of the {IEEE}},
	keywords = {formal verification, formal specification, formal models, specification, Application software, Embedded system, application specific integrated circuits, Application specific integrated circuits, application-specific integrated circuits, {ASIC}, computer architecture, Computer architecture, concurrent design process, Consumer electronics, Embedded computing, embedded software, embedded systems design, formal validation, Hardware, heterogeneous systems, logic design, Microcontrollers, reactive real-time system design, Real time systems, real-time systems, Safety, systems analysis},
	file = {IEEE Xplore Abstract Record:/home/iampietro/Zotero/storage/HLXJCJIG/558710.html:text/html;IEEE Xplore Full Text PDF:/home/iampietro/Zotero/storage/2JCC9S23/Edwards et al. - 1997 - Design of embedded systems formal models, validat.pdf:application/pdf}
}

@inproceedings{Schneider2000,
	title = {A Verified Hardware Synthesis of Esterel Programs},
	url = {https://link.springer.com/chapter/10.1007/978-0-387-35409-5_20},
	doi = {10.1007/978-0-387-35409-5_20},
	abstract = {Synchronous programming languages like Esterel are becoming more and more popular for the design of multi-threaded reactive systems. We have embedded a variant of the Esterel language in the...},
	eventtitle = {{IFIP} Working Conference on Distributed and Parallel Embedded Systems},
	pages = {205--214},
	booktitle = {Architecture and Design of Distributed Embedded Systems},
	publisher = {Springer, Boston, {MA}},
	author = {Schneider, Klaus},
	urldate = {2020-07-01},
	date = {2000-10-18},
	langid = {english},
	file = {Full Text PDF:/home/iampietro/Zotero/storage/MQ8MH4N8/Schneider - 2000 - A Verified Hardware Synthesis of Esterel Programs.pdf:application/pdf;Snapshot:/home/iampietro/Zotero/storage/FDYSNZDK/978-0-387-35409-5_20.html:text/html}
}

@article{Borrione1992,
	title = {Formal verification of {VHDL} descriptions in the Prevail environment},
	volume = {9},
	issn = {1558-1918},
	doi = {10.1109/54.143145},
	abstract = {Prevail, a formal verification environment for proving the equivalence of two very-high-speed integrated circuit hardware description language ({VHDL}) design architectures, is described. For simple bit-level combinational descriptions, the environment calls upon a tautology checker. For parameterized repetitive structures and for more abstract sequential designs, the program translates descriptions into recursive functions according to predefined templates and generates a theorem acceptable to the Bover-Moore theorem prover. The specification, implementation, and functional representation of a sequential example are presented.{\textless}{\textgreater}},
	pages = {42--56},
	number = {2},
	journaltitle = {{IEEE} Design Test of Computers},
	author = {Borrione, D.D. and Pierre, L.V. and Salem, A.M.},
	date = {1992-06},
	note = {Conference Name: {IEEE} Design Test of Computers},
	keywords = {Calculus, theorem proving, formal specification, Formal verification, Mathematical model, Timing, Hardware, Adders, bit-level combinational, Bover-Moore theorem prover, Circuit testing, Combinational circuits, equivalence proving, formal verification environment, Logic circuits, Mathematics, parameterized repetitive structures, Prevail environment, programming environments, recursive functions, specification languages, tautology checker, templates, very-high-speed integrated circuit hardware description language, {VHDL}, {VHDL} descriptions, {VLSI}},
	file = {IEEE Xplore Abstract Record:/home/iampietro/Zotero/storage/EL4BM3I5/143145.html:text/html;IEEE Xplore Full Text PDF:/home/iampietro/Zotero/storage/AVNJVUZV/Borrione et al. - 1992 - Formal verification of VHDL descriptions in the Pr.pdf:application/pdf}
}

@thesis{Braibant2012,
	title = {Algèbres de Kleene, réécriture modulo {AC} et circuits en coq},
	url = {https://tel.archives-ouvertes.fr/tel-00683661},
	abstract = {Cette thèse décrit trois travaux de formalisation en Coq. Le premier chapitre s'intéresse à l'implémentation d'une procédure de décision efficace pour les algèbres de Kleene, pour lesquelles le modèle des langages réguliers est initial : il est possible de décider la théorie équationelle des algèbres de Kleene via la construction et la comparaison d'automates finis. Le second chapitre est consacré à la définition de tactiques pour la réécriture modulo associativité et commutativité en utilisant deux composants : une procédure de décision réflexive pour l'égalité modulo {AC}, ainsi qu'un greffon {OCaml} implémentant le filtrage modulo {AC}. Le dernier chapitre esquisse une formalisation des circuits digitaux via un plongement profond utilisant les types dépendants de Coq ; on s'intéresse ensuite à prouver la correction totale de circuits paramétriques.},
	institution = {Université de Grenoble},
	type = {phdthesis},
	author = {Braibant, Thomas},
	urldate = {2020-07-01},
	date = {2012-02-17},
	langid = {french},
	file = {Full Text PDF:/home/iampietro/Zotero/storage/MMHDAJZZ/Braibant - 2012 - Algèbres de Kleene, réécriture modulo AC et circui.pdf:application/pdf;Snapshot:/home/iampietro/Zotero/storage/2DPSS2K4/tel-00683661.html:text/html}
}

@article{Barrow1984a,
	title = {Verify: A program for proving correctness of digital hardware designs},
	volume = {24},
	issn = {0004-3702},
	url = {http://www.sciencedirect.com/science/article/pii/0004370284900444},
	doi = {10.1016/0004-3702(84)90044-4},
	shorttitle = {Verify},
	abstract = {verify is a prolog program that attempts to prove the correctness of a digital design. It does so by showing that the behavior inferred from the interconnection of its parts and their behaviors is equivalent to the specified behavior. It has successfully verified large designs involving many thousands of transistors.},
	pages = {437--491},
	number = {1},
	journaltitle = {Artificial Intelligence},
	shortjournal = {Artificial Intelligence},
	author = {Barrow, Harry G.},
	urldate = {2020-07-03},
	date = {1984-12-01},
	langid = {english},
	file = {ScienceDirect Full Text PDF:/home/iampietro/Zotero/storage/BGDS8VIS/Barrow - 1984 - Verify A program for proving correctness of digit.pdf:application/pdf;ScienceDirect Snapshot:/home/iampietro/Zotero/storage/YGMGI3XC/0004370284900444.html:text/html}
}

@incollection{Meijer1995,
	location = {Berlin, Heidelberg},
	title = {Merging monads and folds for functional programming},
	volume = {925},
	isbn = {978-3-540-59451-2 978-3-540-49270-2},
	url = {http://link.springer.com/10.1007/3-540-59451-5_7},
	abstract = {These notes discuss the simultaneous use of generalised fold operators and monads to structure functional programs. Generalised fold operators structure programs after the decomposition of the value they consume. Monads structure programs after the computation of the value they produce. Our programs abstract both from the recursive processing of their input as well as from the side-e ects in computing their output. We show how generalised monadic folds aid in calculating an e cient graph reduction engine from an ine cient speci cation.},
	pages = {228--266},
	booktitle = {Advanced Functional Programming},
	publisher = {Springer Berlin Heidelberg},
	author = {Meijer, Erik and Jeuring, Johan},
	editor = {Jeuring, Johan and Meijer, Erik},
	editorb = {Goos, Gerhard and Hartmanis, Juris and Leeuwen, Jan},
	editorbtype = {redactor},
	urldate = {2020-08-27},
	date = {1995},
	langid = {english},
	doi = {10.1007/3-540-59451-5_7},
	note = {Series Title: Lecture Notes in Computer Science},
	file = {Meijer et Jeuring - 1995 - Merging monads and folds for functional programmin.pdf:/home/iampietro/Zotero/storage/SIQQ5PUC/Meijer et Jeuring - 1995 - Merging monads and folds for functional programmin.pdf:application/pdf}
}

@article{Milea,
	title = {Program Termination Proofs},
	abstract = {Proving termination of programs is an undecidable problem. In this work we provide a sound method for proving the termination of a certain class of programs by using the power of linear programming tools. We handle while-loops with a simple loop condition where the assignment of the variables is nondeterministically-chosen out of a set of possible linear assignments. We implement a simple eﬃcient tool for proving termination and compare it with other existing tools.},
	pages = {15},
	author = {Milea, Tal},
	langid = {english},
	file = {Milea - Program Termination Proofs.pdf:/home/iampietro/Zotero/storage/5HQ68K8N/Milea - Program Termination Proofs.pdf:application/pdf}
}

@article{Cook2011,
	title = {Proving program termination},
	volume = {54},
	issn = {0001-0782, 1557-7317},
	url = {https://dl.acm.org/doi/10.1145/1941487.1941509},
	doi = {10.1145/1941487.1941509},
	pages = {88--98},
	number = {5},
	journaltitle = {Communications of the {ACM}},
	shortjournal = {Commun. {ACM}},
	author = {Cook, Byron and Podelski, Andreas and Rybalchenko, Andrey},
	urldate = {2020-09-03},
	date = {2011-05},
	langid = {english},
	file = {Cook et al. - 2011 - Proving program termination.pdf:/home/iampietro/Zotero/storage/ISRMJXQV/Cook et al. - 2011 - Proving program termination.pdf:application/pdf}
}

@online{zotero-314,
	title = {{CEUR}-{WS}.org/Vol-2651 - International Workshop on Petri Nets and Software Engineering ({PNSE} 2020)},
	url = {http://ceur-ws.org/Vol-2651/},
	urldate = {2020-09-09},
	file = {CEUR-WS.org/Vol-2651 - International Workshop on Petri Nets and Software Engineering (PNSE 2020):/home/iampietro/Zotero/storage/JB8E2BZK/Vol-2651.html:text/html}
}

@article{Iampietro,
	title = {Toward the Formal Veriﬁcation of {HILECOP}: Formalization and Implementation of Synchronously Executed Petri Nets},
	pages = {2},
	author = {Iampietro, Vincent and Andreu, David and Delahaye, David},
	langid = {english},
	file = {Iampietro et al. - Toward the Formal Veriﬁcation of HILECOP Formaliz.pdf:/home/iampietro/Zotero/storage/RJB6XJL7/Iampietro et al. - Toward the Formal Veriﬁcation of HILECOP Formaliz.pdf:application/pdf}
}